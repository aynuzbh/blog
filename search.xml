<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>题解|2024暑期杭电多校10</title>
      <link href="/posts/ACM_2024Summer_HDU10.html"/>
      <url>/posts/ACM_2024Summer_HDU10.html</url>
      
        <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A810%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（10）</a></p><h1>(1008)HDU7548.SunBian</h1><h2 id="题意">题意</h2><p>有排成环形的 $n$ 个横着的笋，Alice 和 Bob 轮流执行如下操作，Alice 先手：</p><ul><li>选择 [1,k] 个连续的横着的笋，把它们变成竖着的</li></ul><p>不能操作者输。</p><p>给定 $n,k$ ，求谁会赢。</p><h2 id="解题思路">解题思路</h2><ul><li>当 $k=1$ 时，根据奇偶性判断赢家</li><li>当 $k\ge n$ 时，先手直接将笋全部竖置，必胜</li><li>其余情况下，后手每次都可以尽可能保证剩余区域数为偶数，最终必胜</li></ul><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k;cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=k) cout &lt;&lt; <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">1</span>) cout &lt;&lt; (n%<span class="number">2</span>?<span class="string">&#x27;A&#x27;</span>:<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1009)HDU7549.不基本子串结构</h1><h2 id="题意-2">题意</h2><p>给定2个字符串 $a,b$ ，找到一个最小长度的字符串 $c$ ，使得 $a$ 和 $b$ 在 $c$ 中出现的次数相等且不为0，输出最小长度。</p><h2 id="解题思路-2">解题思路</h2><p>分类讨论，不妨假设 $len(a)\le len(b)$</p><ul><li>若 $a$ 在 $b$ 中出现的次数大于 $1$ ，则不存在满足条件的 $c$</li><li>若 $a$ 在 $b$ 中出现的次数为 $1$ ，则 $c=b$ ，输出 $len(b)$</li><li>若 $a$ 在 $b$ 中没有出现：<ul><li>记 $l_1$ 为 最大满足 $a[0:l]=b[len(b)-l:len(b)]$ 的 $l$</li><li>记 $l_2$ 为 最大满足 $a[len(a)-l:len(a)]=b[0:l]$ 的 $l$</li><li>答案为 $len(a)+len(b)-max(l_1,l_2)$</li></ul></li></ul><p>可以用字符串哈希进行检查和计数。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1,s2;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="keyword">if</span>(s1.<span class="built_in">length</span>()&lt;s2.<span class="built_in">length</span>()) <span class="built_in">swap</span>(s1,s2);</span><br><span class="line">    <span class="function">strHash <span class="title">h1</span><span class="params">(s1)</span>,<span class="title">h2</span><span class="params">(s2)</span></span>;</span><br><span class="line">    ll n=s1.<span class="built_in">length</span>(),m=s2.<span class="built_in">length</span>();</span><br><span class="line">    ll cnt=h1.<span class="built_in">count</span>(h2);</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt==<span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=m+n;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(len,m<span class="number">-1</span>,<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(h1.<span class="built_in">findz</span>(n-len+<span class="number">1</span>,n)==h2.<span class="built_in">findz</span>(<span class="number">1</span>,len))&#123;</span><br><span class="line">            <span class="built_in">chmin</span>(ans,n+m-len);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(len,m<span class="number">-1</span>,<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(h1.<span class="built_in">findf</span>(<span class="number">1</span>,len)==h2.<span class="built_in">findf</span>(m-len+<span class="number">1</span>,m))&#123;</span><br><span class="line">            <span class="built_in">chmin</span>(ans,n+m-len);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>（1011）HDU7551.NOI2024</h1><h2 id="题意-3">题意</h2><p>$m$ 名选手进行 $n$ 场比赛，排名定义为分数严格大于你的人数+1。<br>第 $i$ 场比赛的分数上限为 $b_i$ ，你的排名为 $a_i$ 。<br>最终按照每场比赛的总分排名，前 $k$ 名选手将获得金牌。<br>问在给定条件下不管怎么比赛，是否一定能获得金牌。</p><h2 id="解题思路-3">解题思路</h2><p>用最坏情况考虑：你始终为 $0$ 分，在你前面的选手都有分数。<br>最终最坏排名为 $\min(\sum_{i=1}^{n}a_i,m)$ 。</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="built_in">create_vec</span>(a,n);</span><br><span class="line">    <span class="built_in">create_vec</span>(b,n);</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cnt+=<span class="built_in">max</span>(<span class="number">0ll</span>,a[i]<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">chmin</span>(cnt,m<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;=k) cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期杭电多校09</title>
      <link href="/posts/ACM_2024Summer_HDU09.html"/>
      <url>/posts/ACM_2024Summer_HDU09.html</url>
      
        <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A89%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（9）</a></p><h1>(1005)HDU7533.怪物猎人</h1><h2 id="题意">题意</h2><p>攻击生命值为 $k$ 的怪物，每回合可选择造成 $x$ 或 $y$ 点伤害。<br>分别回答是否有一种攻击序列，可以恰好在第奇数回合/第偶数回合击杀怪物。</p><h2 id="解题思路">解题思路</h2><p>最边缘的情况即为全用 $x$ 和 全用 $y$ ，分别需要 $\lceil \frac{k}{x}\rceil$ 和 $\lceil \frac{k}{y}\rceil$ 回合。</p><p>这两个回合数相等，只有一种可能，否则都可以。</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,a,b;cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    ll ta,tb;</span><br><span class="line">    ta=(n+a<span class="number">-1</span>)/a;</span><br><span class="line">    tb=(n+b<span class="number">-1</span>)/b;</span><br><span class="line">    <span class="keyword">if</span>(ta==tb)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ta%<span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1007)HDU7535.小猫钓鱼</h1><h2 id="题意-2">题意</h2><p>有 $2n$ 张牌，点数 $1\sim n$ 各出现2次。<br>两人各分到 $n$ 张牌，已知每个人手中牌的点数。<br>两人轮流放牌到牌堆顶，若牌堆中此前已经有相同点数的牌，则将这两张牌以及中间的所有牌拿回手中。<br>先打完的人输。</p><h2 id="解题思路-2">解题思路</h2><p>称手牌中成对的牌为双牌，单独的牌为单牌。</p><p>当自己打出单牌时，对方必定能打出一样的单牌收回，且先后手不变，这样是不优的。<br>因此，贪心的打法是先手打双牌，后手打双牌，先手打上次打的双牌。<br>这样的结果是：后手失去一个双牌，交换先后手。</p><p>观察到两人手牌中的双牌的数量相同，因此有双牌的情况下，后手先失去所有双牌，先手获胜。<br>否则，后手可以稳定收取先手打出的牌，后手获胜。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    map&lt;ll,<span class="type">int</span>&gt; mp;</span><br><span class="line">    ll t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        mp[t]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">if</span>(mp.<span class="built_in">size</span>()&lt;n) cout &lt;&lt; <span class="string">&quot;shuishui&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;sha7dow&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期牛客多校10</title>
      <link href="/posts/ACM_2024Summer_NCD10.html"/>
      <url>/posts/ACM_2024Summer_NCD10.html</url>
      
        <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81605">2024牛客暑期多校训练营10</a></p><h1>A.Surrender to My Will</h1><h2 id="题意">题意</h2><p>给定一个长度为 $5$ 的字符串，<code>Y</code>代表投降，<code>N</code>代表不投降，<code>-</code>代表未投票。<br>投降人数不小于4人即可投降。<br>问字符串表示的投降结果。</p><h2 id="解题思路">解题思路</h2><p>计数判断</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;cin &gt;&gt; s;</span><br><span class="line">    map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s) mp[c]++;</span><br><span class="line">    <span class="keyword">if</span>(mp[<span class="string">&#x27;Y&#x27;</span>]&gt;=<span class="number">4</span>) &#123;cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(mp[<span class="string">&#x27;N&#x27;</span>]&gt;=<span class="number">2</span>) &#123;cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.std::pair</h1><h2 id="题意-2">题意</h2><p>基础合法类型<code>int</code>和<code>double</code>。<br>对于任意2个合法类型<code>A</code>和<code>B</code>，<code>pair&lt;A,B&gt;</code>是合法的，可以通过<code>.first</code>和<code>.second</code>分别访问<code>A</code>和<code>B</code>成员。<br>声明变量的格式为<code>pair&lt;A,B&gt; 变量名;</code>。</p><p>给定 $n$ 个字符串表示变量声明，变量名不重复。<br>再给定 $q$ 个字符串表示访问变量，返回被查询的成员类型。</p><h2 id="解题思路-2">解题思路</h2><p>模拟题，对每个变量类型构建二叉树，查询在二叉树上进行。<br>具体实现方式可以参考代码。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">pll v[N]; <span class="comment">//pair的树，x表示左子树，y表示右子树</span></span><br><span class="line">map&lt;string,ll&gt; dict; <span class="comment">//变量二叉树的根所在下标</span></span><br><span class="line">ll cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function">pll <span class="title">parse_type</span><span class="params">(string s)</span></span>&#123; <span class="comment">//解析类型，构建树</span></span><br><span class="line">    <span class="keyword">if</span>(s==<span class="string">&quot;int&quot;</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;; <span class="comment">//int</span></span><br><span class="line">    <span class="keyword">if</span>(s==<span class="string">&quot;double&quot;</span>) <span class="keyword">return</span> &#123;<span class="number">-2</span>,<span class="number">-2</span>&#125;; <span class="comment">//double</span></span><br><span class="line">    s=s.<span class="built_in">substr</span>(<span class="number">5</span>,s.<span class="built_in">length</span>()<span class="number">-6</span>); </span><br><span class="line">    ll cntp=<span class="number">0</span>,cntd=<span class="number">0</span>,pos;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,s.<span class="built_in">length</span>()<span class="number">-1</span>)&#123; <span class="comment">//找到当前pair对应的逗号位置pos</span></span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;p&#x27;</span>) cntp++;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;,&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cntp==cntd) &#123;pos=i;<span class="keyword">break</span>;&#125; </span><br><span class="line">            cntd++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string ltype=s.<span class="built_in">substr</span>(<span class="number">0</span>,pos),rtype=s.<span class="built_in">substr</span>(pos+<span class="number">1</span>,s.<span class="built_in">length</span>()-pos<span class="number">-1</span>);</span><br><span class="line">    ll lidx=cnt++,ridx=cnt++;</span><br><span class="line">    v[lidx]=<span class="built_in">parse_type</span>(ltype);</span><br><span class="line">    v[ridx]=<span class="built_in">parse_type</span>(rtype);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(lidx,ridx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">get_type</span><span class="params">(ll idx)</span></span>&#123; <span class="comment">//重组类型字符串</span></span><br><span class="line">    <span class="keyword">if</span>(v[idx].x==<span class="number">-1</span>) <span class="keyword">return</span> <span class="string">&quot;int&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(v[idx].x==<span class="number">-2</span>) <span class="keyword">return</span> <span class="string">&quot;double&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;pair&lt;&quot;</span>+<span class="built_in">get_type</span>(v[idx].x)+<span class="string">&quot;,&quot;</span>+<span class="built_in">get_type</span>(v[idx].y)+<span class="string">&quot;&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,q;cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    string type,name;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; type &gt;&gt; name;</span><br><span class="line">        name.<span class="built_in">pop_back</span>();</span><br><span class="line">        dict[name]=cnt++;</span><br><span class="line">        v[dict[name]]=<span class="built_in">parse_type</span>(type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,q)&#123;</span><br><span class="line">        cin &gt;&gt; name;</span><br><span class="line">        ll j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;name.<span class="built_in">length</span>()&amp;&amp;name[j]!=<span class="string">&#x27;.&#x27;</span>) j++;</span><br><span class="line">        string main_name=name.<span class="built_in">substr</span>(<span class="number">0</span>,j); j++;</span><br><span class="line">        ll idx=dict[main_name];</span><br><span class="line">        <span class="keyword">while</span>(j&lt;name.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(name[j]==<span class="string">&#x27;f&#x27;</span>)&#123; <span class="comment">//first</span></span><br><span class="line">                idx=v[idx].x;</span><br><span class="line">                j+=<span class="number">6</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(name[j]==<span class="string">&#x27;s&#x27;</span>)&#123; <span class="comment">//second</span></span><br><span class="line">                idx=v[idx].y;</span><br><span class="line">                j+=<span class="number">7</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">get_type</span>(idx) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>F.Collinear Exception</h1><h2 id="题意-3">题意</h2><p>有一 $n\times n$ 的点阵列，每个点的坐标为 $(i,j)$ ，$1\leq i,j\leq n$ 。<br>按给定序列对点进行标记，要求标记后不能存在三个被标记点共线，否则标记失败。<br>按给定序列顺序输出每个点是否标记成功。</p><h2 id="解题思路-3">解题思路</h2><p>每当加入一个新的点时，和已有的点连线，标记线上的所有点。<br>被标记的点不能再被加入。</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vis</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    vector&lt;pll&gt; points;</span><br><span class="line">    ll ub=n*n,xx,yy,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,ub)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; xx &gt;&gt; yy;</span><br><span class="line">        <span class="keyword">if</span>(vis[xx][yy])&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>[tx,ty]:points)&#123; <span class="comment">//标记线上的点</span></span><br><span class="line">            <span class="keyword">if</span>(xx==tx)&#123;</span><br><span class="line">                <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n) vis[xx][j]=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ll dx=xx-tx,dy=yy-ty;</span><br><span class="line">                ll g=__gcd(dx,dy);</span><br><span class="line">                dx/=g;dy/=g;</span><br><span class="line">                ll ttx=tx,tty=ty;</span><br><span class="line">                <span class="keyword">while</span>(ttx&lt;=n&amp;&amp;ttx&gt;=<span class="number">1</span>&amp;&amp;tty&lt;=n&amp;&amp;tty&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">                    vis[ttx][tty]=<span class="number">1</span>;</span><br><span class="line">                    ttx+=dx; tty+=dy;</span><br><span class="line">                &#125;</span><br><span class="line">                ttx=tx; tty=ty;</span><br><span class="line">                <span class="keyword">while</span>(ttx&lt;=n&amp;&amp;ttx&gt;=<span class="number">1</span>&amp;&amp;tty&lt;=n&amp;&amp;tty&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">                    vis[ttx][tty]=<span class="number">1</span>;</span><br><span class="line">                    ttx-=dx; tty-=dy;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        points.<span class="built_in">emplace_back</span>(xx,yy);</span><br><span class="line">        vis[xx][yy]=<span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>H.All-in at the Pre-flop</h1><h2 id="题意-4">题意</h2><p>两名玩家初始分别有 $a,b$ 的筹码，每轮游戏各有 $\frac{1}{2}$ 的概率获胜。<br>假设当前轮两名玩家分别有 $x,y$ 的筹码，那么输家需要付给赢家 $\min(x,y)$ 的筹码。<br>问两名玩家获胜的概率。</p><h2 id="解题思路-4">解题思路</h2><p>打个表，观察到答案是 $\frac{a}{a+b},\frac{b}{a+b}$ 。</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a,b;cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    ll c=<span class="built_in">inv</span>(<span class="built_in">add</span>(a,b));</span><br><span class="line">    cout &lt;&lt; <span class="built_in">mul</span>(a,c) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">mul</span>(b,c) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期牛客多校09</title>
      <link href="/posts/ACM_2024Summer_NCD09.html"/>
      <url>/posts/ACM_2024Summer_NCD09.html</url>
      
        <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81604">2024牛客暑期多校训练营9</a></p><h1>A.Image Scaling</h1><h2 id="题意">题意</h2><p>给定由 <code>.</code> 和 <code>x</code> 组成的 $n\times m$ 的 $n\times m$ 矩阵，$x$ 部分是一个子矩阵。<br>提取并在长宽比不变的情况下，将子矩阵尽可能缩小并输出。</p><h2 id="解题思路">解题思路</h2><p>模拟，缩小到 $1/gcd$</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ll fl=<span class="number">0</span>,st=<span class="number">-1</span>;</span><br><span class="line">    ll nn=<span class="number">-1</span>,mm,idx;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(fl) <span class="keyword">if</span>(s[idx]!=<span class="string">&#x27;x&#x27;</span>) &#123;nn=i-st;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">FORLL</span>(j,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j]==<span class="string">&#x27;x&#x27;</span>)&#123;</span><br><span class="line">                    fl=<span class="number">1</span>; st=i; idx=j;</span><br><span class="line">                    ll t=j;</span><br><span class="line">                    <span class="keyword">while</span>(t&lt;m&amp;&amp;s[t]==<span class="string">&#x27;x&#x27;</span>) t++;</span><br><span class="line">                    mm=t-j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nn==<span class="number">-1</span>) nn=n-st;</span><br><span class="line">    ll g=__gcd(nn,mm);</span><br><span class="line">    nn/=g; mm/=g;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,nn<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,mm<span class="number">-1</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">        &#125;cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>K.Kill The Monsters</h1><h2 id="题意-2">题意</h2><p>$n$ 个怪兽，第 $i$ 个怪兽的体力为 $a_i$ 。</p><p>每次可以进行一种操作：</p><ol><li>所有怪兽体力 $-1$</li><li>选择一个怪兽 $i$ 使得 $a_i\leftarrow \lfloor \dfrac{a_i}{k} \rfloor$</li></ol><p>问最少多少次操作可以使所有怪兽的体力都为 $0$ 。</p><h2 id="解题思路-2">解题思路</h2><p>贪心的，先连续对最大体力的怪兽进行第二种操作，再进行第一种操作。<br>用优先队列维护最大体力。<br>记当前已经操作了 $cnt$ 次，用 $a_{max}+cnt$ 维护最小操作次数。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k,t;cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    priority_queue&lt;ll&gt; pq;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) &#123;cin &gt;&gt; t;pq.<span class="built_in">push</span>(t);&#125;</span><br><span class="line">    ll cur=<span class="number">0</span>,ans=pq.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>) &#123;cout &lt;&lt; ans &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">while</span>(pq.<span class="built_in">top</span>()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        t=pq.<span class="built_in">top</span>();pq.<span class="built_in">pop</span>();</span><br><span class="line">        t/=k; cur++;</span><br><span class="line">        pq.<span class="built_in">push</span>(t);</span><br><span class="line">        <span class="built_in">chmin</span>(ans,pq.<span class="built_in">top</span>()+cur);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans  &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期杭电多校08</title>
      <link href="/posts/ACM_2024Summer_HDU08.html"/>
      <url>/posts/ACM_2024Summer_HDU08.html</url>
      
        <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A88%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（8）</a></p><h1>(1004)HDU7520.cats 的重力拼图</h1><h2 id="题意">题意</h2><p>有一个 $n\times m$ 的方格阵列，物块初始位于 $(x,y),1\le x\le n,1\le y\le m$。<br>每次操作可以改变重力方向：向上、向下、向左、向右，物块会沿重力方向移动，直到碰到边界。<br>求任意操作下物块最多经过的格子数。</p><h2 id="解题思路">解题思路</h2><p>有2种最贪心的操作序列：</p><ol><li>向左、向右、再沿边缘一周</li><li>向上、向下、再沿边缘一周</li></ol><p>特判 $n=1$ 或 $m=1$ 或初始在边缘的情况。</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,a,b;cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">2</span>||m&lt;=<span class="number">2</span>)&#123; cout &lt;&lt; n*m &lt;&lt; endl; <span class="keyword">return</span> ; &#125;</span><br><span class="line">    ll ans=<span class="number">2</span>*(n+m<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">1</span>||a==n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">1</span>||b==m) cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; ans+n<span class="number">-2</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(b==<span class="number">1</span>||b==m) cout &lt;&lt; ans+m<span class="number">-2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; ans+<span class="built_in">max</span>(&#123;<span class="number">0ll</span>,n<span class="number">-2</span>,m<span class="number">-2</span>&#125;) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>（1006）HDU7522.cats 的最小生成树</h1><h2 id="题意-2">题意</h2><p>给定一个有 $n$ 个节点，可能含重边的带权无向图， $m$ 条边按顺序给出，第 $i$ 条边的权值为 $i$。<br>每次删去当前图的最小生成树的所有边，直到图不连通。</p><p>求每条边是在第几次被删除去的。</p><h2 id="解题思路-2">解题思路</h2><p>根据Kruskal算法思想，最小生成树加边是从小到大加入的。<br>开若干个并查集，遍历边，每次二分查找当前边最早可以加入第几个并查集。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ll ub=m/(n<span class="number">-1</span>);</span><br><span class="line">    <span class="function">vector&lt;DSU&gt; <span class="title">dsu</span><span class="params">(ub+<span class="number">2</span>,DSU(n))</span></span>;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">cnt</span><span class="params">(ub+<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">ans</span><span class="params">(m+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    ll u,v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        ll l=<span class="number">1</span>,r=ub+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            ll mid=(l+r+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">bool</span> fl=(dsu[mid].<span class="built_in">find</span>(u)==dsu[mid].<span class="built_in">find</span>(v));</span><br><span class="line">            <span class="keyword">if</span>(fl) l=mid;</span><br><span class="line">            <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll tar=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="built_in">max</span>(<span class="number">1ll</span>,l<span class="number">-3</span>),<span class="built_in">min</span>(ub+<span class="number">1</span>,l+<span class="number">3</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(dsu[i].<span class="built_in">find</span>(u)!=dsu[i].<span class="built_in">find</span>(v))&#123;</span><br><span class="line">                tar=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tar==ub+<span class="number">1</span>) &#123; ans[i]=<span class="number">-1</span>; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        dsu[tar].<span class="built_in">merge</span>(u,v);</span><br><span class="line">        cnt[tar]++; ans[i]=tar;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i]!=<span class="number">-1</span>&amp;&amp;cnt[ans[i]]==n<span class="number">-1</span>) cout &lt;&lt; ans[i];</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">Presentation</span>(i,m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1007)HDU7523.cats 的 k-xor</h1><h2 id="题意-3">题意</h2><p>给定2个十进制整数 $a,b,c$ ， $a,b$ 进行 $k(k\ge 2)$ 进制不进位加法后的结果是 $c$。<br>求 $k$ 有多少种可能。</p><h2 id="解题思路-3">解题思路</h2><p>不进位加法下，丢失的进位信息 $a+b-c$ 是 $k$ 的倍数。<br>枚举 $a+b-c$ 的因子作为 $k$ ，check是否满足条件。</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll a,ll b,ll c,ll k)</span></span>&#123;</span><br><span class="line">    ll dif=a+b-c;</span><br><span class="line">    ll cur=<span class="number">1</span>,nxt=k,s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a/cur||b/cur)&#123;</span><br><span class="line">        ll ta=a/cur%k,tb=b/cur%k;</span><br><span class="line">        s+=(ta+tb)/k*nxt;</span><br><span class="line">        cur*=k; nxt*=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s==dif;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a,b,c;cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    ll dif=a+b-c;</span><br><span class="line">    <span class="keyword">if</span>(dif==<span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ll cnt=<span class="number">0</span>,ub=<span class="built_in">sqrt</span>(dif)+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,ub) <span class="keyword">if</span>(dif%i==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i*i&gt;dif) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(a,b,c,i)) cnt++;</span><br><span class="line">        <span class="keyword">if</span>(i*i!=dif&amp;&amp;<span class="built_in">check</span>(a,b,c,dif/i)) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(a,b,c,dif)) cnt++;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>（1012）HDU7528.cats 的电脑中毒</h1><h2 id="题意-4">题意</h2><p>给定 $3$ 个长度为 $n$ 的二进制串 $a,b,c$ ， 表示病毒的初始位置。<br>每过一秒，病毒会感染相邻的所有二进制编码。（当且仅当两个二进制编码仅有一个位置不同时，这两个编码为相邻）<br>问所有的 $2^n$ 个二进制编码都被感染需要多少时间。</p><h2 id="解题思路-4">解题思路</h2><p>考虑最后一秒被感染的二进制串，它的 距离三个初始位置的最小汉明距离 最大，找到这个串。<br>设这个串为 $s$ ，枚举每一位。若三个初始位置的这一位上，1的数量较多，则设为0；否则设为1。<br>然后进行微调，使得 $s$ 到三个初始位置的最小汉明距离 最大。</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ll n;</span><br><span class="line"><span class="function">ll <span class="title">dis</span><span class="params">(string s1,string s2)</span></span>&#123;</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cnt+=(s1[i]!=s2[i]);</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string s[<span class="number">3</span>],<span class="built_in">ns</span>(n,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,<span class="number">2</span>) cin &gt;&gt; s[i];</span><br><span class="line">    ll cnta=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> cnt1=<span class="number">0</span>,t=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,<span class="number">2</span>) <span class="keyword">if</span>(s[j][i]==<span class="string">&#x27;1&#x27;</span>) cnt1++;</span><br><span class="line">        ns[i]=(cnt1&gt;=<span class="number">2</span>)?<span class="string">&#x27;0&#x27;</span>:<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll dis0=<span class="built_in">dis</span>(s[<span class="number">0</span>],ns),dis1=<span class="built_in">dis</span>(s[<span class="number">1</span>],ns),dis2=<span class="built_in">dis</span>(s[<span class="number">2</span>],ns);</span><br><span class="line">    <span class="keyword">while</span>(dis0&lt;dis1<span class="number">-1</span>&amp;&amp;dis0&lt;dis2<span class="number">-1</span>)&#123; dis0++; dis1--; dis2--; &#125;</span><br><span class="line">    <span class="keyword">while</span>(dis1&lt;dis0<span class="number">-1</span>&amp;&amp;dis1&lt;dis2<span class="number">-1</span>)&#123; dis1++; dis0--; dis2--; &#125;</span><br><span class="line">    <span class="keyword">while</span>(dis2&lt;dis0<span class="number">-1</span>&amp;&amp;dis2&lt;dis1<span class="number">-1</span>)&#123; dis2++; dis0--; dis1--; &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(&#123;dis0,dis1,dis2&#125;) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期杭电多校07</title>
      <link href="/posts/ACM_2024Summer_HDU07.html"/>
      <url>/posts/ACM_2024Summer_HDU07.html</url>
      
        <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A87%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（7）</a></p><h1>(1010)HDU7514.故障机器人想活下去</h1><h2 id="题意">题意</h2><p>故障机器人有 $x$ 点血量。<br>他将按顺序进行 $n$ 场战斗，第 $i$ 场战斗会受到 $a_i$ 点伤害。<br>故障机器人还有 $k$ 个烟雾弹，每个烟雾弹可以让他跳过一场战斗而不受伤害。</p><p>问故障机器人最多能活到第几场战斗结束。</p><h2 id="解题思路">解题思路</h2><p>维护当前最高的 $k$ 个伤害，作为被跳过的伤害。<br>统计受伤量，直到受伤量超过 $x$ 为止。</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,x,k;cin &gt;&gt; n &gt;&gt; x &gt;&gt; k;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    priority_queue&lt;ll,vector&lt;ll&gt;,less&lt;ll&gt;&gt; pq;</span><br><span class="line">    ll S=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        S+=v[i];</span><br><span class="line">        pq.<span class="built_in">push</span>(v[i]);</span><br><span class="line">        <span class="keyword">while</span>(S&gt;=x)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;=k)&#123;</span><br><span class="line">                cout &lt;&lt; pq.<span class="built_in">size</span>()+cnt<span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            S-=pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1011)HDU7515.蛋糕上的草莓是蛋糕的灵魂</h1><h2 id="题意-2">题意</h2><p>有 $x$ 个相同的草莓和 $y$ 个相同的蛋糕。<br>每次可以将当前所有草莓或蛋糕放在一起切 $m$ 刀，即份数变为此前的 $2m$ 倍。<br>在满足条件的情况下切草莓的次数尽可能少。<br>求出最终草莓和蛋糕的数量。</p><h2 id="解题思路-2">解题思路</h2><p>贪心的，观察到蛋糕是不用切的，将草莓切到 $\gcd(x,y)$ 份即可。<br>若 $\gcd$ 是 $x$ 的奇数倍，需要多来一刀。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y;cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    ll g=__gcd(x,y);</span><br><span class="line">    <span class="keyword">if</span>(y/g&gt;<span class="number">1</span>&amp;&amp;(y/g)%<span class="number">2</span>) cout &lt;&lt; y &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x/g*<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; y &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x/g &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期牛客多校08</title>
      <link href="/posts/ACM_2024Summer_NCD08.html"/>
      <url>/posts/ACM_2024Summer_NCD08.html</url>
      
        <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81603">2024牛客暑期多校训练营8</a></p><h1>A.Haitang and Game</h1><h2 id="题意">题意</h2><p>给定一个包含 $n$ 个数的正整数集合 $S$ ，每次可以从中选择两个数 $x,y$ 满足 $x,y\in S,\gcd(x,y)\notin S$，将 $\gcd(x,y)$ 加入 $S$ 。<br>最多加入数的个数是奇数输出<code>dXqwq</code>，否则输出<code>Haitang</code>。</p><h2 id="解题思路">解题思路</h2><p>考虑最终集合中的数 $d$ ，一定满足原集合中，它的所有倍数的 $gcd$ 等于它。<br>从小到大枚举 $d$ ，如果 $d$ 满足上述条件且不在原集合中，计数。</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    unordered_set&lt;ll&gt; s;</span><br><span class="line">    ll mx=<span class="number">-1</span>,t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        s.<span class="built_in">insert</span>(t);</span><br><span class="line">        <span class="built_in">chmax</span>(mx,t);</span><br><span class="line">    &#125;</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,mx)&#123;</span><br><span class="line">        ll fl=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll j=i;j&lt;=mx;j+=i)</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">count</span>(j)) fl=__gcd(fl,j);</span><br><span class="line">        <span class="keyword">if</span>(fl==i&amp;&amp;!s.<span class="built_in">count</span>(i)) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt%<span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;dXqwq\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Haitang\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>J.Haitang and Triangle</h1><h2 id="题意-2">题意</h2><p>构造一个长度为 $n$ 的排列，它恰有 $m$ 个长度为 $3$ 的子区间满足子区间的三个数能构成非退化三角形。</p><h2 id="解题思路-2">解题思路</h2><p>构造一个长度为 $n-m$ 的排列，它不含能够构成非退化三角形的长度为 $3$ 的子区间。<br>我使用的方法是把 $1\sim n-m$ 从大到小均分成三组，第1组降序，其他组升序，按321的顺序放置。<br>假设 $n-m=7$ ，分成 $[2,1],[3,4],[5,6,7]$ ，排列为 $5,3,2,\ 6,4,1,\ 7$ 。</p><p>剩下 $m$ 个数降序放在排列的前面，和上面的排列合并形成 $m$ 个合法区间。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ll t = n-m;</span><br><span class="line">    <span class="keyword">if</span>(t&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    deque&lt;ll&gt; v[<span class="number">3</span>];</span><br><span class="line">    ll t1=t/<span class="number">3</span>,t2=t%<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,t1) v[<span class="number">0</span>].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,t1+<span class="number">1</span>,t1*<span class="number">2</span>+(t2&gt;<span class="number">1</span>)) v[<span class="number">1</span>].<span class="built_in">emplace_front</span>(i);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,t1*<span class="number">2</span>+(t2&gt;<span class="number">1</span>)+<span class="number">1</span>,t) v[<span class="number">2</span>].<span class="built_in">emplace_front</span>(i);</span><br><span class="line">    <span class="comment">// FORLL(i,0,2) print_vec(v[i]);</span></span><br><span class="line">    vector&lt;ll&gt; ans;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,t1)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;v[<span class="number">2</span>].<span class="built_in">size</span>()) ans.<span class="built_in">emplace_back</span>(v[<span class="number">2</span>][i]);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;v[<span class="number">1</span>].<span class="built_in">size</span>()) ans.<span class="built_in">emplace_back</span>(v[<span class="number">1</span>][i]);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;v[<span class="number">0</span>].<span class="built_in">size</span>()) ans.<span class="built_in">emplace_back</span>(v[<span class="number">0</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,n,t+<span class="number">1</span>) cout &lt;&lt; i &lt;&lt; <span class="built_in">Presentation</span>(i,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,t<span class="number">-1</span>) cout &lt;&lt; ans[i] &lt;&lt; <span class="built_in">Presentation</span>(i,t<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>K.Haitang and Ava</h1><h2 id="题意-3">题意</h2><p>判断给定字符串是否仅由若干个 <code>ava</code> 和 <code>avava</code> 组成。</p><h2 id="解题思路-3">解题思路</h2><p>从 $i=1$ 开始，对于当前位置开头，先检查长度为 $5$ 的子串是否是 <code>avava</code> ，再检查长度为 $3$ 的子串是否是 <code>ava</code> ，如果是，就跳过这个子串；否则输出<code>NO</code>。</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pat1 = <span class="string">&#x27;ava&#x27;</span></span><br><span class="line">pat2 = <span class="string">&#x27;avava&#x27;</span></span><br><span class="line"></span><br><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    s = <span class="built_in">input</span>()</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">        <span class="keyword">if</span> i+<span class="number">5</span>&lt;=<span class="built_in">len</span>(s) <span class="keyword">and</span> s[i:i+<span class="number">5</span>] == pat2:</span><br><span class="line">            i += <span class="number">5</span></span><br><span class="line">        <span class="keyword">elif</span> i+<span class="number">3</span>&lt;=<span class="built_in">len</span>(s) <span class="keyword">and</span> s[i:i+<span class="number">3</span>] == pat1:</span><br><span class="line">            i += <span class="number">3</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;No&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Yes&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期牛客多校07</title>
      <link href="/posts/ACM_2024Summer_NCD07.html"/>
      <url>/posts/ACM_2024Summer_NCD07.html</url>
      
        <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81702">2024牛客暑期多校训练营7</a></p><h1>I.Fight Against the Monster</h1><h2 id="题意">题意</h2><p>瓶子换水问题。 $m$ 个空瓶可以换 $k$ 瓶水， 求一共要喝 $h$ 瓶水，初始最少需要多少瓶水。</p><h2 id="解题思路">解题思路</h2><p>二分check。</p><p>设初始有 $x$ 瓶水，换水次数为 $\dfrac{x-m}{m-k}+1=\dfrac{x-k}{m-k}$。<br>每次换水产生 $k$ 瓶水，总共 $x+k\cdot \dfrac{x-k}{m-k}$ 瓶水。</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(ll m,ll k,ll h,ll x)</span></span>&#123;</span><br><span class="line">    ll t=(x-k)/(m-k)*k+x;   </span><br><span class="line">    <span class="keyword">if</span>(t&gt;=h) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,k,h;cin &gt;&gt; m &gt;&gt; k &gt;&gt; h;</span><br><span class="line">    <span class="keyword">if</span>(h&lt;=m)&#123;cout &lt;&lt; h &lt;&lt; endl;<span class="keyword">return</span>;&#125; <span class="comment">//不用换</span></span><br><span class="line">    <span class="keyword">if</span>(m&lt;=k)&#123;cout &lt;&lt; m &lt;&lt; endl;<span class="keyword">return</span>;&#125; <span class="comment">//生生不息</span></span><br><span class="line">    ll l=<span class="number">0</span>,r=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        ll mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(m,k,h,mid)) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="built_in">max</span>(<span class="number">0ll</span>,l<span class="number">-10</span>),r+<span class="number">10</span>) <span class="keyword">if</span>(<span class="built_in">check</span>(m,k,h,i)) &#123;cout &lt;&lt; i &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>J.Ball</h1><h2 id="题意-2">题意</h2><p>给定一根左端点为 $(0,0)$ 垂直于y轴长度为 $l$ 的棍子。<br>在上面找一个支点使得棍子绕支点旋转可以碰到位于 $(x,y)$ 的小球。</p><h2 id="解题思路-2">解题思路</h2><p>支点位于两端时扫过的面积可覆盖所有情况。<br>判断小球到两端的距离。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll l,x,y;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    ll dis1,dis2;</span><br><span class="line">    dis1=x*x+y*y;</span><br><span class="line">    dis2=(l-x)*(l-x)+y*y;</span><br><span class="line">    <span class="keyword">if</span>(dis1&gt;l*l&amp;&amp;dis2&gt;l*l) &#123; cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(dis1&lt;dis2) cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期杭电多校06</title>
      <link href="/posts/ACM_2024Summer_HDU06.html"/>
      <url>/posts/ACM_2024Summer_HDU06.html</url>
      
        <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A86%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（6）</a></p><h1>(1001)HDU7494 造花（简单版）</h1><h2 id="题意">题意</h2><p>给定一棵 $n$ 个节点的树，问能否通过删去一个节点，使得剩下的节点组成2个连通块，且每个连通块都是一个菊花图。</p><p>菊花图是一棵树，且存在唯一中心点与其他所有节点之间有一条边。特殊的，只有一个节点的树也是菊花图。</p><h2 id="解题思路">解题思路</h2><p>一棵树删去一个点得到两个连通块，那么删去的点的度必定为2。</p><p>这个删去的点 $u$ 和得到的两个菊花图的中心点 $v_1,v_2$ 有三种情况：</p><ol><li>$u$ 和 $v_1,v_2$ 直接相连</li><li>$u$ 和 $v_1$ 直接相连，和 $v_2$ 的距离为2</li><li>$u$ 和 $v_1,v_2$ 的距离都为2</li></ol><p>记录度大于1的节点，这些点是关键节点，可能是中心点，也可能是删去的点。</p><p>度大于1的节点数最多的情况是第三种，最多有5个度大于1的节点，形如：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  8       9</span><br><span class="line">  |       |</span><br><span class="line">1<span class="string">-2</span><span class="string">-3</span><span class="string">-4</span><span class="string">-5</span><span class="string">-6</span><span class="string">-7</span></span><br><span class="line">  |       |</span><br><span class="line">  10      11</span><br></pre></td></tr></table></figure><p>删去点 $u$ 后，剩余度大于1的节点必定是中心点，个数不大于 $2-t$ 即满足。<br>其中， $t$ 是删点后仅由不多于$2$个点组成的连通块的个数。</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">G</span>(n+<span class="number">1</span>);</span><br><span class="line">    ll u,v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">        G[v].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;ll&gt; crit; <span class="comment">//关键点</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(G[i].<span class="built_in">size</span>()&gt;<span class="number">1</span>) crit.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    <span class="keyword">if</span>(crit.<span class="built_in">size</span>()&gt;<span class="number">5</span>) &#123;cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;<span class="keyword">return</span>;&#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> u:crit) <span class="keyword">if</span>(G[u].<span class="built_in">size</span>()==<span class="number">2</span>)&#123; <span class="comment">//枚举删除的点</span></span><br><span class="line">        ll cnt2=<span class="number">0</span>,cnt1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:G[u])&#123; <span class="comment">//相邻的2个点</span></span><br><span class="line">            <span class="keyword">if</span>(G[v].<span class="built_in">size</span>()==<span class="number">2</span>)&#123; </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> w:G[v])  <span class="comment">//w==u:这一端的连通块只有2个节点</span></span><br><span class="line">                <span class="keyword">if</span>(w!=u) <span class="keyword">if</span>(G[w].<span class="built_in">size</span>()&gt;<span class="number">1</span>) cnt2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(G[v].<span class="built_in">size</span>()==<span class="number">1</span>) cnt1++; <span class="comment">//这一端的连通块只有1个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        ll t=crit.<span class="built_in">size</span>()<span class="number">-1</span>-cnt2;</span><br><span class="line">        <span class="keyword">if</span>(t&lt;=<span class="number">2</span>-cnt1) &#123; cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1003)HDU7496 飞车狂飙</h1><h2 id="题意-2">题意</h2><p>给定一个长度为 $n$ 的字符串，包含：</p><ol><li><code>L</code> ：表示左转的方块</li><li><code>R</code> ：表示右转的方块</li><li><code>S</code> ：表示直行的方块</li></ol><p>从原点开始，按照字符串给定的顺序，先放置，再按照给定的方向移动。</p><p>合法的字符串满足：</p><ol><li>不在同一位置放置两个方块</li><li>所有方块形成一个环</li></ol><p>问给定的字符串是否合法。</p><h2 id="解题思路-2">解题思路</h2><p>模拟。<br>每走一步更新沿途放置了方块的坐标和当前方向。<br>中途检查是否有重复放置的方块，最后检查是否回到原点、方向是否回正。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        0 1 2 3</span></span><br><span class="line"><span class="type">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pll cur=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dir=<span class="number">0</span>; <span class="comment">//0:up 1:left 2:down 3:right</span></span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    string s;cin &gt;&gt; s;</span><br><span class="line">    map&lt;pll,<span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">count</span>(cur))&#123;  cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">        mp[cur]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;L&#x27;</span>) dir=(dir+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;R&#x27;</span>) dir=(dir+<span class="number">3</span>)%<span class="number">4</span>;</span><br><span class="line">        cur.first+=dx[dir];</span><br><span class="line">        cur.second+=dy[dir];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur.first==<span class="number">0</span>&amp;&amp;cur.second==<span class="number">0</span>&amp;&amp;dir==<span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1004)HDU7497 不醒人室</h1><h2 id="题意-3">题意</h2><p>给定 $n$ 个上课时间段， $m$ 个睡觉时间段。</p><p>初始状态是不清醒。<br>每个睡觉时间段 $[s,t]$ 能使接下来 $2(t-s)$ 的时间，也就是 $[t,t+2(t-s)]$ 时间段内保持清醒。<br>睡觉提供的清醒时间段不会叠加，以此前最后一个睡觉时间段为准。</p><p>问给定的时间段能否满足以下条件：</p><ol><li>上课时间保持清醒</li><li>上课时间不能睡觉</li></ol><h2 id="解题思路-3">解题思路</h2><p>将所有时间段排序，从左往右遍历：</p><ol><li>当前是上课时间段，检查：<ol><li>上课开始时间是否晚于最后一个睡觉时间段的结束时间</li><li>上课结束时间是否早于最后一次睡觉提供的清醒时间段的结束时间</li></ol></li><li>当前是睡觉时间段，检查睡觉时间是否晚于上一节课的结束时间</li></ol><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;pair&lt;pll,<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(m+n);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; v[i].first.first &gt;&gt; v[i].first.second;</span><br><span class="line">        v[i].second = <span class="number">0</span>; <span class="comment">//上课</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,n,n+m<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; v[i].first.first &gt;&gt; v[i].first.second;</span><br><span class="line">        v[i].second = <span class="number">1</span>; <span class="comment">//睡觉</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    ll b,e,s,t; <span class="comment">//上次上课时间[b,e]，上次睡觉时间[s,t]</span></span><br><span class="line">    b=e=s=t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [tp,op]:v)&#123;</span><br><span class="line">        <span class="keyword">auto</span> [x,y] = tp;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">0</span>)&#123; <span class="comment">//上课</span></span><br><span class="line">            <span class="keyword">if</span>(x&lt;t)&#123; cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;<span class="keyword">return</span>;&#125; <span class="comment">//上课开始还在睡觉</span></span><br><span class="line">            <span class="keyword">if</span>(t+<span class="number">2</span>*(t-s)&lt;y) &#123;cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;<span class="keyword">return</span>;&#125; <span class="comment">//上次没睡够支撑不到下课</span></span><br><span class="line">            b=x;e=y;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">            <span class="keyword">if</span>(x&lt;e)&#123; cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;<span class="keyword">return</span>;&#125; <span class="comment">//还没下课就睡觉</span></span><br><span class="line">            s=x;t=y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1005)HDU7498 交通管控</h1><h2 id="题意-4">题意</h2><p>有 $k$ 盏红绿灯，每盏灯有三种状态：绿色<code>A</code>、黄色<code>B</code>、红色<code>C</code>。</p><p>一个操作用一个长度为 $k$ 的字符串表示，一个字符对应一盏灯。<br>字符串中包含：</p><ol><li><code>+</code>：红变绿、绿变黄、黄变红</li><li><code>-</code>：绿变红、黄变绿、红变黄</li><li><code>0</code>：不变</li></ol><p>交警有一个长度为 $n$ 的操作序列，他可以按顺序对每个操作选择执行或不执行。</p><p>问最后能达到哪些状态，以及每种状态对应的 操作序列种数。</p><h2 id="解题思路-4">解题思路</h2><p>状态压缩DP。</p><p>用一个 $k$ 位3进制数表示 $k$ 盏灯的状态，每一位表示一盏灯的状态：0绿、1黄、2红。<br>记：</p><ul><li>$dp[i][x]$ 表示前 $i$ 个操作，状态为 $x$ 的方案数。</li><li>$op(x,i)$ 表示状态 $x$ 经过第 $i$ 个操作后的状态。</li></ul><p>状态转移方程：$dp[i][x]=dp[i-1][x]+\sum\limits_{j}^{st\in stat[i-1],op(st,i)=j} dp[i-1][st]$<br>其中，$stat[i-1]$ 表示第 $i-1$ 个操作后的所有状态。</p><p>利用滚动数组可以实现空间优化。</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ll&gt; pow3;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pow3.<span class="built_in">emplace_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,<span class="number">20</span>) pow3.<span class="built_in">emplace_back</span>(pow3.<span class="built_in">back</span>()*<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">ll n,k;</span><br><span class="line"><span class="comment">//在x的3进制，第idx位，+d再对3取模</span></span><br><span class="line"><span class="function">ll <span class="title">opadd</span><span class="params">(ll x,ll idx,ll d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d==<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    ll t = x/pow3[idx]%<span class="number">3</span>;</span><br><span class="line">    t = (t+d+<span class="number">3</span>)%<span class="number">3</span>-t;</span><br><span class="line">    <span class="keyword">return</span> x + t*pow3[idx];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0A1B2C</span></span><br><span class="line"><span class="function">string <span class="title">trans</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,k<span class="number">-1</span>)&#123;</span><br><span class="line">        s += <span class="built_in">char</span>(<span class="string">&#x27;A&#x27;</span>+x%<span class="number">3</span>);</span><br><span class="line">        x /= <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    cin &gt;&gt; MODULE::MOD;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s:v) cin &gt;&gt; s;</span><br><span class="line">    map&lt;ll,ll&gt; dp[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> fl=<span class="number">0</span>;</span><br><span class="line">    dp[fl].<span class="built_in">insert</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;); fl^=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s:v)&#123;</span><br><span class="line">        dp[fl]=dp[fl^<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [v,cnt]:dp[fl^<span class="number">1</span>])&#123;</span><br><span class="line">            ll t=v;</span><br><span class="line">            <span class="built_in">FORLL</span>(i,<span class="number">0</span>,k<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;+&#x27;</span>) t=<span class="built_in">opadd</span>(t,i,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;-&#x27;</span>) t=<span class="built_in">opadd</span>(t,i,<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">addto</span>(dp[fl][t],cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        fl^=<span class="number">1</span>;</span><br><span class="line">    &#125;fl^=<span class="number">1</span>;</span><br><span class="line">    map&lt;string,ll&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v,cnt]:dp[fl]) ans.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="built_in">trans</span>(v),(ll)cnt));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [s,cnt]:ans) cout &lt;&lt; s &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期杭电多校05</title>
      <link href="/posts/ACM_2024Summer_HDU05.html"/>
      <url>/posts/ACM_2024Summer_HDU05.html</url>
      
        <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A85%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（5）</a></p><h1>(1002)HDU7482 Array-Gift</h1><h2 id="题意">题意</h2><p>给定一个长度为 $n$ 的正整数数组 $a$ ，提供以下2种操作：</p><ol><li>选择两个不同的下标 $i,j$ ，$a_i\leftarrow a_i\ mod\ a_j$</li><li>选择一个下标 $i$ 和一个任意正整数 $x$ ，$a_i\leftarrow a_i+x$</li></ol><p>求使得数组仅有1个非0元素的最小操作次数。</p><h2 id="解题思路">解题思路</h2><p>add：做之前先对数组去重，因为重复的数可以在开始就通过操作1变为0。</p><p>考虑最坏情况的操作次数：<br>选定两个不同的下标 $i,j$ ，不妨设 $a_i&lt;=a_j$ 。（1次）<br>做操作2使得 $a_i=a_j+1$ ，再做操作1使得 $a_i=1$ 。（1次）<br>最后对每个 $k\neq i$ 做操作1：$a_k\leftarrow a_k\ mod\ a_i=0$ 。（$n-1$次）<br>最坏情况的操作次数为 $n+1$ 。</p><p>最好的情况：存在一个下标 $i$ 使得 $a_i$ 能够整除数组中所有元素。<br>满足这个条件的 $a_i$ 一定是数组中的最小值。<br>这种情况只需对每个 $k\neq i$ 做操作1：$a_k\leftarrow a_k\ mod\ a_i=0$ ，操作次数为 $n-1$ 。</p><p>由于最坏情况难以确定，考虑操作次数为 $n$ 的情况：</p><ol><li>数组 $a$ 中的最小值经过操作2 ，$\min(a)\leftarrow\min(a)+x$ ，能够整除数组中所有元素。</li><li>某个元素经过操作1，能够整除数组中所有元素。</li></ol><p>对于第二种情况，维护gcd前缀/后缀（似乎不维护也能过？）。<br>枚举被修改的数 $a_i$ 和模数 $a_j$ ，若 $a_i\ mod\ a_j=\gcd\limits_k^{k\neq i}a_k$ ，则最少操作次数为 $n$ 。</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    vector&lt;ll&gt; tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v)&#123;</span><br><span class="line">        <span class="type">int</span> fl=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> m:tmp) <span class="keyword">if</span>(x%m==<span class="number">0</span>) &#123;fl=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(fl) tmp.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    ll on=n; v=tmp; n=v.<span class="built_in">size</span>(); <span class="comment">//on是原数组大小</span></span><br><span class="line">    v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(),<span class="number">0</span>); v.<span class="built_in">insert</span>(v.<span class="built_in">end</span>(),<span class="number">0</span>); <span class="comment">//起始下标改为1</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;cout &lt;&lt; on<span class="number">-1</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">preg</span><span class="params">(n+<span class="number">2</span>,<span class="number">0</span>)</span>,<span class="title">sufg</span><span class="params">(n+<span class="number">2</span>,<span class="number">0</span>)</span></span>; </span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) preg[i]=__gcd(preg[i<span class="number">-1</span>],v[i]);</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,n,<span class="number">1</span>) sufg[i]=__gcd(sufg[i+<span class="number">1</span>],v[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sufg[<span class="number">2</span>]&gt;v[<span class="number">1</span>]&amp;&amp;sufg[<span class="number">2</span>]&lt;=v[<span class="number">2</span>]) &#123;cout &lt;&lt; on &lt;&lt; endl;<span class="keyword">return</span>;&#125; <span class="comment">//剩下的数模（v1+x）为0</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123; <span class="comment">//被修改的数</span></span><br><span class="line">        ll g=__gcd(preg[i<span class="number">-1</span>],sufg[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,i<span class="number">-1</span>)&#123;<span class="comment">//模数</span></span><br><span class="line">            ll t=v[i]%v[j];</span><br><span class="line">            <span class="keyword">if</span>(t==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(g%t==<span class="number">0</span>) &#123;cout &lt;&lt; on &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; on+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1006)HDU7486 猫罐头游戏</h1><h2 id="题意-2">题意</h2><p>有三堆猫罐头，每堆猫罐头的数量分别为 $a,b,c$ 。<br>两只猫猫进行博弈，每次可以选择一堆猫罐头全部吃掉，然后再从剩下的两堆中选择一堆猫罐头分成两份（每份至少一罐）。<br>不能操作的猫猫输掉游戏。</p><p>问先手是否有必胜策略。</p><h2 id="解题思路-2">解题思路</h2><p>最终必败态是 $a=b=c=1$ 。</p><p>当开局有3个奇数时，不论怎么操作，结果都是2奇数1偶数；<br>当开局有1个或2个偶数时，可以控制结果为3个奇数。<br>三个奇数的尽头就是3个1必败，因此开局3奇数必败，开局1或2偶数必胜。</p><p>开局全偶数的情况，可以从lowbit的角度考虑。<br>当开局三个数lowbit位于同一位时，不论怎么操作都不能使lowbit相等。<br>当开局三个数lowbit位于不同位时，可以通过操作控制lowbit相等，整个过程lowbit减小。<br>lowbit相等的尽头是三个数的lowbit都等于$1$也就是三奇数的必败态。</p><p>因此，开局三个数lowbit相等必败。<br>观察到三个数不全是偶数的情况也可以归并到这个结论中，2行秒了。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a,b,c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">lowbit</span>(a)==<span class="built_in">lowbit</span>(b)&amp;&amp;<span class="built_in">lowbit</span>(b)==<span class="built_in">lowbit</span>(c))  NO; <span class="keyword">else</span> YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1011)HDU7491 开关灯</h1><h2 id="题意-3">题意</h2><p>有 $n$ 盏灯排成一排，编号为 $1\sim n$ ，初始状态为全灭。<br>每次操作可以选择一盏灯，反转这盏灯和与之相邻的灯的状态（开变关，关变开）。<br>求任意操作后，这排灯可以到达多少种不同的状态。</p><h2 id="解题思路-3">解题思路</h2><p>观察样例发现答案满足 $2^n$ 。<br>手玩发现只有 $n\equiv2(mod\ 3)$ 时达不到全亮状态，是 $2^{n-1}$ 。</p><p>如果发现力不够，还可以考虑以下方法：<br>对位置1,2分别做一次操作，可以单独反转3；再对4,5分别做一次操作，可以单独反转6。<br>以此类推，正着做可以单独反转所有 $i\equiv0(mod\ 3)$，反着做可以单独反转所有 $i\equiv n-2(mod\ 3)$ 。<br>如果可以单独任意反转连续2个灯，则与它们相邻的灯也可以单独任意反转，以达到所有 $2^n$ 种状态。</p><p>当且仅当 $n\equiv2(mod\ 3)$ 时，正着做和反着做反转的都是同一批灯，无法通过以上操作任意反转所有的灯。<br>由于无法到达全亮状态，答案少一半，为 $2^{n-1}$ 。</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">3</span>==<span class="number">2</span>) cout &lt;&lt; <span class="built_in">qcpow</span>(<span class="number">2</span>,n<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">qcpow</span>(<span class="number">2</span>,n) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1013)HDU7493 飞行棋</h1><h2 id="题意-4">题意</h2><p>$0\sim n$ 号格子排成一排，棋子初始在 $0$ 号格，目标是精确到达第 $n$ 格。<br>每次随机从 $1\sim n$ 中均匀随机一个正整数 $x$ ，然后向前移动 $x$ 步，若移动到第 $n$ 格还有剩余步数，则会往回走。<br>如果随机到 $n$ 且最终没有精确到达第 $n$ 格，则可以再从 $1\sim n-1$ 中均匀随机一个正整数并行动。</p><p>求精确到达第 $n$ 格的期望步数。</p><h2 id="解题思路-4">解题思路</h2><p>从 $0$ 号格子一次到达第 $n$ 格的概率是 $\dfrac{1}{n}$ 。<br>从 $1\sim n-1$ 号格子一次到达第 $n$ 格的概率都是 $\dfrac{1}{n}(1+\dfrac{1}{n-1})=\dfrac{1}{n-1}$ ，期望为 $n-1$<br>如果没有到达终点，棋子只会落在 $1\sim n-1$ 号格子上。</p><p>因此答案为 $\dfrac{1}{n}+\dfrac{n-1}{n}\times ((n-1)+1)=n+1+\dfrac{1}{n}$ 。<br>（式子中 $(n-1)+1$ 是加上了从0开始的第一步）</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sub</span>(<span class="built_in">add</span>(<span class="built_in">inv</span>(n),n),<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期牛客多校06</title>
      <link href="/posts/ACM_2024Summer_NCD06.html"/>
      <url>/posts/ACM_2024Summer_NCD06.html</url>
      
        <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81601">2024牛客暑期多校训练营6</a></p><h1>A.Cake</h1><h2 id="题意">题意</h2><p>给定一棵 $n$ 个节点，以 $1$ 为根的树，每条边有一个权值 0 或 1。<br>棋子初始在节点 $1$ ，Alice先手，Bob后手。<br>每回合，玩家可以将棋子移动到当前节点的一个子节点。<br>直到棋子达到叶子节点，游戏结束。</p><p>棋子经过的路径的权值按顺序构成一个01序列，记它的长度为 $m$ 。<br>接下来，Bob可以把 $1$ 块蛋糕任意分成 $m$ 份（某份蛋糕可以为0//空盘子）。<br>然后根据01序列决定取蛋糕的次序：0代表Bob取，1代表Alice取。</p><p>问两人都以最优策略行动和切蛋糕，问Alice最多能拿到多少蛋糕。</p><h2 id="解题思路">解题思路</h2><p>先考虑在路径确定的情况下，Bob会怎么分蛋糕：<br>Bob会找到一个前缀pre，这个前缀的“0占比”是所有前缀中最大的。<br>pre的长度记为 $t$，0占比记为 $p$。<br>Bob会将蛋糕平均分为 $t$ 份，剩下 $m-t$ 份为空。<br>这样，Bob可以保证他拿到最多的，大小为 $p$ 的蛋糕。</p><p>对于每个节点 $i$ ，先DFS一次，处理出从 $1$ 到 $i$ 这条路径上所有前缀的最大0占比。<br>那么在每个结点处。</p><p>再DFS一次，假设根节点 $1$ 的深度是1，那么：<br>深度为奇数的节点是Alice的回合，Alice会希望前缀的“0的占比”最小化；<br>深度为偶数的节点是Bob的回合，Bob会希望前缀的“0的占比”最大化。</p><p>从叶子到根更新，得到最终0占比 $p$ ，按照上面的方法分蛋糕，最终答案为 $1-p$ 。</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">ll n;</span><br><span class="line">vector&lt;vector&lt;pll&gt;&gt; G;</span><br><span class="line">vector&lt;ld&gt; pref; <span class="comment">//前缀中0的最大占比</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll u=<span class="number">1</span>,ll fa=<span class="number">0</span>,ll cnt0=<span class="number">0</span>,ll cnt1=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u!=<span class="number">1</span>) <span class="built_in">chmax</span>(pref[u],(ld)cnt0/(cnt0+cnt1));<span class="comment">//用当前节点的0占比更新前缀</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v,w]:G[u])</span><br><span class="line">        <span class="keyword">if</span>(v!=fa)&#123;</span><br><span class="line">            pref[v]=pref[u];<span class="comment">//继承父节点的pref</span></span><br><span class="line">            <span class="built_in">dfs</span>(v,u,cnt0+(w==<span class="number">0</span>),cnt1+(w==<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;ld&gt; dp; <span class="comment">//节点对执棋手的最优解</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_dp</span><span class="params">(ll u=<span class="number">1</span>,ll fa=<span class="number">0</span>, ll dep=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    dp[u]=dep%<span class="number">2</span>; </span><br><span class="line">    <span class="keyword">if</span>(u!=<span class="number">1</span>&amp;&amp;G[u].<span class="built_in">size</span>()==<span class="number">1</span>) dp[u]=pref[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v,w]:G[u]) <span class="keyword">if</span>(v!=fa)&#123;</span><br><span class="line">        <span class="built_in">dfs_dp</span>(v,u,dep+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(dep%<span class="number">2</span>) <span class="built_in">chmin</span>(dp[u],dp[v]); <span class="comment">//先手求pref小</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">chmax</span>(dp[u],dp[v]); <span class="comment">//后手求pref大</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    G.<span class="built_in">clear</span>(); G.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    pref.<span class="built_in">clear</span>(); pref.<span class="built_in">resize</span>(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    dp.<span class="built_in">clear</span>(); dp.<span class="built_in">resize</span>(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    ll u,v,w;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        G[u].<span class="built_in">emplace_back</span>(v,w);</span><br><span class="line">        G[v].<span class="built_in">emplace_back</span>(u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(); <span class="built_in">dfs_dp</span>();</span><br><span class="line">    <span class="built_in">print_float</span>(<span class="number">1.</span>-dp[<span class="number">1</span>],<span class="number">12</span>);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.Cake2</h1><h2 id="题意-2">题意</h2><p>给定正整数 $n,k$ ，蛋糕的形状是正 $n$ 边形，顶点编号为 $0$ 到 $n-1$ 。<br>对于每个顶点 $i$ ，沿着由 顶点 $i$ 和 $(i+k)mod\ n$ 确定的直线切一刀。<br>求最后蛋糕的块数。</p><p>以$n=6,k=2$为例，蛋糕的形状如下：<br><img src="/images/ACM/2024Summer_NCD06_B.png" alt=""></p><h2 id="解题思路-2">解题思路</h2><p>手画几个图，发现当且仅当 $n=k\times2$ 时，蛋糕的块数为 $n$ 。<br>其余情况下，发现每个交点仅由2条直线，蛋糕的块数为 $n\times k+1$ 。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k;cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;n/<span class="number">2</span>) k=n-k;</span><br><span class="line">    <span class="keyword">if</span>(k*<span class="number">2</span>!=n) cout &lt;&lt; k*n+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>H.Genshin Impact’s Fault</h1><h2 id="题意-3">题意</h2><p>给定一个字符串，包含以下字符：</p><ul><li><code>3</code>：三星卡</li><li><code>4</code>：四星卡</li><li><code>5</code>：普通五星卡</li><li><code>U</code>：特殊五星卡</li></ul><p>满足以下条件的字符串是合法的：</p><ol><li>每10个连续的字符不能都是<code>3</code></li><li>每90个连续的字符至少有1个<code>U</code>或<code>5</code></li><li>相邻两张五星卡不能都是<code>5</code></li></ol><p>判断给定字符串是否合法。</p><h2 id="解题思路-3">解题思路</h2><p>按照题意模拟判断。</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;3&#x27;</span>) cnt++;</span><br><span class="line">        <span class="keyword">else</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=<span class="number">10</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c!=<span class="string">&#x27;5&#x27;</span>&amp;&amp;c!=<span class="string">&#x27;U&#x27;</span>) cnt++;</span><br><span class="line">        <span class="keyword">else</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=<span class="number">90</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> pre=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;5&#x27;</span>||c==<span class="string">&#x27;U&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre==<span class="string">&#x27;0&#x27;</span>) pre=c;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pre==<span class="string">&#x27;5&#x27;</span>&amp;&amp;c==<span class="string">&#x27;5&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> pre=c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check1</span>()&amp;&amp;<span class="built_in">check2</span>()&amp;&amp;<span class="built_in">check3</span>()) cout &lt;&lt; <span class="string">&quot;valid\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;invalid\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期牛客多校05</title>
      <link href="/posts/ACM_2024Summer_NCD05.html"/>
      <url>/posts/ACM_2024Summer_NCD05.html</url>
      
        <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81600">2024牛客暑期多校训练营5</a></p><blockquote><p>玲珑骰子安红豆，入骨相思知不知。  ——温庭筠</p></blockquote><h1>B.珑</h1><h2 id="题意">题意</h2><p>使用若干个 $1\times 2$ 的小矩形，恰好覆盖一个 $n\times m$ 的大矩形（即不允许重叠、不允许有部分超出大矩形范围）</p><p>对于任意两个小矩形，可能存在以下两种限制（中的0种、1种或2种）：</p><ol><li>边长为1的边不能相贴</li><li>边长为2的边不能相贴，即使相贴部分的长度仅为1</li></ol><p>问是否存在一种方案，在满足给定限制的条件下，恰好覆盖大矩形。</p><h2 id="解题思路">解题思路</h2><p>不妨令 $n&lt;m$ ：</p><ol><li>小矩形的面积是2，所以 $n\times m$ 必须是偶数</li><li>只有 $n=1$ 的情况满足条件2</li><li>只有 $n=1且m&gt;2$ 的情况不满足条件1</li></ol><p><img src="/images/ACM/2024Summer_NCD05_B.png" alt="image"></p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,a,b;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;m) <span class="built_in">swap</span>(n,m);</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>&amp;&amp;m%<span class="number">2</span>) &#123;NO;<span class="keyword">return</span> ;&#125; <span class="comment">// 面积是奇数</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>&amp;&amp;m==<span class="number">2</span>) &#123;YES;<span class="keyword">return</span> ;&#125; <span class="comment">// 1*2只需要一块</span></span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>&amp;&amp;n!=<span class="number">1</span>) &#123;NO;<span class="keyword">return</span> ;&#125; <span class="comment">// 只有1*m时能满足b</span></span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>&amp;&amp;n==<span class="number">1</span>) &#123;NO;<span class="keyword">return</span> ;&#125; <span class="comment">// 只有1*m时不能满足a</span></span><br><span class="line">    YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>E.安</h1><h2 id="题意-2">题意</h2><p>May和Ray各有 $n$ 个骑士，分别按顺序排成一排，编号为 $1\sim n$ 。<br>May的骑士的生命值为 $a_i$ ，Ray的骑士的生命值为 $b_i$ 。</p><p>玩家每次操作可以选择一个双方骑士都存活的序号 $i$ ，命自己的骑士 $i$ 攻击对方的骑士 $i$ （使对方的骑士 $i$ 的生命值减少 $1$ ）。</p><p>May先行，两人都执行最优策略，直到无法操作。</p><p>问May最终剩余多少个骑士。</p><h2 id="解题思路-2">解题思路</h2><p>考虑最优策略：</p><ol><li>$a_i&gt;b_i$ ：优势，在这个位置只需要在对方攻击后反击，就能保证消灭对方。</li><li>$a_i&lt;b_i$ ：根据上一条，这个位置的骑士无法存活。</li><li>$a_i=b_i$ ：先攻击的棋子存活，一半的棋子存活，先手可以向上取整。</li></ol><p>按照最优策略，答案为 $cnt(a_i&gt;b_i)+\lceil cnt(a_i=b_i)/2 \rceil$ 。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">create_vec</span>(a,n);</span><br><span class="line">    <span class="built_in">create_vec</span>(b,n);</span><br><span class="line">    ll ans=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==b[i]) cnt++;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;b[i]) ans++;</span><br><span class="line">    &#125;cout &lt;&lt; ans+(cnt+<span class="number">1</span>)/<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>H.入</h1><h2 id="题意-3">题意</h2><p>给定一个 $n$ 个点 $m$ 条边的无向图，每个点带唯一点权 $w_i$ 。</p><p>棋子初始被放在一个点上，每次会移动到相邻的点中点权最小的一个点。</p><p>现在点权和初始位置可以自己决定，问最多能经过多少个点。</p><h2 id="解题思路-3">解题思路</h2><p>若从点 $i$ 走到点 $j$ ，其他和 $i$ 相邻的点的权值一定大于点 $j$ 的权值，因此之后都不会再走到这些点。</p><p>换句话说，走到下一个点之后，就可以把上一步的点和它的相邻点删掉了。</p><p>建图，按照以上思路，从每个点出发各一次，DFS找到最长路径长度。</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ll n,m;</span><br><span class="line">vector&lt;vector&lt;ll&gt;&gt; G;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vis;</span><br><span class="line">ll ans=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll u,ll cur=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">chmax</span>(ans,cur);</span><br><span class="line">    vector&lt;ll&gt; tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:G[u]) <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">        tmp.<span class="built_in">emplace_back</span>(v);</span><br><span class="line">        vis[v]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt+=tmp.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n-cnt+cur&gt;=ans)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:tmp) <span class="built_in">dfs</span>(v,cur+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:tmp) vis[v]=<span class="number">0</span>;</span><br><span class="line">    cnt-=tmp.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ll u,v;</span><br><span class="line">    G.<span class="built_in">clear</span>(); G.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    vis.<span class="built_in">clear</span>(); vis.<span class="built_in">resize</span>(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">        G[v].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        vis[i]=<span class="number">1</span>; cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i);</span><br><span class="line">        vis[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>L.知</h1><h2 id="题意-4">题意</h2><p>给定一个长度为 $n$ 的序列 $a$ ，每次操作可以选择一个下标 $i&lt;n$ ，执行：$a_i=a_i+1,a_{i+1}=a_{i+1}-1$ 。</p><p>求任意次操作后，序列 $a$ 的积的最大值 $mod\ 998244353$ 。</p><h2 id="解题思路-4">解题思路</h2><p>小学老师教过我们，当和一定时，数越平均，积越大。</p><p>观察到操作的特性：后面的大数字可以匀到前面，但是前面的数字不能匀给后面。</p><p>从前往后处理，把第 $i$ 个数 $a_i$ 加入答案时，<br>从当前的 前 $i-1$ 个数中，从小到大依次选取尽可能多的数（记为 $b_1\sim b_k$ ），<br>满足：$max{b_1\cdots b_k}&lt; avg{b_1 \cdots b_k,a_i}$</p><p>然后可以将 ${b_1 \cdots b_k,a_i}$ 平均化，是最优的平均方法。</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">// ll n=5;</span></span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(n)</span>,vans</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:v) cin &gt;&gt; x;</span><br><span class="line">    vans.<span class="built_in">emplace_back</span>(v[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i]&gt;vans[<span class="number">0</span>])&#123;</span><br><span class="line">            ll tsum=v[i],j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;i)&#123; <span class="comment">//取出需要被匀的数</span></span><br><span class="line">                <span class="keyword">if</span>(vans[j]&gt;=tsum/(j+<span class="number">1</span>)) <span class="keyword">break</span>;  </span><br><span class="line">                <span class="comment">//如果当前的数已经大于等于平均值，就不需要被平均了</span></span><br><span class="line">                tsum+=vans[j]; j++;</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;ll&gt; temp;</span><br><span class="line">            <span class="built_in">FORLL</span>(k,j,i<span class="number">-1</span>) temp.<span class="built_in">emplace_back</span>(vans[k]);</span><br><span class="line">            ll avg=tsum/(j+<span class="number">1</span>),tt=tsum%(j+<span class="number">1</span>);</span><br><span class="line">            temp.<span class="built_in">insert</span>(temp.<span class="built_in">end</span>(),tt,avg+<span class="number">1</span>);</span><br><span class="line">            temp.<span class="built_in">insert</span>(temp.<span class="built_in">end</span>(),j+<span class="number">1</span>-tt,avg);</span><br><span class="line">            vans=temp;</span><br><span class="line">        &#125;<span class="keyword">else</span> vans.<span class="built_in">emplace_back</span>(v[i]);</span><br><span class="line">        <span class="built_in">SORT</span>(vans);</span><br><span class="line">    &#125; <span class="comment">// print_vec(ans);</span></span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:vans) <span class="built_in">multo</span>(ans,x);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期杭电多校04</title>
      <link href="/posts/ACM_2024Summer_HDU04.html"/>
      <url>/posts/ACM_2024Summer_HDU04.html</url>
      
        <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A84%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（4）</a></p><h1>1003</h1><p>//TODO</p><h1>(1005)HDU7473.多层血条</h1><h2 id="题意">题意</h2><p>Boss血条的尺寸为 $n$ 行 $m$ 列，外层有边框。<br>行数仅代表血条的高度，不代表血量。<br>每列代表 $1$ 点血量， $m$ 列代表了 $m$ 点血量，即一层血条。</p><p>血条自底向上、从左往右平铺，最底下没有血量的部分为空格。<br>第一层血量用 <code>A</code> 表示，第二层血量用 <code>B</code> 表示，…，第五层血量用 <code>E</code> 表示，第六层血量用 <code>A</code> 表示，五层一循环，以此类推。</p><p>$n=2,m=10$ 且血量为$12$时，血条如下：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+----------+</span></span><br><span class="line">|BBAAAAAAAA|</span><br><span class="line"><span class="section">|BBAAAAAAAA|</span></span><br><span class="line"><span class="section">+----------+</span></span><br></pre></td></tr></table></figure><p>为了加强打击反馈，当Boss受到伤害时，即将扣减的血量将短暂显示为<code>.</code>，然后再显示为对应的血条。</p><p>如上面的血条，当受到 $3$ 点伤害时，血条将变为：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+----------+</span></span><br><span class="line">|..AAAAAAA.|</span><br><span class="line"><span class="section">|..AAAAAAA.|</span></span><br><span class="line"><span class="section">+----------+</span></span><br></pre></td></tr></table></figure><p>给定 $n,m$ ，血量 $hp$，即将受到的伤害 $dmg$ ，求受到伤害时的血条。</p><h2 id="解题思路">解题思路</h2><p>计算血条层数决定填充当前层（和下一层）的字符。<br>计算当前最后一个血的位置，然后根据伤害对血条进行修改。</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,hp,dmg;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; hp &gt;&gt; dmg;</span><br><span class="line">    string ul=<span class="string">&#x27;+&#x27;</span>+<span class="built_in">string</span>(m,<span class="string">&#x27;-&#x27;</span>)+<span class="string">&#x27;+&#x27;</span>; <span class="comment">//边框</span></span><br><span class="line">    cout &lt;&lt; ul &lt;&lt; endl;</span><br><span class="line">    string s=<span class="string">&quot;|&quot;</span>;</span><br><span class="line">    ll k=(hp+m<span class="number">-1</span>)/m; <span class="comment">//层数</span></span><br><span class="line">    <span class="type">char</span> c=(k+<span class="number">4</span>)%<span class="number">5</span>+<span class="string">&#x27;A&#x27;</span>; <span class="comment">//当前层字符</span></span><br><span class="line">    ll cur = (hp<span class="number">-1</span>)%m+<span class="number">1</span>; <span class="comment">//当前层血量位置</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,cur) s+=c;</span><br><span class="line">    <span class="type">char</span> c1=(k<span class="number">-1</span>)&gt;<span class="number">0</span>?(k<span class="number">-2</span>)%<span class="number">5</span>+<span class="string">&#x27;A&#x27;</span>:<span class="string">&#x27; &#x27;</span>; <span class="comment">//下一层字符</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,cur+<span class="number">1</span>,m) s+=c1;</span><br><span class="line">    s+=<span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">    <span class="built_in">chmin</span>(dmg,m);</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,cur,<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dmg==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        s[i]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        dmg--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,m,cur+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dmg==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        s[i]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        dmg--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ul &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>1007</h1><p>//TODO</p><h1>(1009)HDU7477.昵称检索</h1><h2 id="题意-2">题意</h2><p>给定 $n$ 个字符串表示名字。<br>一个昵称由两部分组成：一个给定的名字+4位数字。<br>其中，4位数字表示一个日期。</p><p>注：日期格式为 <code>MMDD</code> ，即月份和日期，0229也算。</p><p>给定一个长度为 $m$ 的字符串，计算所有子序列中能构成不同的昵称的个数。</p><h2 id="解题思路-2">解题思路</h2><p>昵称和日期分开考虑。</p><p>要求计不同的昵称的个数，因此每种名字、日期只需要考虑一次。</p><p>名字只需要选取最早完整出现的子序列，因为早出现一定比晚出现匹配的日期个数多。<br>日期只需要选取最晚完整出现的子序列，因为晚出现一定比早出现匹配的名字个数多。</p><p>记录每种字符出现的位置，先匹配日期。<br>用 $date_i$ 表示下标为 $i$ 的位置开头的不同日期数。<br>对 $date$ 做一个后缀和， $date_i$ 就表示到当前位置开始，往后的不同日期数。</p><p>再匹配名字。<br>找到名字 $name$ 的最早出现位置 $j$ ，它能组合出的最多不同昵称数为 $date_{j+1}$，加入答案。</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; days = &#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">toint</span><span class="params">(<span class="type">char</span> c1,<span class="type">char</span> c2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (c1-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+c2-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;string&gt; names;</span><br><span class="line">    string s,t;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        names.<span class="built_in">emplace_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;<span class="type">char</span>,vector&lt;ll&gt;&gt; posc,posint;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;z&#x27;</span>) posc[s[i]].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        <span class="keyword">else</span> posint[s[i]].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">date</span><span class="params">(m+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> d2=<span class="string">&#x27;0&#x27;</span>;d2&lt;=<span class="string">&#x27;9&#x27;</span>;d2++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(posint[d2].<span class="built_in">empty</span>()) <span class="keyword">continue</span>; <span class="comment">//没有这个数字</span></span><br><span class="line">        <span class="keyword">auto</span> posd2 = posint[d2].<span class="built_in">back</span>(); <span class="comment">//最后一个位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d1=<span class="string">&#x27;0&#x27;</span>;d1&lt;=<span class="string">&#x27;3&#x27;</span>;d1++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> day=<span class="built_in">toint</span>(d1,d2);</span><br><span class="line">            <span class="keyword">if</span>(day&gt;<span class="number">31</span>||day&lt;<span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">//不可能的天数</span></span><br><span class="line">            <span class="keyword">if</span>(posint[d1].<span class="built_in">empty</span>()) <span class="keyword">continue</span>; <span class="comment">//没有这个数字</span></span><br><span class="line">            <span class="keyword">auto</span> itposd1 = <span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(posint[d1]),posd2); <span class="comment">//找比posd2小的最大的位置</span></span><br><span class="line">            <span class="keyword">if</span>(itposd1==posint[d1].<span class="built_in">begin</span>()) <span class="keyword">continue</span>; <span class="comment">//没有比posd2小的</span></span><br><span class="line">            <span class="keyword">auto</span> posd1 = *(--itposd1);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> m2=<span class="string">&#x27;0&#x27;</span>;m2&lt;=<span class="string">&#x27;9&#x27;</span>;m2++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(posint[m2].<span class="built_in">empty</span>()) <span class="keyword">continue</span>; <span class="comment">//没有这个数字</span></span><br><span class="line">                <span class="keyword">auto</span> itposm2 = <span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(posint[m2]),posd1); <span class="comment">//找比posd1小的最大的位置</span></span><br><span class="line">                <span class="keyword">if</span>(itposm2==posint[m2].<span class="built_in">begin</span>()) <span class="keyword">continue</span>; <span class="comment">//没有比posd1小的</span></span><br><span class="line">                <span class="keyword">auto</span> posm2 = *(--itposm2);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> m1=<span class="string">&#x27;0&#x27;</span>;m1&lt;=<span class="string">&#x27;1&#x27;</span>;m1++)&#123;</span><br><span class="line">                    <span class="keyword">auto</span> month=<span class="built_in">toint</span>(m1,m2);</span><br><span class="line">                    <span class="keyword">if</span>(month&gt;<span class="number">12</span>||month&lt;<span class="number">1</span>) <span class="keyword">continue</span>;; <span class="comment">//不可能的月份</span></span><br><span class="line">                    <span class="keyword">if</span>(day&gt;days[month]) <span class="keyword">continue</span>;; <span class="comment">//不可能的日期</span></span><br><span class="line">                    <span class="keyword">if</span>(posint[m1].<span class="built_in">empty</span>()) <span class="keyword">continue</span>; <span class="comment">//没有这个数字</span></span><br><span class="line">                    <span class="keyword">auto</span> itposm1 = <span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(posint[m1]),posm2); <span class="comment">//找比posm2小的最大的位置</span></span><br><span class="line">                    <span class="keyword">if</span>(itposm1==posint[m1].<span class="built_in">begin</span>()) <span class="keyword">continue</span>; <span class="comment">//没有比posm2小的</span></span><br><span class="line">                    <span class="keyword">auto</span> posm1 = *(--itposm1);</span><br><span class="line">                    date[posm1]++;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; month &lt;&lt; &#x27; &#x27; &lt;&lt; day &lt;&lt; endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,m<span class="number">-1</span>,<span class="number">0</span>) date[i]+=date[i+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// print_vec(date);</span></span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;name:names)&#123;</span><br><span class="line">        ll curi=<span class="number">-1</span>,len=name.<span class="built_in">length</span>();</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">0</span>,len<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">auto</span> c=name[i];</span><br><span class="line">            <span class="keyword">auto</span> it=<span class="built_in">upper_bound</span>(<span class="built_in">ALL</span>(posc[c]),curi);</span><br><span class="line">            <span class="keyword">if</span>(it==posc[c].<span class="built_in">end</span>()) <span class="keyword">break</span>;</span><br><span class="line">            curi=*it;</span><br><span class="line">            <span class="keyword">if</span>(i==len<span class="number">-1</span>) ans+=date[curi+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期杭电多校03</title>
      <link href="/posts/ACM_2024Summer_HDU03.html"/>
      <url>/posts/ACM_2024Summer_HDU03.html</url>
      
        <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A83%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（3）</a></p><h1>(1001)HDU7457.深度自同构</h1><h2 id="题意">题意</h2><p>求由 $n$ 个节点构成，且满足“深度相同的节点，度相同”的森林的方案数。</p><h2 id="解题思路">解题思路</h2><p>先考虑 $i$ 个节点的合法的树，这棵树每个节点的子树形态相同。<br>去掉根节点，每个部分的子树形态相同，那么每个子树的节点数是 $i-1$ 的约数。<br>设 $f(i)$ 表示 $i$ 个节点满足上述条件的树的方案数，那么有：$f(i)=\sum_{d|(i-1)} f(d)$</p><p>再考虑 $n$ 个节点的合法的森林，每个树的节点数是 $n$ 的约数。<br>设 $g(n)$ 表示 $n$ 个节点满足上述条件的森林的方案数，那么有：$g(n)=\sum_{d|n} f(d)$</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> ll N = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line">ll f[N],g[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    ll n=<span class="number">1e6</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="keyword">for</span>(ll j=i;j&lt;=n;j+=i)</span><br><span class="line">            <span class="built_in">addto</span>(f[j+<span class="number">1</span>],f[i]);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="keyword">for</span>(ll j=i;j&lt;=n;j+=i)</span><br><span class="line">            <span class="built_in">addto</span>(g[j],f[i]);</span><br><span class="line">    <span class="comment">//寄巧：对于从约数i到倍数j的转移，可以枚举倍数k，以调和级数复杂度求</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cout &lt;&lt; g[i] &lt;&lt; <span class="built_in">Presentation</span>(i,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1007)HDU7463.单峰数列</h1><h2 id="题意-2">题意</h2><p>给定一个长度为 $n$ 的数列 $a$ ，$q$ 次操作：</p><ol><li><code>1 l r x</code>：$a[l,r]$ 每个数加 $x$</li><li><code>2 l r</code>：判断 $a[l,r]$ 是否相同</li><li><code>3 l r</code>：判断 $a[l,r]$ 是否严格单调递增，$l=r$ 时也算</li><li><code>4 l r</code>：判断 $a[l,r]$ 是否严格单调递减，$l=r$ 时也算</li><li><code>5 l r</code>：判断 $a[l,r]$ 是否单峰数列</li></ol><p>长度为 $m$ 的数列 $b$ 被称为单峰数列，当且仅当存在唯一位置 $1\lt i\lt m$ ，使得 $b[1,i]$ 严格单调递增，$b[i,m]$ 严格单调递减。</p><h2 id="解题思路-2">解题思路</h2><p>暴力判断<br>维护差分序列更直观</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ll&gt; v;</span><br><span class="line">ll n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">range_add</span><span class="params">(ll l,ll r,ll val)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,l<span class="number">-1</span>,r<span class="number">-1</span>) v[i]+=val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check_same</span><span class="params">(ll l,ll r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,l,r<span class="number">-1</span>) <span class="keyword">if</span>(v[i]!=v[l<span class="number">-1</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check_up</span><span class="params">(ll l,ll r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,l,r<span class="number">-1</span>) <span class="keyword">if</span>(v[i<span class="number">-1</span>]&gt;=v[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check_down</span><span class="params">(ll l,ll r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,l,r<span class="number">-1</span>) <span class="keyword">if</span>(v[i<span class="number">-1</span>]&lt;=v[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check_mountain</span><span class="params">(ll l,ll r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fl=<span class="number">0</span>; <span class="comment">//up</span></span><br><span class="line">    <span class="keyword">if</span>(v[l<span class="number">-1</span>]&gt;v[l]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,l,r<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i<span class="number">-1</span>]==v[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(fl==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i<span class="number">-1</span>]&gt;v[i]) fl=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(fl==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i<span class="number">-1</span>]&lt;v[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fl==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    v.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:v) cin &gt;&gt; x;</span><br><span class="line">    ll q;cin &gt;&gt; q;</span><br><span class="line">    ll op,l,r,val;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r &gt;&gt; val;</span><br><span class="line">            <span class="built_in">range_add</span>(l,r,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">check_same</span>(l,r) &lt;&lt; endl;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)&#123;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">check_up</span>(l,r) &lt;&lt; endl;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">4</span>)&#123;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">check_down</span>(l,r) &lt;&lt; endl;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">5</span>)&#123;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">check_mountain</span>(l,r) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1008)HDU7464.比特跳跃</h1><h2 id="题意-3">题意</h2><p>给定一个 $n$ 个点 $m$ 条边（不保证连通，可能有重边）的无向图。<br>每条边 $E(u,v)$ 有一个权值 $w$ ，表示从 $u$ 到 $v$ 的代价。<br>此外，对于任意两点 $u,v$ ，可以付出 $k\times(u|v)$ （按位或）的代价从 $u$ 跳到 $v$ 。<br>分别求从节点 $1$ 到所有其他点 $2$ ~ $n$ 的最小代价。</p><h2 id="解题思路-3">解题思路</h2><p>最暴力的想法肯定是把直接跳跃也看作边加入图中，然后跑单源最短路。<br>但是这样边的数量是 $n^2$ ，显然不可取。<br>因此考虑哪些边是有必要加的。</p><p>$1$ 直接跳到其他节点的方案是很优的：<br>若节点 $i$ 不在节点 $1$ 所在的连通块内，那么 $1$ 直接跳到 $i$ 的代价只可能是 $i$ （$i$ 为奇数）或 $i+1$ （$i$ 为偶数）。</p><p>但如果存在 $E(1,2,0)$ ，对于 $x=2,6,10…$ 这一类满足 $x%4=2$ 的节点， $1$ 直接跳到 $x$ 的代价为 $x+1$ ，但先走到 $2$ 再跳到 $x$ 的代价仅为 $x$ 。</p><p>因此，对于 $x%4=2$ 的节点，需要加入 $E(2,x,k(x|2))$ 。</p><p>同理，对于 $x%2^{i+1}=2^i$ 的节点，需要加入 $E(2,x,k(x|2^i))$ 。</p><p>最后，跑一遍单调队列优化的单源最短路，求出答案。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">pow2</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=<span class="number">60</span>;i++) pow2.<span class="built_in">emplace_back</span>(pow2.<span class="built_in">back</span>()*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="function">Dijkstra <span class="title">dij</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        ll u,v,w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        dij.<span class="built_in">addedge</span>(u,v,w);</span><br><span class="line">        dij.<span class="built_in">addedge</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n) dij.<span class="built_in">addedge</span>(<span class="number">1</span>,i,k*(<span class="number">1</span>|i));</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,<span class="number">60</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pow2[i]&gt;n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll j=pow2[i]*<span class="number">2</span>;j&lt;=n;j+=pow2[i]) <span class="keyword">if</span>(pow2[i]&amp;j)</span><br><span class="line">            dij.<span class="built_in">addedge</span>(pow2[i],j,k*(pow2[i]|j));</span><br><span class="line">    &#125;</span><br><span class="line">    dij.<span class="built_in">solve</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n) cout &lt;&lt; dij[i] &lt;&lt; <span class="built_in">Presentation</span>(i,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1011)HDU7467.抓拍</h1><h2 id="题意-4">题意</h2><p>$n$ 个人，第 $i$ 个人初始在 $(x_i,y_i)$ 。<br>每个人有一个行进方向：东（E,+x方向）、西（W,-x方向）、南（S,-y方向）、北（N,+y方向），每秒移动一个距离。<br>散步无限长时间、不改变方向、忽略碰撞。</p><p>求一个周长最小的矩形满足：</p><ol><li>上下边平行于 $x$ 轴，左右边平行于 $y$ 轴</li><li>存在一个时刻，所有人都在矩形内部</li></ol><h2 id="解题思路-4">解题思路</h2><p>每个时刻的最小周长矩形只由 最上面、最下面、最左边、最右边 的四个人决定，那么就考虑可能成为这四个人的人。</p><p>左右移动的人占据的y区间，上下移动的人占据的x区间，不会改变。<br>记录：左右走的人里最靠上、最靠下的人，上下走的人里最靠左、最靠右的人。</p><p>因为时间无限长，最后在最上面的人，一定是向上走的人中初始点最靠上的，其他方向同理。<br>记录：向上走的人里最靠上的、向下走的人里最靠下的，向左走的人里最靠左的、向右走的人里最靠右的。</p><p>开始最靠下的人如果是向左/右/下走的，已经记录了，只要在向上走的人中找到最靠下的，其他方向同理。<br>记录：向上走的人里最靠下的、向下走的人里最靠上的、向左走的人里最靠右的、向右走的人里最靠左的。</p><p>有了这12个值，就可以计算出任何一个时刻的 $x_{min},x_{max},y_{min},y_{max}$ ，从而计算出最小周长。</p><p>模拟可知，周长对时间的函数，要么是单调增的，要么是一个开口向上的二次函数（因为最后人一定越走越散）。因此可以三分找到极小值点，即为答案。</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//           E W S N</span></span><br><span class="line"><span class="comment">//           R L D U</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pll a,pll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.second==b.second) <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">    <span class="keyword">return</span> a.second&lt;b.second;</span><br><span class="line">&#125;</span><br><span class="line">ll yLRmax,yLRmin,xUDmax,xUDmin;</span><br><span class="line">ll xLmin,xLmax,xRmin,xRmax,yUmin,yUmax,yDmin,yDmax;</span><br><span class="line"><span class="function">ll <span class="title">getC</span><span class="params">(ll t)</span></span>&#123;</span><br><span class="line">    ll xmin = <span class="built_in">min</span>(&#123;xLmin-t,xRmin+t,xUDmin&#125;);</span><br><span class="line">    ll xmax = <span class="built_in">max</span>(&#123;xLmax-t,xRmax+t,xUDmax&#125;);</span><br><span class="line">    ll ymin = <span class="built_in">min</span>(&#123;yDmin-t,yUmin+t,yLRmin&#125;);</span><br><span class="line">    ll ymax = <span class="built_in">max</span>(&#123;yDmax-t,yUmax+t,yLRmax&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*((xmax-xmin)+(ymax-ymin));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    vector&lt;pll&gt; L,R,U,D;</span><br><span class="line">    ll x,y;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;E&#x27;</span>) R.<span class="built_in">emplace_back</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;W&#x27;</span>) L.<span class="built_in">emplace_back</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;N&#x27;</span>) U.<span class="built_in">emplace_back</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;S&#x27;</span>) D.<span class="built_in">emplace_back</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左右移动的最上和最下两个人，上下移动的最左和最右两个人</span></span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">ALL</span>(L),cmp); <span class="built_in">sort</span>(<span class="built_in">ALL</span>(R),cmp); <span class="built_in">sort</span>(<span class="built_in">ALL</span>(U)); <span class="built_in">sort</span>(<span class="built_in">ALL</span>(D));</span><br><span class="line">    yLRmax = xUDmax = -INF;</span><br><span class="line">    yLRmin = xUDmin = INF;</span><br><span class="line">    <span class="keyword">if</span>(L.<span class="built_in">size</span>()) &#123;<span class="built_in">chmax</span>(yLRmax,L.<span class="built_in">back</span>().second);<span class="built_in">chmin</span>(yLRmin,L.<span class="built_in">front</span>().second);&#125;</span><br><span class="line">    <span class="keyword">if</span>(R.<span class="built_in">size</span>()) &#123;<span class="built_in">chmax</span>(yLRmax,R.<span class="built_in">back</span>().second);<span class="built_in">chmin</span>(yLRmin,R.<span class="built_in">front</span>().second);&#125;</span><br><span class="line">    <span class="keyword">if</span>(U.<span class="built_in">size</span>()) &#123;<span class="built_in">chmax</span>(xUDmax,U.<span class="built_in">back</span>().first);<span class="built_in">chmin</span>(xUDmin,U.<span class="built_in">front</span>().first);&#125;</span><br><span class="line">    <span class="keyword">if</span>(D.<span class="built_in">size</span>()) &#123;<span class="built_in">chmax</span>(xUDmax,D.<span class="built_in">back</span>().first);<span class="built_in">chmin</span>(xUDmin,D.<span class="built_in">front</span>().first);&#125;</span><br><span class="line">    <span class="comment">//初始状态，向左的最左最右，向右的最左最右，向上的最上最下，向下的最上最下</span></span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">ALL</span>(L)); <span class="built_in">sort</span>(<span class="built_in">ALL</span>(R)); <span class="built_in">sort</span>(<span class="built_in">ALL</span>(U),cmp); <span class="built_in">sort</span>(<span class="built_in">ALL</span>(D),cmp);</span><br><span class="line">    xLmin = xRmin = yUmin = yDmin = INF;</span><br><span class="line">    xLmax = xRmax = yUmax = yDmax = -INF;</span><br><span class="line">    <span class="keyword">if</span>(L.<span class="built_in">size</span>()) &#123;<span class="built_in">chmin</span>(xLmin,L.<span class="built_in">front</span>().first);<span class="built_in">chmax</span>(xLmax,L.<span class="built_in">back</span>().first);&#125;</span><br><span class="line">    <span class="keyword">if</span>(R.<span class="built_in">size</span>()) &#123;<span class="built_in">chmin</span>(xRmin,R.<span class="built_in">front</span>().first);<span class="built_in">chmax</span>(xRmax,R.<span class="built_in">back</span>().first);&#125;</span><br><span class="line">    <span class="keyword">if</span>(U.<span class="built_in">size</span>()) &#123;<span class="built_in">chmin</span>(yUmin,U.<span class="built_in">front</span>().second);<span class="built_in">chmax</span>(yUmax,U.<span class="built_in">back</span>().second);&#125;</span><br><span class="line">    <span class="keyword">if</span>(D.<span class="built_in">size</span>()) &#123;<span class="built_in">chmin</span>(yDmin,D.<span class="built_in">front</span>().second);<span class="built_in">chmax</span>(yDmax,D.<span class="built_in">back</span>().second);&#125;</span><br><span class="line">    ll l=<span class="number">0</span>,r=<span class="number">2e9</span>;</span><br><span class="line">    <span class="comment">//三分找到getC最小的t</span></span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;<span class="number">10</span>)&#123;</span><br><span class="line">        ll m1 = l+(r-l)/<span class="number">3</span>;</span><br><span class="line">        ll m2 = r-(r-l)/<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">getC</span>(m1)&lt;<span class="built_in">getC</span>(m2)) r=m2;</span><br><span class="line">        <span class="keyword">else</span> l=m1;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mnans=INF;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,l,r) <span class="built_in">chmin</span>(mnans,<span class="built_in">getC</span>(i));</span><br><span class="line">    cout &lt;&lt; mnans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1012)HDU7468.死亡之组</h1><h2 id="题意-5">题意</h2><p>给定一个长度为 $n$ 的数组 $a$ （$n$ 是4的倍数），$a_i$ 表示第 $i$ 个队伍的实力。<br>每4个队伍一组，“死亡之组”至少符合以下条件之一：</p><ol><li>至少有2个队伍的实力 $&gt; L$</li><li>最大实力和最小实力之差 $\le D$</li></ol><p>问是否存在一种分组方案使得第 $1$ 组所在的小组不是“死亡之组”。</p><h2 id="解题思路-5">解题思路</h2><p>为了不满足条件1，存在至少3个队伍的实力 $\le L$ 即可。<br>然后把这3个队伍 $t_1,t_2,t_3$ 拿出来。<br>为了不满足条件2，所有队伍的实力中，最大值和最小值之差 $&gt; D$ 即可。<br>然后把实力最大的队伍 $t_4$ 拿出来。</p><p>对队伍1（$a_1$）进行讨论：</p><ul><li>如果 $a_1&gt;L$，替换 $t4$ ，重新判定</li><li>如果 $a_1\le L$，替换 $t3$</li></ul><h2 id="参考程序-5">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,l,d;cin &gt;&gt; n &gt;&gt; l &gt;&gt; d;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    ll t1 = v[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    ll cntll=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v) <span class="keyword">if</span>(x&lt;l) cntll++;</span><br><span class="line">    <span class="keyword">if</span>(cntll&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t1&gt;=l)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1-v.<span class="built_in">front</span>()&lt;=d) cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v.<span class="built_in">back</span>()-v.<span class="built_in">front</span>()&lt;=d) cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期牛客多校04</title>
      <link href="/posts/ACM_2024Summer_NCD04.html"/>
      <url>/posts/ACM_2024Summer_NCD04.html</url>
      
        <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81599">2024牛客暑期多校训练营4</a></p><h1>A.LCT</h1><h2 id="题意">题意</h2><p>给定一棵有根树，问按顺序给定的前 $i$ 条边组成的森林中，以 $c_i$ 为根的树的深度。</p><h2 id="解题思路">解题思路</h2><p>按步骤生成森林的过程，与并查集合并的过程一致。<br>因此用带权并查集，维护每个点的深度和答案，利用路径压缩降低时间复杂度。</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span>&#123;</span><br><span class="line">    vector&lt;ll&gt; parents, size, dep, ans;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">DSU</span><span class="params">(ll n)</span> : parents(n + <span class="number">1</span>), size(n + <span class="number">1</span>, <span class="number">1</span>), dep(n + <span class="number">1</span>, <span class="number">0</span>), ans(n + <span class="number">1</span>, <span class="number">0</span>) &#123;</span> <span class="built_in">iota</span>(parents.<span class="built_in">begin</span>(), parents.<span class="built_in">end</span>(), <span class="number">0</span>); &#125;</span><br><span class="line">    <span class="function">ll <span class="title">find</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == parents[x]) <span class="keyword">return</span> x;</span><br><span class="line">        ll px = <span class="built_in">find</span>(parents[x]);</span><br><span class="line">        dep[x]+=dep[parents[x]]; </span><br><span class="line">        <span class="keyword">return</span> parents[x]=px;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">// merge b into a</span></span><br><span class="line">        ll pa = <span class="built_in">find</span>(a);</span><br><span class="line">        parents[b] = a;</span><br><span class="line">        dep[b] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="built_in">chmax</span>(ans[pa],ans[b]+dep[b]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> ans[x];&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="function">DSU <span class="title">dsu</span><span class="params">(n)</span></span>;</span><br><span class="line">    ll a,b,q;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        dsu.<span class="built_in">merge</span>(a,b);</span><br><span class="line">        cin &gt;&gt; q;</span><br><span class="line">        cout &lt;&lt; dsu.<span class="built_in">query</span>(q) &lt;&lt; <span class="built_in">Presentation</span>(i,n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C.Sort4</h1><h2 id="题意-2">题意</h2><p>给定一个长度为 $n$ 的排列 $p$ （即序列中 $1$ ~ $n$ 的每个数恰好出现一次）。<br>每次操作可以选择4个元素，并任意交换它们的位置。<br>求使得排列变为升序的最少操作次数。</p><h2 id="解题思路-2">解题思路</h2><p>把排列看作由 $i\rightarrow p_i$（下标从1开始） 构成的图，这个图中有若干个环，表示这个环中的元素可以通过交换回到原来的位置。</p><p>长度为 $3,4$ 的环，可以通过一次操作还原；<br>长度为 $2$ 的环，可以 $2$ 个环一组通过一次操作还原；<br>长度大于 $4$ 的环，每次操作可以让 $3$ 个元素回到原来的位置，使得环的长度减少 $3$，直到环的长度小于等于 $4$。</p><p>根据这个原则，计算最终答案。</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; v[i];</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    ll ans=<span class="number">0</span>,of=<span class="number">0</span>; <span class="comment">//of:最终长度为2的环的数量</span></span><br><span class="line">    map&lt;ll,ll&gt; mp;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[v[i]]) <span class="keyword">continue</span>;</span><br><span class="line">        ll cnt=<span class="number">1</span>,cur=v[i];</span><br><span class="line">        vis[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=i)&#123;</span><br><span class="line">            vis[cur]=<span class="number">1</span>;</span><br><span class="line">            cur = v[cur];</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt%<span class="number">3</span>==<span class="number">1</span>) ans+=(cnt<span class="number">-1</span>)/<span class="number">3</span>; <span class="comment">//最终长度为4的环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt%<span class="number">3</span>==<span class="number">2</span>)&#123; <span class="comment">//最终长度为2的环</span></span><br><span class="line">            ans+=(cnt<span class="number">-2</span>)/<span class="number">3</span>;</span><br><span class="line">            of++;</span><br><span class="line">        &#125;<span class="keyword">else</span> ans+=cnt/<span class="number">3</span>; <span class="comment">//最终长度为3的环</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans+(of+<span class="number">1</span>)/<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>H.Yet Another Origami Problem</h1><h2 id="题意-3">题意</h2><p>给定一个长度为 $n$ 的序列 $a$，每次可以选择一个元素 $a_i$，执行以下操作之一：</p><ol><li>所有原来比 $a_i$ 小的数 $a_j$ ： $a_j=a_i+2(a_i-a_j)$ ，即原来 $a_j$ 比 $a_i$ 小多少，现在就比 $a_i$ 大多少。</li><li>所有原来比 $a_i$ 大的数 $a_j$ ： $a_j=a_i-2(a_j+a_i)$ ，即原来 $a_j$ 比 $a_i$ 大多少，现在就比 $a_i$ 小多少。</li></ol><p>问任意次操作后，序列 $a$ 中最大元素和最小元素之差 $max(a)-min(a)$ 的最小值。</p><h2 id="解题思路-3">解题思路</h2><p>每次操作：</p><ol><li>对序列 $a$ 排序去重，求出差分数组 $d$ 。</li><li>选定次小元素 $a_2$ ，执行操作 $1$ ，使得最小元素 $a_1 = a_2 - d_1$ 变成 $a_1’ = a_2 + d_1$ 。</li></ol><p>假设重新排序去重后，新的 $a_1’$ 相邻的两项为 $a_j,a_{j+1}$ ，步骤1中这两项的差分是 $d_j=a_{j+1}-a_j$ 。<br>那么当 $a_i’$ 插到中间时，新的差分数组的变化如下：</p><ol><li>第1项 $d_1$ 删去（因为 $a_1$ 变成了 $a_1’$ 后移）</li><li>原本的 $d_j$ 被替换为 $d_j’=d_1-\sum\limits_{k=2}^{j-1}d_k$ ，$d’_{j+1}=d_j-d_j’$ 。</li></ol><p>第2点变化可能比较难理解，给出如下例子：</p><ul><li>$a = [1,6,8,10,13,15]$ （原序列排序去重）</li><li>$d = [5,2,2,3,2]$ （差分数组）</li><li>$a_1=1,a_2=6,d_1=5$ （选定次小元素做操作1）</li><li>$a_1’=a_2+d_1=11$</li><li>$a’ = [6,8,10,11,13,15]$ （新序列排序去重，$a_1’$ 位于第4位）</li><li>$d’ = [2,2,1,2,2]$ （新差分数组）</li></ul><p>差分数组的变化：</p><ol><li>第1项 $d_1=5$ 删去</li><li>第4项 $3$ 变为：$d_1-d_2-d_3=1$ 和 $3-1=2$</li></ol><p>这个变化的意义就在于，它证明了任意次操作后的差分数组中的元素，是原差分数组中元素的线性组合，且随着操作次数增加，$\sum d_i$ 逐渐减小，直到 $a$ 仅剩2个元素。<br>线性组合能达到的最小值为 $\gcd\limits_{i=1}^{n-1}d_i$ 。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)</span><br><span class="line">        ans = __gcd(ans,v[i]-v[i<span class="number">-1</span>]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>G.Horse Drink Water</h1><h2 id="题意-4">题意</h2><p>将军饮马问题，将军在第一象限的整点 $(x_0,y_0)$ ，河流由 $x$ 正半轴和 $y$ 正半轴组成。<br>问将军碰到河流再前往 $(x_1,y_1)$ 的最短路径长度。</p><h2 id="解题思路-4">解题思路</h2><p>将起点以 $x$ 轴、 $y$ 轴为对称轴，分别对称到第四、二象限，比较这两个点和终点的距离，取最小值。</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ld xx1,xx2,yy1,yy2;</span><br><span class="line">    cin &gt;&gt; xx1 &gt;&gt; yy1 &gt;&gt; xx2 &gt;&gt; yy2;</span><br><span class="line">    ld ans1,ans2;</span><br><span class="line">    ans1 = <span class="built_in">sqrt</span>((xx1-xx2)*(xx1-xx2)+(yy1+yy2)*(yy1+yy2));</span><br><span class="line">    ans2 = <span class="built_in">sqrt</span>((xx1+xx2)*(xx1+xx2)+(yy1-yy2)*(yy1-yy2));</span><br><span class="line">    <span class="built_in">print_float</span>(<span class="built_in">min</span>(ans1,ans2),<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>I</h1><p>// TODO</p>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期牛客多校03</title>
      <link href="/posts/ACM_2024Summer_NCD03.html"/>
      <url>/posts/ACM_2024Summer_NCD03.html</url>
      
        <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81598">2024牛客暑期多校训练营3</a></p><h1>A.Bridging the Gap 2</h1><h2 id="题意">题意</h2><p>$n$个人过河，第 $i$ 个人初始有 $h_i$ 点体力。<br>由于船的限制，每次过河（或返回）至少需要乘坐 $l$ 人（来划船），至多可以乘坐 $r$ 人，<strong>每个</strong>乘船的人都会消耗 $1$ 点体力。体力为 $0$ 的人无法乘船。<br>求对于给定的条件，是否能够使所有人过河。</p><h2 id="解题思路">解题思路</h2><p>假设初始所有人在左岸，考虑一种贪心模拟的做法：</p><ul><li>从在左岸的所有人中选取 $l$ 个体力最大的人划船，带 $r-l$ 个体力最小的人去右岸。</li><li>从在右岸的所有人中选取 $l$ 个体力最大的人划船返回左岸。</li><li>重复以上步骤，直到所有人都到达右岸，或者无法继续。</li></ul><p>这个过程中，除去最后一次划到右岸的 $r$ 个人，每次能运输的人数为 $r-l$ 。<br>最低<strong>往返</strong>的次数为 $turn = \lceil \dfrac{n-r}{r-l}\rceil$ ，且最优，因为往返越少对体力的要求越低。</p><p>对于个人，除自己前往右岸的1点体力，多余的体力可以用于划船带人，往返一次需要2点体力。<br>因此第 $i$ 个人能够参与的往返次数为 $\lfloor \dfrac{h_i-1}{2}\rfloor$ 。<br>由于只存在 $turn$ 次往返，因此第 $i$ 个人能够参与的往返次数为 $\min(\lfloor \dfrac{h_i-1}{2}\rfloor,turn)$ 。</p><p>计算所有人能够参与的往返次数之和，如果大于等于 $turn*l$ ，则按照上述贪心模拟的方法，可以使所有人过河。</p><h2 id="参考程序">参考程序</h2><blockquote><p>程序是副机长根据解题思路写的，居然A了()</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,l,r; cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;x:v) cin &gt;&gt; x;</span><br><span class="line">    ll turn = (n-r)/(r-l) + ((n-r)%(r-l)!=<span class="number">0</span>);</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v) sum += <span class="built_in">min</span>((x<span class="number">-1</span>)/<span class="number">2</span>,turn);</span><br><span class="line">    cout &lt;&lt; (sum&gt;=turn*l?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.Crash Test</h1><h2 id="题意-2">题意</h2><p>初始距离墙壁的距离为 $d$ 。<br>每次前进有 $n$ 种长度可以选择：$h_1,h_2,\cdots,h_n$。每次前进的长度可以是任意一种长度。<br>如果选择的长度 $h_i$ 大于当前与墙壁的距离 $d’$ ，将会退后多余的距离，即新的距离为 $h_i - d’$ 。<br>求在任意次（包括0次）前进后，与墙壁的最小距离。</p><h2 id="解题思路-2">解题思路</h2><p><a href="https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593">裴蜀定理</a>：对于非0整数 $a,b$ ，对任意整数 $x,y$ 有 $gcd(a,b)|ax+by$ 成立，即 $gcd(a,b)$ 是所有 $a,b$ 的线性组合中，绝对值最小的非0整数。</p><p>裴蜀定理扩展到多整数的情况仍然成立。</p><p>因此计算出 $g=\gcd\limits_{i=1}^n(h_i)$ ，$g$ 的意义是通过对 $h_i$ 的某种线性组合，能够得到的最小前进距离。</p><p>然后每一步视为走 $g$ ，以此求得不撞墙答案 $d%g$ 与撞墙答案 $g-d%g$ ，取较小值即可。</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,d; cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    ll g = v[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v) g = __gcd(g,x);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(d%g,g-d%g) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>D.Dominoes!</h1><p>//TODO</p><h1>J.Rigged Games</h1><p>//TODO</p><h1>L.Sudoku and Minesweeper</h1><h2 id="题意-3">题意</h2><p>经典数独在 $9\times 9$ 大小的棋盘格内进行，每一行、每一列、$9$ 个 $3\times 3$ 的小方块内，数字 $1-9$ 恰好出现一次。</p><p>扫雷是一款在棋盘格内进行的游戏，中心数字表示周围 $8$ 格包含地雷的数量。</p><p>现给定一个 $9\times 9$ 数字矩阵表示一个已经完成的合法经典数独，可以将里面的数字替换成地雷，但必须保留至少 $1$ 个数字，求一个合法的扫雷游戏布局。</p><h2 id="解题思路-3">解题思路</h2><p>除了边缘之外，中间 $7\times 7$ 范围内必然出现数字 $8$ 。<br>这是一个特殊的数字，只需要把它保留，其余所有数字全部替换成地雷，就是一个合法的扫雷游戏布局。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">vs</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;s:vs) cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> fl=<span class="number">0</span>,i8,i8;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,<span class="number">7</span>)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,<span class="number">7</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vs[i][j]==<span class="string">&#x27;8&#x27;</span>)&#123;</span><br><span class="line">                i8=i; i8=j; fl=<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">if</span>(fl) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,<span class="number">8</span>)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,<span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==i8&amp;&amp;j==i8) cout &lt;&lt; <span class="string">&#x27;8&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期杭电多校02</title>
      <link href="/posts/ACM_2024Summer_HDU02.html"/>
      <url>/posts/ACM_2024Summer_HDU02.html</url>
      
        <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A82%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（2）</a></p><h1>(1001)HDU7445.鸡爪</h1><p><strong>构造</strong></p><h2 id="题意">题意</h2><p>一个鸡爪由一个中心节点和3条（不含端点的）边构成。如下图中，三条边和节点 $1$ 构成一个鸡爪，节点 $2,3,4$ 不属于这个鸡爪。<br><img src="/images/ACM//2024Summer_HDU02_1001_1.png" alt="image"></p><p>给定正整数 $n$ ，允许使用 $n$ 条边和任意个节点。要求构造一张图，在包含尽可能最多的鸡爪的条件下，按顺序输出图的 $n$ 条边时的字典序最小。</p><h2 id="解题思路">解题思路</h2><p>不限制节点数的情况下，想要构造最多$n/3$（整除）个的鸡爪是很容易的，问题的关键是如何构造使得字典序最小。</p><p>先讨论 $n$ 是3的倍数的情况。<br>由于一个中心点只能被一个鸡爪使用，贪心的想法便是让节点 $1$~$n/3$ 成为中心点，且依次尽量让节点 $1,2,3$ 连接更多的点。</p><p>$4$~$n/3$ 这些点首先作为中心点和 $1,2,3$ 相连。<br>$1,2,3$ 三个点互相连接后，无法构成以 $1,2,3$ 为中心的鸡爪，因此需要借助 $n/3+1, n/3+2, n/3+3$ 这三个点进行构造。</p><p>连接图如下：<br><img src="/images/ACM/2024Summer_HDU02_1001_2.png" alt="image"></p><p>其他情况：<br>对于 $n$ 不是3的倍数的情况，将多余的1或2个点连接到节点1上。<br>$n\le 6$时，由于节点数太少，需要单独构造。</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;pll&gt;&gt; ans=&#123;</span><br><span class="line">    &#123;&#125;, <span class="comment">// 0</span></span><br><span class="line">    &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>&#125;&#125;, <span class="comment">// 1</span></span><br><span class="line">    &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>&#125;,&#123;<span class="number">1</span>,<span class="number">6</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">2</span>,<span class="number">4</span>&#125;&#125;, <span class="comment">// 2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">6</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:ans[n])&#123;</span><br><span class="line">            cout &lt;&lt; p.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line">        &#125;<span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;pll&gt; edges;</span><br><span class="line">    ll cnt = n/<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,cnt+<span class="number">3</span>) edges.<span class="built_in">emplace_back</span>(<span class="number">1</span>,i); </span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">3</span>,cnt+<span class="number">2</span>) edges.<span class="built_in">emplace_back</span>(<span class="number">2</span>,i);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">4</span>,cnt+<span class="number">1</span>) edges.<span class="built_in">emplace_back</span>(<span class="number">3</span>,i); </span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n%<span class="number">3</span>) edges.<span class="built_in">emplace_back</span>(<span class="number">1</span>,cnt+<span class="number">3</span>+i);</span><br><span class="line">    <span class="built_in">SORT</span>(edges);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p:edges)&#123;</span><br><span class="line">        cout &lt;&lt; p.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;Test:&quot; &lt;&lt; edges.size() &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1003)HDU7447.绝对不模拟的简单魔方</h1><h2 id="题意-2">题意</h2><p>给定一个三阶魔方，用$1$~$6$表示6个面的颜色。<br>魔方从初始还原状态起，侧面被扭转了不超过3次，且有一个角上的两片颜色贴纸可能贴错。<br>确定魔方的贴纸是否被贴错。如果有贴错，输出贴错那个角的三个颜色。</p><h2 id="解题思路-2">解题思路</h2><p>扭转三次的操作对于魔方的角来说没有任何影响，只是虚晃一枪（题目中也提示了“绝对不模拟”）。</p><blockquote><p>但是赛时还是有神速度写模拟而且一遍过了%%%%</p></blockquote><p>只需要先把正常状态的魔方的8个角按同一顺序（如顺时针）记录下来，统一以$1,6$开头以唯一确定三元组。<br>再把输入的魔方的8个角按同一顺序（顺时针）记录下来，统一以$1,6$开头，然后在正常状态的记录中查找，找不到的就是被贴错贴纸的角。</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cor</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">cor</span>(<span class="type">int</span> _a,<span class="type">int</span> _b,<span class="type">int</span> _c):<span class="built_in">a</span>(_a),<span class="built_in">b</span>(_b),<span class="built_in">c</span>(_c)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(cor t)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a==t.a&amp;&amp;b==t.b&amp;&amp;c==t.c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">srt</span><span class="params">()</span></span>&#123; <span class="comment">//按大小排序</span></span><br><span class="line">        <span class="keyword">if</span>(a&gt;b) <span class="built_in">swap</span>(a,b);</span><br><span class="line">        <span class="keyword">if</span>(b&gt;c) <span class="built_in">swap</span>(b,c);</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b) <span class="built_in">swap</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mkstd</span><span class="params">()</span></span>&#123; <span class="comment">//把三元组化为以1或6开头的形式</span></span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="keyword">while</span>(a!=<span class="number">1</span>&amp;&amp;a!=<span class="number">6</span>)&#123;</span><br><span class="line">            t=a; a=b; b=c; c=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//原始魔方八个角，顺时针</span></span><br><span class="line">vector&lt;cor&gt; std_cor = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>&#125;,&#123;<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>&#125;,&#123;<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>&#125;,&#123;<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>&#125;,&#123;<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">mf</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s:mf) cin &gt;&gt; s;</span><br><span class="line">    vector&lt;cor&gt; corners=&#123;<span class="comment">//给定魔方的八个角，顺时针</span></span><br><span class="line">        &#123;mf[<span class="number">0</span>][<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">3</span>][<span class="number">11</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">3</span>][<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">8</span>][<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">11</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">3</span>][<span class="number">8</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">3</span>][<span class="number">9</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">0</span>][<span class="number">5</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">5</span>][<span class="number">8</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">8</span>][<span class="number">5</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">9</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">6</span>][<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">2</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">3</span>][<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">2</span>][<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">3</span>][<span class="number">2</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">6</span>][<span class="number">5</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">6</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">5</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">3</span>][<span class="number">6</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">2</span>][<span class="number">5</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">3</span>][<span class="number">5</span>]-<span class="string">&#x27;0&#x27;</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; cor:corners) cor.<span class="built_in">mkstd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; cor:corners)&#123;</span><br><span class="line">        <span class="type">int</span> fl=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; st:std_cor) <span class="keyword">if</span>(st==cor) &#123;fl=<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(fl) <span class="keyword">continue</span>;</span><br><span class="line">        cor.<span class="built_in">srt</span>();</span><br><span class="line">        cout &lt;&lt; cor.a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; cor.b &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; cor.c &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;No problem&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1006)HDU7450.传奇勇士小凯</h1><h2 id="题意-3">题意</h2><p>一棵以 $1$ 为根， $n$ 个节点的树，在第 $i$ 个节点处，每天有 $\dfrac{p_i}{15}$ 的概率可以离开当前节点，并选择一个子节点走一步。<br>从根节点 $1$ 走到任意叶子节点的最大天数的期望。</p><h2 id="解题思路-3">解题思路</h2><p>在第 $i$ 个节点处，记停留在该节点的期望天数为 $x$ ，有 $\dfrac{p_i}{15}$ 的概率可以离开（停留 $1$ 天），有 $1-\dfrac{p_i}{15}$ 的概率停留在当前节点（停留 $x+1$ 天）。<br>有 $x = \dfrac{p_i}{15} + \dfrac{15-p_i}{15} \cdot (1+x)$ 成立，解得 $x = \dfrac{15}{p_i}$ 。</p><p>问题转换为选择一条以节点 $1$ 开头，以叶子节点结尾的路径，使得路径上的每个节点的期望天数 $\dfrac{15}{p_i}$ 之和最大。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">form</span><span class="params">(pll&amp; p)</span></span>&#123; <span class="comment">//化简</span></span><br><span class="line">    ll g = __gcd(p.first,p.second);</span><br><span class="line">    p.first/=g;</span><br><span class="line">    p.second/=g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">smaller</span><span class="params">(pll a,pll b)</span></span>&#123; <span class="comment">//a&lt;b</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.</span>*a.first/a.second&lt;<span class="number">1.</span>*b.first/b.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addto</span><span class="params">(pll&amp; a,pll b)</span></span>&#123; <span class="comment">//a+=b</span></span><br><span class="line">    a.first=a.first*b.second+a.second*b.first;</span><br><span class="line">    a.second*=b.second;</span><br><span class="line">    form(a);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;ll&gt; vdfs; <span class="comment">//dfs序列</span></span><br><span class="line">vector&lt;vector&lt;ll&gt;&gt; G;</span><br><span class="line">vector&lt;ll&gt; fa;</span><br><span class="line">vector&lt;pll&gt; ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll x,ll f)</span></span>&#123;</span><br><span class="line">    fa[x]=f;</span><br><span class="line">    vdfs.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;y:G[x]) <span class="keyword">if</span>(y!=f) <span class="built_in">dfs</span>(y,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    G.<span class="built_in">clear</span>(); G.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    fa.<span class="built_in">clear</span>(); fa.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    ans.<span class="built_in">clear</span>(); ans.<span class="built_in">resize</span>(n+<span class="number">1</span>,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    vdfs.<span class="built_in">clear</span>();</span><br><span class="line">    ll u,v,t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">        G[v].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">    &#125; <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        ans[i]=&#123;<span class="number">15</span>,t&#125;; <span class="comment">//直接存入第i个节点的期望</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">ALL</span>(vdfs));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> cur:vdfs)&#123; <span class="comment">//逆DFS序遍历</span></span><br><span class="line">        pll mx=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;y:G[cur]) <span class="keyword">if</span>(y!=fa[cur])&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">smaller</span>(mx,ans[y])) mx=ans[y];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">addto</span>(ans[cur],mx);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans[<span class="number">1</span>].first &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; ans[<span class="number">1</span>].second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1007)HDU7451.URL划分</h1><h2 id="题意-4">题意</h2><p>给定字符串URL，形如：<code>s3://hdu-oj-bucket/problem=1/type=data/</code><br>从中提取出：</p><ul><li>传输协议：<code>://</code>之前的内容，如<code>s3</code></li><li>网络位置：<code>://</code>之后，第一个<code>/</code>之前的内容，如<code>hdu-oj-bucket</code></li><li>环境变量：由<code>/</code>分割，形如<code>A=B</code>的内容，如<code>problem=1</code>，<code>type=data</code></li></ul><h2 id="解题思路-4">解题思路</h2><p>按题目要求提取即可</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s; cin &gt;&gt; s;</span><br><span class="line">    string protocol;</span><br><span class="line">    string location;</span><br><span class="line">    vector&lt;string&gt; var;</span><br><span class="line">    string varname,val;</span><br><span class="line">    ll n=s.<span class="built_in">length</span>(),i=<span class="number">0</span>,t;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;:&#x27;</span>)&#123;</span><br><span class="line">            protocol = s.<span class="built_in">substr</span>(<span class="number">0</span>,i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">1</span>;</span><br><span class="line">    &#125; i+=<span class="number">3</span>;</span><br><span class="line">    ll j=i;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            location = s.<span class="built_in">substr</span>(j,i-j);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; i++;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123; <span class="comment">//匹配varname=val，以/分隔</span></span><br><span class="line">        j=i;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;n&amp;&amp;s[j]!=<span class="string">&#x27;=&#x27;</span>&amp;&amp;s[j]!=<span class="string">&#x27;/&#x27;</span>) j++;</span><br><span class="line">        <span class="keyword">if</span>(s[j]==<span class="string">&#x27;/&#x27;</span>)&#123; <span class="comment">//跳过</span></span><br><span class="line">            i=j+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[j]==<span class="string">&#x27;=&#x27;</span>)&#123;</span><br><span class="line">            varname=s.<span class="built_in">substr</span>(i,j-i);</span><br><span class="line">            i=j+<span class="number">1</span>; j=i;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;n&amp;&amp;s[j]!=<span class="string">&#x27;/&#x27;</span>) j++;</span><br><span class="line">            val=s.<span class="built_in">substr</span>(i,j-i);</span><br><span class="line">            var.<span class="built_in">emplace_back</span>(varname+<span class="string">&quot;=&quot;</span>+val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; protocol &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; location &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:var) cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>写完python才发现hduOJ不支持python…</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    url = <span class="built_in">input</span>()</span><br><span class="line">    protocol, location, *path = re.split(<span class="string">r&quot;://|/&quot;</span>, url)</span><br><span class="line">    variables = [p <span class="keyword">for</span> p <span class="keyword">in</span> path <span class="keyword">if</span> <span class="string">&quot;=&quot;</span> <span class="keyword">in</span> p]</span><br><span class="line">    <span class="built_in">print</span>(protocol)</span><br><span class="line">    <span class="built_in">print</span>(location)</span><br><span class="line">    <span class="keyword">for</span> variable <span class="keyword">in</span> variables:</span><br><span class="line">        <span class="built_in">print</span>(variable)</span><br></pre></td></tr></table></figure><h1>(1010)HDU7454.女神的睿智</h1><h2 id="题意-5">题意</h2><p>给定长度为$8$的字符串，由<code>R,G,B</code>三种字符组成。<br>进行以下三轮操作，每轮操作从左往右两两合并：</p><ol><li>颜色相同时，合并为该颜色；颜色不同时，合并为左侧颜色</li><li>颜色相同时，合并为该颜色；颜色不同时，合并为左侧颜色</li><li>颜色相同时，合并为该颜色；颜色不同时，比较两种颜色在初始字符串中的数量，合并为数量多的一种；数量相同时，合并为随机颜色</li></ol><p>求最终合并后的颜色：<code>R,G,B</code>或不确定颜色<code>N</code></p><h2 id="解题思路-5">解题思路</h2><p>按题目要求模拟即可</p><h2 id="参考程序-5">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s,s2; cin &gt;&gt; s;</span><br><span class="line">    map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s) mp[c]++;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i+=<span class="number">2</span>) s2.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">    s.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i+=<span class="number">2</span>) s.<span class="built_in">push_back</span>(s2[i]);</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]==s[<span class="number">1</span>]) cout &lt;&lt; s[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mp[s[<span class="number">0</span>]]!=mp[s[<span class="number">1</span>]]) cout &lt;&lt; s[mp[s[<span class="number">0</span>]]&lt;mp[s[<span class="number">1</span>]]] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&#x27;N&#x27;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1011)HDU7455.在 A 里面找有 C 的 B</h1><p>//TODO</p>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期杭电多校01</title>
      <link href="/posts/ACM_2024Summer_HDU01.html"/>
      <url>/posts/ACM_2024Summer_HDU01.html</url>
      
        <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A81%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（1）</a></p><h1>(1001)HDU7433.循环位移</h1><p><strong>字符串</strong></p><h2 id="题意">题意</h2><p>给定两个字符串 $A,B$ 。<br>定义 $[A]$ 为字符串 $A$ 的循环位移任意次可以得到的所有字符串的集合。<br>求 $B$ 包含 $[A]$ 中元素的个数。</p><h2 id="解题思路">解题思路</h2><p>利用字符串Hash快速匹配。<br>将 $[A]$ 中所有元素的Hash记录到一个set：计算 $A+A$ 的Hash前缀和，以快速得到所有长度为 $|A|$ 的子串的Hash值，并加入set中。<br>枚举 $B$ 的所有长度为 $|A|$ 的子串，计算Hash值，判断是否在set中，计数。</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    ll n=a.<span class="built_in">length</span>(),m=b.<span class="built_in">length</span>();</span><br><span class="line">    set&lt;pll&gt; st;</span><br><span class="line">    <span class="function">strHash <span class="title">sa</span><span class="params">(a+a)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        st.<span class="built_in">insert</span>(sa.<span class="built_in">findz</span>(i,i+n<span class="number">-1</span>));</span><br><span class="line">    <span class="function">strHash <span class="title">sb</span><span class="params">(b)</span></span>;</span><br><span class="line">    ll ans = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m-n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">count</span>(sb.<span class="built_in">findz</span>(i,i+n<span class="number">-1</span>))) ans++;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1002)HDU7434.星星</h1><p><strong>背包DP</strong></p><h2 id="题意-2">题意</h2><p>小A要进行n次选择，每次可以选择一项：</p><ol><li>不执行操作</li><li>付出$a_i$点代价得到1颗星星</li><li>付出$b_i$点代价得到2颗星星</li><li>付出$c_i$点代价得到3颗星星</li><li>付出$d_i$点代价得到4颗星星</li></ol><p>求恰好得到$k$颗星星的最小代价。</p><h2 id="解题思路-2">解题思路</h2><p>一眼顶针鉴定为背包DP的分组背包问题。</p><p>$dp_x$表示选x个物品的最低cost。<br>在第$i$组时，从大到小遍历作出选择后有$j$个星星。<br>遍历这一步的选择（ $l$ 个星星），从 $dp_{j-l}$ 更新到 $dp_j$ ，这样更新保证了一次操作只生效一项。</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k;cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    vector&lt;array&lt;ll,5&gt;&gt; <span class="built_in">cost</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">dp</span><span class="params">(k+<span class="number">1</span>,INF)</span></span>; dp[<span class="number">0</span>]=<span class="number">0</span>; <span class="comment">//选i个物品的最低cost</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cin &gt;&gt; cost[i][<span class="number">1</span>] &gt;&gt; cost[i][<span class="number">2</span>] &gt;&gt; cost[i][<span class="number">3</span>] &gt;&gt; cost[i][<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123; <span class="comment">//第i步</span></span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,k,<span class="number">1</span>)&#123; <span class="comment">//选择后的个数</span></span><br><span class="line">            <span class="built_in">FORLL</span>(l,<span class="number">0</span>,<span class="number">4</span>)&#123; <span class="comment">//这一步选择l个</span></span><br><span class="line">                <span class="keyword">if</span>(j-l&gt;=<span class="number">0</span>) <span class="built_in">chmin</span>(dp[j],dp[j-l]+cost[i][l]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[k] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1008)HDU7440.位运算</h1><h2 id="题意-3">题意</h2><p>给定整数$n,k$，求满足 $((a\otimes b)\oplus c)\ominus d=n$ 的四元组 $(a,b,c,d)，0\le a,b,c,d\lt 2^k$ 的个数。</p><p>其中，$\otimes$ 表示按位与，$\oplus$ 表示按位异或，$\ominus$ 表示按位或。</p><h2 id="解题思路-3">解题思路</h2><p>转为二进制，按位考虑。</p><p>若 $n$ 的某一位上是 $0$ ， $d$ 在这一位上必须为 $0$ ，$c$ 在这一位上由 $a,b$ 决定（控制这一位为 $0$），$a,b$ 在这一位上任选，即 $1\times 1\times 2\times 2=4$ 种可能。</p><p>若 $n$ 的某一位上是 $1$ ：</p><ol><li>若 $d$ 在这一位上为 $0$ ，则 $c$ 在这一位上由 $a,b$ 决定（控制这一位为 $1$），$a,b$ 在这一位上任选，即 $1\times 1\times 2\times 2=4$ 种可能。</li><li>若 $d$ 在这一位上为 $1$ ，则 $a,b,c$ 在这一位上任选，即 $1\times 2\times 2\times 2=8$ 种可能。</li></ol><p>综上，$n$ 的一位上是 $1$ 时有 $12$ 种可能，是 $0$ 时有 $4$ 种可能。</p><p>答案为 $4^k\times 3^{cnt1}$ 。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    ll cnt1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>) cnt1++;</span><br><span class="line">        n/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">qcpow</span>(<span class="number">2</span>,k*<span class="number">2</span>)*<span class="built_in">qcpow</span>(<span class="number">3</span>,cnt1) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1012)HDU7444.并</h1><h2 id="题意-4">题意</h2><p>给定 $n$ 个矩形，对 $k=1\to n$ 分别求随机取 $k$ 个矩形的面积并的期望。</p><h2 id="解题思路-4">解题思路</h2><p>平面可以被矩形边界分割成若干个小区域，考虑每个区域对答案的贡献。</p><p>因为要求期望，被“相同数量矩形覆盖”的小区域 对答案的贡献是相同的，因此按照 覆盖矩形数量 将这些小区域分组，统计出恰好被 $i$ 个矩形覆盖的区域的面积 $S_i$。</p><p>我的求法就是从左到右扫描，在每条竖线的位置，更新 $i$ 个矩形覆盖的y轴长度 $yval_i$ ，到下一条竖线再乘经过的x轴长度，得到这一部分的面积（类似于积分？），加入 $S_i$</p><p>然后考虑贡献的权重。<br>从 $n$ 个矩形中随机选取 $k$ 个，对于被 $i$ 个矩形覆盖的区域，只要选取的 $k$ 个矩形中，存在这 $i$ 个矩形之一，那么这个面积就会被计入。<br>在上述条件下的贡献权重是 $val_{k,i}=\frac{C_{n}^{k}-C_{n-i}^{k}}{C_{n}^{k}}$ ，即从 $n$ 个矩形中选取 $k$ 个方案数，减去从 $n-i$ 个矩形中选取 $k$ 个方案数。</p><p>最后答案$ans_k$是 $\sum\limits_{i=1}^{n}val_{k,i}\times S_i$ 。</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">Prepare_Combination</span>(<span class="number">5005</span>);</span><br><span class="line">    MOD = <span class="number">998244353</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getval</span><span class="params">(ll n,ll i,ll j)</span></span>&#123;</span><br><span class="line">    ll ret=C[n][i],sb;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;n-j) sb=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> sb = C[n-j][i];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sub</span>(ret,sb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    ll xx1,xx2,yy1,yy2;</span><br><span class="line">    vector&lt;tuple&lt;ll,ll,ll,ll&gt;&gt; xlines;</span><br><span class="line">    vector&lt;ll&gt; ylines;</span><br><span class="line">    <span class="comment">// xline:(y,x1,x2,flag) # 横线 flag:0上边界1下边界</span></span><br><span class="line">    <span class="comment">// yline:(x) # 竖线x坐标</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; xx1 &gt;&gt; yy1 &gt;&gt; xx2 &gt;&gt; yy2;</span><br><span class="line">        xlines.<span class="built_in">emplace_back</span>(yy1,xx1,xx2,<span class="number">0</span>);</span><br><span class="line">        xlines.<span class="built_in">emplace_back</span>(yy2,xx1,xx2,<span class="number">1</span>);</span><br><span class="line">        ylines.<span class="built_in">emplace_back</span>(xx1);</span><br><span class="line">        ylines.<span class="built_in">emplace_back</span>(xx2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SORT</span>(xlines); <span class="built_in">SORT</span>(ylines);</span><br><span class="line"></span><br><span class="line">    map&lt;ll,ll&gt; S,yval;</span><br><span class="line">    ll prex=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// S[i]:重叠i次部分的面积</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> xx:ylines)</span><br><span class="line">    &#123;</span><br><span class="line">        ll difx = xx-prex;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [pl,val]:yval)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// S[pl]+=difx*val;</span></span><br><span class="line">            <span class="built_in">addto</span>(S[pl],<span class="built_in">mul</span>(difx,val));</span><br><span class="line">        &#125;</span><br><span class="line">        yval.<span class="built_in">clear</span>();</span><br><span class="line">        ll cur = <span class="number">0</span>, prey = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [yy,xx1,xx2,flag]:xlines)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(xx1&lt;=xx&amp;&amp;xx&lt;xx2)</span><br><span class="line">            &#123;</span><br><span class="line">                yval[cur]+=yy-prey;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">0</span>) cur++;</span><br><span class="line">                <span class="keyword">else</span> cur--;</span><br><span class="line">                prey=yy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        prex = xx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(auto x:S) cout &lt;&lt; x.first &lt;&lt; &#x27; &#x27; &lt;&lt; x.second &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">            ll val = <span class="built_in">getval</span>(n,i,j);</span><br><span class="line">            ans = <span class="built_in">add</span>(ans,<span class="built_in">mul</span>(val,S[j]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">divto</span>(ans,C[n][i]);</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期牛客多校02</title>
      <link href="/posts/ACM_2024Summer_NCD02.html"/>
      <url>/posts/ACM_2024Summer_NCD02.html</url>
      
        <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81597">2024牛客暑期多校训练营2</a></p><h1>C.Red Walking on Grid</h1><h2 id="题意">题意</h2><p>一个2行 $n$ 列的网格上，有些格子是红色的，有些格子是白色的。<br>你可以最初选择一个红色的格子，然后每一步都可以选择上下左右相邻的红色格子。离开一个格子时，这个格子立即变成白色。问最多可以走多少步。<br>最初没有红色的格子，输出0。</p><h2 id="解题思路">解题思路</h2><p>总体思路就是找连通块，在每个连通块内部找到能走最多格的路径，然后所有连通块的答案取最大值。<br>由于无法走回头路，形如以下样式的连通块将无法走遍全部红色格子：</p><p><img src="/images/ACM/2024Summer_NCD02_C.png" alt="image"></p><p>先从头到尾扫一遍，有以上2种形式的连通块，将打×的部分预先涂成白色。这样就能保证每个红色格子都会被经过，计算到答案中。</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">array&lt;string, 2&gt; s;</span><br><span class="line">ll n,ans=<span class="number">1</span>;</span><br><span class="line"><span class="function">ll <span class="title">getstat</span><span class="params">(ll col)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;W&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;W&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;W&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;R&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;R&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;W&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;R&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;R&#x27;</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getcnt</span><span class="params">(ll col)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;W&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;W&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;W&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;R&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;R&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;W&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;R&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;R&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preprocess</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll cnt=<span class="number">0</span>,pre=<span class="number">0</span>,cur;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">getcnt</span>(<span class="number">0</span>)==<span class="number">1</span>) pre=<span class="built_in">getstat</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cur = <span class="built_in">getcnt</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="number">1</span>)&#123;</span><br><span class="line">            cur=<span class="built_in">getstat</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(pre&amp;&amp;cur&amp;&amp;cnt)&#123;</span><br><span class="line">                <span class="keyword">if</span>((cnt%<span class="number">2</span>==<span class="number">0</span>)&amp;&amp;((pre&amp;cur)==<span class="number">0</span>)) s[cur<span class="number">-1</span>][i<span class="number">-1</span>]=<span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>((cnt%<span class="number">2</span>)&amp;&amp;((pre&amp;cur))) s[cur<span class="number">-1</span>][i<span class="number">-1</span>]=<span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cnt=<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur==<span class="number">2</span>)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cnt=<span class="number">0</span>; pre=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getans</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll cnt=<span class="built_in">getcnt</span>(<span class="number">0</span>),pre=<span class="built_in">getstat</span>(<span class="number">0</span>),cur;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cur = <span class="built_in">getstat</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(cur&amp;pre)&#123;</span><br><span class="line">            cnt+=<span class="built_in">getcnt</span>(i);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">chmax</span>(ans,cnt);</span><br><span class="line">            cnt=<span class="built_in">getcnt</span>(i);</span><br><span class="line">        &#125;pre=cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">chmax</span>(ans,cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; s[<span class="number">0</span>] &gt;&gt; s[<span class="number">1</span>];</span><br><span class="line">    ans=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">preprocess</span>();</span><br><span class="line">    <span class="built_in">getans</span>();</span><br><span class="line">    cout &lt;&lt; ans<span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>E.GCD VS XOR</h1><h2 id="题意-2">题意</h2><p>给定一个正整数 $x$ ，找到一个严格小于 $x$ 的正整数 $y$ ，使得 $gcd(x,y)=x\oplus y$ ，其中 $\oplus$ 表示按位异或。</p><h2 id="解题思路-2">解题思路</h2><p>首先观察到，对于一个正整数 $x$ ，$lowbit(x)$ 一定是 $x$ 的因子。<br>那么令 $y = x - lowbit(x)$ ，则 $gcd(x,y)=lowbit(x)$ ，$x\oplus y = lowbit(x)$ ，满足题意。</p><blockquote><p>有时候灵感就来源于一瞬间</p></blockquote><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    ll ans=n-<span class="built_in">lowbit</span>(n);</span><br><span class="line">    cout &lt;&lt; (ans?ans:<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>H.Instructions Substring</h1><h2 id="题意-3">题意</h2><p>你初始位于原点 $(0,0)$ 。<br>给定一串动作指令，包含<code>W</code>、<code>A</code>、<code>S</code>、<code>D</code>，分别表示向上（$y+=1$）、向左（$x-=1$）、向下（$y-=1$）、向右（$x+=1$）。<br>你需要选择一个连续的子串，使得执行这个子串的指令后，你能经过给定得一点 $(x,y)$ 。<br>计算符合条件的子串的个数。</p><h2 id="解题思路-3">解题思路</h2><p>假设选择了子串 $s_{ij}$ ，恰好能到达 $(x,y)$ ，那么 $s_j$ 之后任意增加指令都已经满足了“经过 $(x,y)$”的条件。</p><p>最暴力的做法就是枚举开头指令 $i$ ，枚举恰好到达 $(x,y)$ 的最小结尾指令 $j$ ，以位置 $i$ 开头的方案数就是 $n-j+1$ 。时间复杂度 $O(n^2)$ ，包TLE的，需要优化搜索过程。</p><p>我们可以先从头到尾执行（即做一个前缀和），每一步都记录到达当前位置 $(x_i,y_i)$ 时执行的指令编号 $i$ 。<br>再重新从头到尾执行一边，对于每一步到达的位置 $(x_i,y_i)$ ，将它视作起点（即假设之前的步骤都没有执行），那么需要经过的点变为 $(x_i+x,y_i+y)$ 。二分找到在 $i$ 之后到达过 $(x_i+x,y_i+y)$ 的最小指令编号 $j$ ，以位置 $i$ 开头的方案数就是 $n-j+1$ 。</p><p>$x=0,y=0$ 的情况比较特殊，特判一下即可。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//                W  S  D  A</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="function">ll <span class="title">conv</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;W&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;S&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;D&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;A&#x27;</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,x,y; cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    string s; cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; n*(n+<span class="number">1</span>)/<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;pll,vector&lt;ll&gt;&gt; mp;</span><br><span class="line">    ll cx,cy,dir; cx=cy=<span class="number">0</span>;</span><br><span class="line">    mp[&#123;cx,cy&#125;].<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">char</span> c = s[i];</span><br><span class="line">        dir = <span class="built_in">conv</span>(c);</span><br><span class="line">        cx += dx[dir];</span><br><span class="line">        cy += dy[dir];</span><br><span class="line">        mp[&#123;cx,cy&#125;].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    cx=cy=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> v = mp[&#123;cx+x,cy+y&#125;];</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(v),i);</span><br><span class="line">        <span class="keyword">if</span>(it!=v.<span class="built_in">end</span>()) ans+=n-(*it);</span><br><span class="line">        <span class="type">char</span> c = s[i];</span><br><span class="line">        dir = <span class="built_in">conv</span>(c);</span><br><span class="line">        cx += dx[dir];</span><br><span class="line">        cy += dy[dir];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> v = mp[&#123;cx+x,cy+y&#125;];</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(v),n);</span><br><span class="line">    <span class="keyword">if</span>(it!=v.<span class="built_in">end</span>()) ans+=n-(*it);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期牛客多校01</title>
      <link href="/posts/ACM_2024Summer_NCD01.html"/>
      <url>/posts/ACM_2024Summer_NCD01.html</url>
      
        <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81596">2024牛客暑期多校训练营1</a></p><h1>A.A Bit Common</h1><p><strong>组合数学</strong></p><h2 id="题意">题意</h2><p><strong>题目概括：</strong><br>给定两个整数 $n$ 和 $m$，我们需要计算所有包含 $n$ 个非负整数且每个整数都小于 $2^m$ 的序列中，满足<strong>存在一个</strong>非空子序列使得这些整数的按位与（bitwise AND）为 1 的序列的数量。</p><p>注意：一个序列的非空子序列是指从序列中删除零个或多个元素后得到的子序列，并保持剩余元素的原始顺序。</p><p>由于结果可能非常大，请输出结果对一个正整数 $q$ 取模后的值。</p><h2 id="解题思路">解题思路</h2><p>序列 $A$ 中的每个整数可以看作一个 $m$ 位的二进制数。</p><p>符合条件的序列中，所有末位为 1 的元素的&amp;和一定为 1（因为剩余的元素末位都是0，&amp;入答案会消灭末位1）。</p><p>枚举序列包含的 末位为 1 的元素个数 $k$ ，把这些数一行一个写成二进制，按位对齐。</p><p>对于这 $k$ 个元素，要满足除末位外每一个二进制位不全为 1 ，这 $k$ 个数每个二进制位（按列看）上的方案数为 $2^{k}-1$ （即除全1外）。<br>除末位外有 $m-1$ 个二进制位，（有序）方案数为 $a=(2^{k}-1)^{m-1}$ 。</p><p>对于剩余的 $n-k$ 个元素，只需要保证末位为 0 ，其他位不加限制，因此这 $n-k$ 个数每个二进制位（按列看）上的方案数为 $2^{n-k}$ （即除全1外）。<br>除末位外有 $m-1$ 个二进制位，（有序）方案数为 $b=(2^{n-k})^{m-1}$ 。</p><p>综合两部分，方案数为 $a\times b\times C_n^k$ 。<br>$C_n^k$ 表示序列的 $n$ 个位置中选取 $k$ 个用于顺序放置末位为 1 的 $k$ 个数。</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m &gt;&gt; MODULE::MOD;</span><br><span class="line">    <span class="built_in">Prepare_Combination</span>(<span class="number">5005</span>);</span><br><span class="line">    ll tmp,a,b,ans1=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(k,<span class="number">1</span>,n)&#123;</span><br><span class="line">        a = <span class="built_in">qcpow</span>(<span class="built_in">qcpow</span>(<span class="number">2</span>,k)<span class="number">-1</span>,m<span class="number">-1</span>); <span class="comment">// a = (2^k-1)^(m-1)</span></span><br><span class="line">        b = <span class="built_in">qcpow</span>(<span class="number">2</span>,<span class="built_in">mul</span>(n-k,m<span class="number">-1</span>)); <span class="comment">// b = 2^(n-k)^(m-1)</span></span><br><span class="line">        tmp = <span class="built_in">mul</span>(C[n][k],<span class="built_in">mul</span>(a,b)); <span class="comment">// tmp = C(n,k)*a*b</span></span><br><span class="line">        <span class="built_in">addto</span>(ans1,tmp); <span class="comment">// 加入答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) cout &lt;&lt; <span class="built_in">Get_Mod</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; ans1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.A Bit More Common</h1><h2 id="题意-2">题意</h2><p>给定两个整数 $n$ 和 $m$，我们需要计算所有包含 $n$ 个非负整数且每个整数都小于 $2^m$ 的序列中，满足<strong>存在两个</strong>非空子序列使得这些整数的按位与（bitwise AND）为 1 的序列的数量。</p><p>注意：一个序列的非空子序列是指从序列中删除零个或多个元素后得到的子序列，并保持剩余元素的原始顺序。</p><p>由于结果可能非常大，请输出结果对一个正整数 $q$ 取模后的值。</p><h2 id="解题思路-2">解题思路</h2><p>和A题的区别在于，需要满足存在两个非空子序列。</p><p>因此除A题中 “由所有末位为1的元素” 构成的&amp;和为1的子序列外，还要另考虑一个。<br>贪心的想法就是从上述子序列中删去某个元素，剩下的元素的&amp;和仍然为1。</p><p>枚举序列包含的 末位为 1 的元素个数 $k$ ，把这些数一行一个写成二进制，按位对齐。</p><p>正向考虑难以枚举，可以从反面考虑，即：从 这$k$个&amp;和为1的元素 中，删去任一元素，剩下的元素的&amp;和都不能为1。<br>要满足这一特性，每个元素都至少要有一位“特殊位0” 。</p><p>“特殊位0” ：即有且仅有唯一元素，在这个二进制位（按列看）上是 0 ，其他元素的这个二进制位上都为 1 。<br>这样，当删去这个元素后，其他元素这一位上的&amp;和将变成1，从而不满足条件。</p><p>记$dp(k,j)$： $k$ 个末位为 1 的数，每个数至少有 1 个“特殊位0” ，且它们共有 $j$ “特殊位0” 的方案数。<br>如果从这 $k$ 个数中选取 1 个，去掉它的 1 个特殊位，则有可能会导致一个数没有特殊位。<br>转移到：</p><ul><li>$k$ 个数，每个数至少有 1 个“特殊位0” ，且它们共有 $j-1$ 个“特殊位0”</li><li>$k-1$ 个数，每个数至少有 1 个“特殊位0” ，且它们共有 $j-1$ “特殊位0”</li></ul><p>得到转移方程： $dp(k,j)=k\times(dp(k,j-1)+dp(k-1,j-1))$ ，预处理dp数组。</p><p>对于这 $k$ 个元素，要满足除末位1外每一个二进制位不全为 1 ，且每个元素至少有 1 个“特殊位0” 。<br>对于每个 $k$ ，枚举特殊位个数 $j:k\rightarrow m-1$ :</p><ul><li>末位为1但没有特殊位的元素，每个 非“特殊位0” 二进制位（按列看）上的方案数为 $2^{k}-1-k$ （除：全1的1种和“特殊位0”k种），除末位外有 $m-1-j$ 个 非“特殊位0” 二进制位，（有序）方案数为 $t=(2^{k}-1)^{m-1}$ 。</li><li>特殊位：方案数 $dp(k,j)$</li></ul><p>综上，这 $k$ 个末位为1的元素的（有序）方案数为 $a = \sum\limits_{j=k}^{m-1} t\times dp(k,j)\times C(m-1,j)$</p><p>对于剩余的 $n-k$ 个元素，只需要保证末位为 0 ，其他位不加限制，因此这 $n-k$ 个数每个二进制位（按列看）上的方案数为 $2^{n-k}$ （即除全1外）。<br>除末位外有 $m-1$ 个二进制位，（有序）方案数为 $b=(2^{n-k})^{m-1}$ 。</p><p>综合两部分，方案数为 $a\times b\times C_n^k$ 。</p><p>用A题的答案减去得到的数字，则为本题所求的答案。</p><p>本题复杂度较高，常规的取模操作做的多的，可能会因为常数太大TLE。<br>可以通过预处理乘方数组、逐步求乘方数、减少取模次数、优化取模等方法解决。</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m &gt;&gt; MODULE::MOD;</span><br><span class="line">    <span class="built_in">Prepare_Combination</span>(<span class="number">5005</span>);</span><br><span class="line">    vector&lt;ll&gt; pow2;</span><br><span class="line">    pow2.<span class="built_in">emplace_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n*m) pow2.<span class="built_in">emplace_back</span>(<span class="built_in">mul</span>(pow2.<span class="built_in">back</span>(),<span class="number">2</span>));</span><br><span class="line">    ll t,tt,powt,a,b,ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        a = pow2[<span class="built_in">mul</span>(m<span class="number">-1</span>,n-i)]; <span class="comment">// a = 2^(m-1)^(n-i)</span></span><br><span class="line">        b = <span class="built_in">qcpow</span>(pow2[i]<span class="number">-1</span>,m<span class="number">-1</span>); <span class="comment">// b = (2^i-1)^(m-1)</span></span><br><span class="line">        t = <span class="built_in">mul</span>(C[n][i],<span class="built_in">mul</span>(a,b)); <span class="comment">// t = C(n,i)*a*b</span></span><br><span class="line">        <span class="built_in">addto</span>(ans1,t);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;ll&gt;(m+<span class="number">1</span>,<span class="number">0</span>)); <span class="comment">//dp_i,j表示j个特殊位覆盖了i个数的方案数</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,m<span class="number">-1</span>)&#123; </span><br><span class="line">            dp[i][j] = <span class="built_in">mul</span>(<span class="built_in">add</span>(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]),i); <span class="comment">// i*(dp[i][j-1]+dp[i-1][j-1])</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(k,<span class="number">2</span>,n)&#123; <span class="comment">// 末位为1的数的个数</span></span><br><span class="line">        t = <span class="built_in">sub</span>(pow2[k],k+<span class="number">1</span>); <span class="comment">// 2^k-k-1</span></span><br><span class="line">        powt = <span class="number">1</span>;</span><br><span class="line">        a = pow2[<span class="built_in">mul</span>(n-k,m<span class="number">-1</span>)]; <span class="comment">// a = 2^(m-1)^(n-k)</span></span><br><span class="line">        b = <span class="number">0</span>; </span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,m<span class="number">-1</span>,k)&#123; <span class="comment">// k个元素有j个特殊位</span></span><br><span class="line">            tt = <span class="built_in">mul</span>(powt,dp[k][j]); <span class="comment">// t^(m-1-j)*dp[k][j]</span></span><br><span class="line">            tt = <span class="built_in">mul</span>(tt,C[m<span class="number">-1</span>][j]); <span class="comment">// C(m-1,j)*t^(m-1-j)*dp[k][j]</span></span><br><span class="line">            <span class="built_in">addto</span>(b,tt); </span><br><span class="line">            powt = <span class="built_in">mul</span>(powt,t); <span class="comment">// t^(m-1-j)</span></span><br><span class="line">        &#125;</span><br><span class="line">        tt = <span class="built_in">mul</span>(C[n][k],<span class="built_in">mul</span>(a,b)); <span class="comment">// C(n,k)*a*b</span></span><br><span class="line">        <span class="built_in">addto</span>(ans2,tt); </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sub</span>(ans1,ans2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C.Sum of Suffix Sums</h1><h2 id="题意-3">题意</h2><p>给定一个初始为空的数组，你需要进行 <code>q</code> 次操作：</p><ul><li>对于每次操作，给定两个非负整数 <code>t</code> 和 <code>v</code>，先从数组末尾取出 <code>t</code> 个元素，然后将 <code>v</code> 添加到数组末尾。保证 <code>t</code> 不会超过操作前数组的长度。</li></ul><p>每次操作后，假设当前数组为 <code>a1, a2, ..., an</code>，计算 <code>s1, s2, ..., sn</code> 的总和，其中 <code>si = ai + ai+1 + ... + an</code> 是从位置 <code>i</code> 开始的后缀和。</p><p>由于结果可能非常大，输出时需对 <code>1000000007</code> 取模。</p><h2 id="解题思路-3">解题思路</h2><p>考虑每个元素的贡献：第 $i$ 个元素对答案的贡献为 $i*a_i$ 。</p><p>在加入元素时，直接将其贡献加入答案。</p><p>同时对这个序列维护一个前缀和，以便快速移除元素和减去贡献。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> ll N = <span class="number">200005</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll q,t,rm;cin &gt;&gt; q;</span><br><span class="line">    ll n=<span class="number">1</span>;</span><br><span class="line">    vector&lt;ll&gt; v,s;</span><br><span class="line">    v.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">    s.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">    ll tm;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        cin &gt;&gt; rm &gt;&gt; t;</span><br><span class="line">        sum = <span class="built_in">Get_Mod</span>(sum-<span class="built_in">Get_Mod</span>(s[n<span class="number">-1</span>]-s[n-rm<span class="number">-1</span>]));</span><br><span class="line">        s.<span class="built_in">erase</span>(s.<span class="built_in">end</span>()-rm,s.<span class="built_in">end</span>());</span><br><span class="line">        v.<span class="built_in">erase</span>(v.<span class="built_in">end</span>()-rm,v.<span class="built_in">end</span>());</span><br><span class="line">        n-=rm;</span><br><span class="line"></span><br><span class="line">        tm = t;</span><br><span class="line">        tm = <span class="built_in">Get_Mod</span>(tm*n); <span class="comment">// 元素贡献</span></span><br><span class="line">        sum = <span class="built_in">Get_Mod</span>(sum+tm);</span><br><span class="line">        v.<span class="built_in">emplace_back</span>(tm);</span><br><span class="line">        s.<span class="built_in">emplace_back</span>(sum);</span><br><span class="line">        n++;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>H.World Finals</h1><h2 id="题意-4">题意</h2><p>两场ICPC比赛，已知（预测的）两场比赛的所有队伍的解题数和罚时。</p><p>如果一支队伍同时具有两场比赛的资格，只能参加其中一场。</p><p>现在，<code>lzr010506</code>可以决定 同时具有两场比赛的资格 的队伍具体参加哪一场，根据预测数据求<code>lzr010506</code>可以得到的最高名次。</p><h2 id="解题思路-4">解题思路</h2><p>开2个map分别记录两场比赛情况。</p><p>假设<code>lzr010506</code>参加其中一场，去掉那一场所有的 同时具有两场比赛的资格 的队伍，排序即可得到这一场的最佳名次。</p><p>如此求出两场比赛的最佳名次，取最小值即可。</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> ll N = <span class="number">200005</span>;</span><br><span class="line">string me=<span class="string">&quot;lzr010506&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> pair&lt;string,pll&gt; &amp;a,<span class="type">const</span> pair&lt;string,pll&gt; &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pll pa,pb;</span><br><span class="line">    pa=a.second; pb=b.second;</span><br><span class="line">    <span class="keyword">if</span>(pa.first==pb.first) <span class="keyword">return</span> pa.second&lt;pb.second;</span><br><span class="line">    <span class="keyword">return</span> pa.first&gt;pb.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;string,pll&gt; v1,v2;</span><br><span class="line">    ll n,m;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string ts; ll t1,t2;</span><br><span class="line">    ll ans1,ans2;ans1=ans2=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; ts &gt;&gt; t1 &gt;&gt; t2;</span><br><span class="line">        v1[ts]=<span class="built_in">make_pair</span>(t1,t2);</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; ts &gt;&gt; t1 &gt;&gt; t2;</span><br><span class="line">        v2[ts]=<span class="built_in">make_pair</span>(t1,t2);</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;string,pll&gt; tmp;</span><br><span class="line">    tmp = v1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:v2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp.<span class="built_in">count</span>(x.first)&amp;&amp;x.first!=me)&#123;</span><br><span class="line">            tmp.<span class="built_in">erase</span>(x.first);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> tv = vector&lt;pair&lt;string,pll&gt;&gt;(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">ALL</span>(tv),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:tv)&#123;</span><br><span class="line">        ans1++;</span><br><span class="line">        <span class="keyword">if</span>(x.first==me) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = v2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:v1)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp.<span class="built_in">count</span>(x.first)&amp;&amp;x.first!=me)&#123;</span><br><span class="line">            tmp.<span class="built_in">erase</span>(x.first);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tv = vector&lt;pair&lt;string,pll&gt;&gt;(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">ALL</span>(tv),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:tv)&#123;</span><br><span class="line">        ans2++;</span><br><span class="line">        <span class="keyword">if</span>(x.first==me) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(ans1,ans2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>I.Mirror Maze</h1><p><strong>DFS</strong></p><h2 id="题意-5">题意</h2><p>在一个 $n \times m$ 的镜子迷宫中，每个格子都有一面镜子。镜子的类型有以下四种：</p><ol><li><code>-</code>：来自上方或下方的光线将被反射回去，来自左方或右方的光线则继续前进而不会被反射。</li><li><code>|</code>：来自左方或右方的光线将被反射回去，来自上方或下方的光线则继续前进而不会被反射。</li><li><code>/</code>：来自左方、右方、上方、下方的光线将分别被反射到上方、下方、左方、右方。</li><li><code>\</code>：来自左方、右方、上方、下方的光线将分别被反射到下方、上方、右方、左方。</li></ol><p>现在有 $q$ 个光源（给定位置和方向）。光的信徒小G想知道，对于每个光源，在足够长的时间内，发出的光线会被反射经过的不同镜子的数量。</p><h2 id="解题思路-5">解题思路</h2><p>对于一个光源，如果它的传播路径没有首尾相连成环，那么这个路径就只可能是一条链。<br>（证明：光的路径是可逆的，假设一条传播路径在某一点突然形成了环，那回溯时在这个点就可以有两条路径，这显然是不合理的）</p><p>对于给定的镜子阵列，我们可以直接处理出每个点向每个方向的答案，对最后的询问打表。</p><p>只要是一条链，它的最初起点和最后终点一定在阵列的边缘位置。我们可以从边缘位置开始向内DFS，直到遇到边缘位置，这样就可以得到一条链的路径，路径上的答案都可以处理得到。</p><p>没有遍历到的点，说明它们是环的一部分，我们可以通过时间戳来寻找和处理环上的答案。</p><h2 id="参考程序-5">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//                D  U  R  L</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c0[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// -</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c1[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>&#125;; <span class="comment">// |</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c2[] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;; <span class="comment">// /</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c3[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>&#125;; <span class="comment">// \&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">conv</span><span class="params">(<span class="type">int</span> d, <span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> c0[d];</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>: <span class="keyword">return</span> c1[d];</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">return</span> c2[d];</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>: <span class="keyword">return</span> c3[d];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,q,tms,cnt; <span class="comment">//tms:timestamp</span></span><br><span class="line">vector&lt;string&gt; mp;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vis;</span><br><span class="line">vector&lt;vector&lt;array&lt;<span class="type">int</span>,4&gt;&gt;&gt; ans,visd;</span><br><span class="line">vector&lt;tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;&gt; buf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_line</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> dir)</span></span>&#123;</span><br><span class="line">    buf.<span class="built_in">push_back</span>(&#123;x,y,dir&#125;);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;=n||y&lt;<span class="number">0</span>||y&gt;=m) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> nd=<span class="built_in">conv</span>(dir,mp[x][y]); <span class="comment">//new direction</span></span><br><span class="line">    <span class="built_in">dfs_line</span>(x+dx[nd],y+dy[nd],nd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f_line</span><span class="params">(<span class="type">int</span> sx,<span class="type">int</span> sy,<span class="type">int</span> sd)</span></span>&#123;</span><br><span class="line">    buf.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">dfs_line</span>(sx,sy,sd);</span><br><span class="line">    <span class="built_in">reverse</span>(buf.<span class="built_in">begin</span>(),buf.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>; tms++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;buf.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123; <span class="comment">//回溯</span></span><br><span class="line">        <span class="keyword">auto</span> [x,y,d]=buf[i];</span><br><span class="line">        <span class="keyword">if</span>(i)&#123;</span><br><span class="line">            <span class="type">int</span> fl=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(mp[x][y]==<span class="string">&#x27;-&#x27;</span>&amp;&amp;(d&amp;<span class="number">2</span>)||mp[x][y]==<span class="string">&#x27;|&#x27;</span>&amp;&amp;!(d&amp;<span class="number">2</span>)) fl=<span class="number">0</span>; <span class="comment">// 通过</span></span><br><span class="line">            <span class="keyword">if</span>(fl)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[x][y]!=tms) res+=fl; <span class="comment">// 反射</span></span><br><span class="line">                vis[x][y]=tms;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visd[x+dx[d^<span class="number">1</span>]][y+dy[d^<span class="number">1</span>]][d]=tms;</span><br><span class="line">        ans [x+dx[d^<span class="number">1</span>]][y+dy[d^<span class="number">1</span>]][d]=res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_loop</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> dir)</span></span>&#123;</span><br><span class="line">    visd[x][y][dir]=tms;</span><br><span class="line">    x += dx[dir];</span><br><span class="line">    y += dy[dir];</span><br><span class="line">    <span class="type">int</span> nd = <span class="built_in">conv</span>(dir,mp[x][y]);</span><br><span class="line">    <span class="keyword">if</span>(nd!=dir)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[x][y]!=tms) cnt++;</span><br><span class="line">        vis[x][y]=tms;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(visd[x][y][nd]!=tms) <span class="built_in">dfs_loop</span>(x,y,nd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mk_loop</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> dir)</span></span>&#123;</span><br><span class="line">    ans[x][y][dir] = cnt;</span><br><span class="line">    visd[x][y][dir] = tms;</span><br><span class="line">    x+=dx[dir];</span><br><span class="line">    y+=dy[dir];</span><br><span class="line">    <span class="type">int</span> nd=<span class="built_in">conv</span>(dir,mp[x][y]);</span><br><span class="line">    <span class="keyword">if</span>(visd[x][y][nd]!=tms) <span class="built_in">mk_loop</span>(x,y,nd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f_loop</span><span class="params">(<span class="type">int</span> sx,<span class="type">int</span> sy,<span class="type">int</span> sd)</span></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>; tms++;</span><br><span class="line">    <span class="built_in">dfs_loop</span>(sx,sy,sd);</span><br><span class="line">    tms++;</span><br><span class="line">    <span class="built_in">mk_loop</span>(sx,sy,sd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    mp.<span class="built_in">clear</span>();</span><br><span class="line">    mp.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s:mp) cin &gt;&gt; s;</span><br><span class="line">    ans.<span class="built_in">resize</span>(n,vector&lt;array&lt;<span class="type">int</span>,<span class="number">4</span>&gt;&gt;(m,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;));</span><br><span class="line">    visd.<span class="built_in">resize</span>(n,vector&lt;array&lt;<span class="type">int</span>,<span class="number">4</span>&gt;&gt;(m,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;));</span><br><span class="line">    vis.<span class="built_in">resize</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">f_line</span>(i,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">f_line</span>(i,m<span class="number">-1</span>,<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="built_in">f_line</span>(<span class="number">0</span>,i,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">f_line</span>(n<span class="number">-1</span>,i,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">0</span>;d&lt;<span class="number">4</span>;d++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(visd[i][j][d]==<span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">f_loop</span>(i,j,d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,d;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; s;</span><br><span class="line">        x--,y--;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;b&#x27;</span>) d=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;a&#x27;</span>) d=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;r&#x27;</span>) d=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;l&#x27;</span>) d=<span class="number">3</span>;</span><br><span class="line">        cout &lt;&lt; ans[x][y][d] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目文档|基于科大讯飞星火大模型的Nonebot2插件</title>
      <link href="/posts/Project_nonebot_plugin_sparkapi.html"/>
      <url>/posts/Project_nonebot_plugin_sparkapi.html</url>
      
        <content type="html"><![CDATA[<div align="center">  <a href="https://v2.nonebot.dev/store"><img src="https://source.cclmsy.cc/Images/nbp_Sparkapi/nbp_logo.png" width="180" height="180" alt="NoneBotPluginLogo"></a>  <br>  <p><img src="https://source.cclmsy.cc/Images/nbp_Sparkapi/NoneBotPlugin.svg" width="240" alt="NoneBotPluginText"></p></div><div align="center"><h1>nonebot-plugin-sparkapi</h1><p><em>✨ 科大讯飞星火大模型官方 API 聊天机器人 ✨</em></p><a href="./LICENSE">    <img src="https://img.shields.io/github/license/CCLMSY/nonebot-plugin-sparkapi.svg" alt="license"></a><a href="https://pypi.python.org/pypi/nonebot-plugin-sparkapi">    <img src="https://img.shields.io/pypi/v/nonebot-plugin-sparkapi.svg" alt="pypi"></a><img src="https://img.shields.io/badge/python-3.10+-blue.svg" alt="python"></div><h2 id="📖-介绍">📖 介绍</h2><p>基于 Nonebot2 平台/科大讯飞星火大模型官方 API 的 AI 聊天机器人插件</p><p>适用于所有模型版本（默认当前最新 <code>v4.0</code>），同时支持自定义人物预设、会话管理，兼具 AI 绘图、AI 生成 PPT 等功能</p><p>开发环境：<code>Python3.11.8 on Conda, Windows 11</code></p><blockquote><p>[!important]</p><p>为了方便的直接阅读存储的文件，<code>v2.0.5</code> 版本起，信息编码方式更改为 <code>UTF-8</code>。从旧版本更新到 <code>v2.0.5</code> 以上版本时，请务必删除 BOT 项目文件夹下的<code>SparkApi</code>文件夹，即清除所有缓存文件，否则可能产生错误。由此带来不便敬请谅解！QwQ</p><p>项目正在准备重写更新到3.x，期望集成绝大部分星火大模型的能力</p></blockquote><h3 id="📦-项目地址">📦 项目地址</h3><ul><li>Github: <a href="https://github.com/CCLMSY/nonebot-plugin-sparkapi">https://github.com/CCLMSY/nonebot-plugin-sparkapi</a></li><li>Pypi: <a href="https://pypi.org/project/nonebot-plugin-sparkapi/">https://pypi.org/project/nonebot-plugin-sparkapi/</a></li><li>NoneBot: <a href="https://registry.nonebot.dev/plugin/nonebot-plugin-sparkapi:nonebot_plugin_sparkapi">https://registry.nonebot.dev/plugin/nonebot-plugin-sparkapi:nonebot_plugin_sparkapi</a></li><li>作者主页: <a href="https://cclmsy.cc">https://cclmsy.cc</a></li><li>觉得好用的话，请给个 Star⭐️ 谢谢喵~</li></ul><h3 id="💬-功能">💬 功能</h3><ul><li>[x] 支持 AI 对话（已适配星火 4.0API）</li><li>[x] 支持上下文关联</li><li>[x] 支持自定义预设、预设管理</li><li>[x] 支持会话存储和加载、会话管理</li><li>[x] 支持预设和历史记录持久化（基于 json）</li><li>[x] 完善配置项（有其他需求请发 issue）</li><li>[x] 支持 AI 绘图（Image Generation）</li><li>[x] 支持 AI 生成 PPT（PPT Generation）</li><li>[ ] 文档问答（Document QA）</li><li>[ ] 用户权限与功能区分（超级用户、普通用户）</li></ul><h2 id="💿-安装">💿 安装</h2><details open><summary>使用 nb-cli 安装</summary>在 nonebot2 项目的根目录下打开命令行, 输入以下指令即可安装<pre><code>nb plugin install nonebot-plugin-sparkapi</code></pre></details><details><summary>使用包管理器安装</summary>在 nonebot2 项目的插件目录下, 打开命令行, 根据你使用的包管理器, 输入相应的安装命令<details><summary>pip</summary><pre><code>pip install nonebot-plugin-sparkapi</code></pre></details><details><summary>pdm</summary><pre><code>pdm add nonebot-plugin-sparkapi</code></pre></details><details><summary>poetry</summary><pre><code>poetry add nonebot-plugin-sparkapi</code></pre></details><details><summary>conda</summary><pre><code>conda install nonebot-plugin-sparkapi</code></pre></details><p>打开 nonebot2 项目根目录下的 <code>pyproject.toml</code> 文件, 在 <code>[tool.nonebot]</code> 部分追加写入</p><pre><code>plugins = [&quot;nonebot_plugin_sparkapi&quot;]</code></pre></details><h2 id="⚙️-配置项">⚙️ 配置项</h2><p>在 nonebot2 项目的<code>.env</code>文件中添加下列配置项中的必填配置（SPARKAPI_APP_ID, SPARKAPI_API_SECRET, SPARKAPI_API_KEY）</p><p>服务接口认证信息 app_id, api_secret, api_key 请前往 <a href="https://console.xfyun.cn/">讯飞开放平台控制台</a> 获取</p><p>AI 绘图、AI 生成 PPT 功能的 API 信息在同一应用下与对话 API 信息相同，开启相应功能前需要在讯飞开放平台申请相应的服务用量</p><table><thead><tr><th style="text-align:center">配置项</th><th style="text-align:center">必填</th><th style="text-align:center">默认值</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">SPARKAPI_APP_ID</td><td style="text-align:center">是</td><td style="text-align:center">/</td><td style="text-align:center">APPID</td></tr><tr><td style="text-align:center">SPARKAPI_API_SECRET</td><td style="text-align:center">是</td><td style="text-align:center">/</td><td style="text-align:center">APISecret</td></tr><tr><td style="text-align:center">SPARKAPI_API_KEY</td><td style="text-align:center">是</td><td style="text-align:center">/</td><td style="text-align:center">APIKey</td></tr><tr><td style="text-align:center">SPARKAPI_MODEL_VERSION</td><td style="text-align:center">否</td><td style="text-align:center"><code>&quot;&quot;</code></td><td style="text-align:center">星火大模型的版本，默认为当前最新。<br>可选值：“default”, “v4.0”, “v3.5”, “v3.0”, “v2.0”, “v1.5”</td></tr><tr><td style="text-align:center">SPARKAPI_MODEL_TOP_K</td><td style="text-align:center">否</td><td style="text-align:center"><code>4</code></td><td style="text-align:center">平衡生成文本的质量和多样性。<br>较小的 k 值会减少随机性，使得输出更加稳定；<br>而较大的 k 值会增加随机性，产生更多新颖的输出。<br>取值范围[1, 6]</td></tr><tr><td style="text-align:center">SPARKAPI_MODEL_TEMPERATURE</td><td style="text-align:center">否</td><td style="text-align:center"><code>0.5</code></td><td style="text-align:center">控制结果随机性，取值越高随机性越强，即相同的问题得到的不同答案的可能性越高。<br>取值范围 (0，1]</td></tr><tr><td style="text-align:center">SPARKAPI_MODEL_MAXLENGTH</td><td style="text-align:center">否</td><td style="text-align:center"><code>8000</code></td><td style="text-align:center">单次上下文最大 token 长度，v2.0 以上建议取值范围：[4000,8000]。<br>详细说明见下文</td></tr><tr><td style="text-align:center">SPARKAPI_PRIORITY</td><td style="text-align:center">否</td><td style="text-align:center"><code>80</code></td><td style="text-align:center">本插件响应事件的优先级，建议设置较大的值。可选值：1~97。<br>详细说明见下文</td></tr><tr><td style="text-align:center">SPARKAPI_COMMAND_CHAT</td><td style="text-align:center">否</td><td style="text-align:center"><code>&quot;&quot;</code></td><td style="text-align:center">机器人对话指令，默认为&quot;&quot;可直接对话</td></tr><tr><td style="text-align:center">SPARKAPI_FL_NOTICE</td><td style="text-align:center">否</td><td style="text-align:center"><code>True</code></td><td style="text-align:center">收到对话请求时是否提示“已收到请求”</td></tr><tr><td style="text-align:center">SPARKAPI_FL_PRIVATE_CHAT</td><td style="text-align:center">否</td><td style="text-align:center"><code>True</code></td><td style="text-align:center">是否允许私聊使用</td></tr><tr><td style="text-align:center">SPARKAPI_FL_GROUP_PUBLIC</td><td style="text-align:center">否</td><td style="text-align:center"><code>False</code></td><td style="text-align:center">群聊启用公共会话<br>True：所有人共享同一会话<br>False：每个人的会话各自独立</td></tr><tr><td style="text-align:center">SPARKAPI_FL_INTERFLOW</td><td style="text-align:center">否</td><td style="text-align:center"><code>False</code></td><td style="text-align:center">对于同一用户，群聊与私聊数据互通（公共会话启用时，群聊仍独立）</td></tr><tr><td style="text-align:center">SPARKAPI_FL_GROUP_AT</td><td style="text-align:center">否</td><td style="text-align:center"><code>True</code></td><td style="text-align:center">群聊回复消息时是否需要@提问者</td></tr><tr><td style="text-align:center">SPARKAPI_FL_IMGGEN</td><td style="text-align:center">否</td><td style="text-align:center"><code>False</code></td><td style="text-align:center">是否启用 AI 绘图功能</td></tr><tr><td style="text-align:center">SPARKAPI_FL_PPTGEN</td><td style="text-align:center">否</td><td style="text-align:center"><code>False</code></td><td style="text-align:center">是否启用 AI 生成 PPT 功能</td></tr><tr><td style="text-align:center">SPARKAPI_IG_SIZE</td><td style="text-align:center">否</td><td style="text-align:center"><code>[1280,720]</code></td><td style="text-align:center">AI 绘图的图片尺寸，[宽,高]。<br>可选值和 API 消耗见下文</td></tr><tr><td style="text-align:center">SPARKAPI_BOT_NAME</td><td style="text-align:center">否</td><td style="text-align:center"><code>&quot;&quot;</code></td><td style="text-align:center">机器人的名字</td></tr></tbody></table><h3 id="SPARKAPI-MODEL-MAXKLENGTH">SPARKAPI_MODEL_MAXKLENGTH</h3><ul><li>单次上下文最大 token 长度</li><li>该值越大，对话历史记录保留越长，单次请求消耗 token 的最大值越大</li><li>1token≈1.5 个中文字 ≈1 个英文单词。保守起见，在本插件中 1token 取 1.25 个字符</li><li>v1.5 建议取值：4000（API 限制不能超过 4000token）</li><li>v2.0 以上建议取值范围：[4000,8000]（API 限制不能超过 8000token）</li><li>QQ 单条消息上限 4500 个字符（计 3600token），消息超过最大长度可能导致响应不正确</li></ul><h3 id="SPARKAPI-PRIORITY">SPARKAPI_PRIORITY</h3><ul><li>响应事件的优先级，该值越小，事件越先被本插件响应。可选值：1~97</li><li>本插件中事件的优先级顺序：私聊阻断（=priority）&lt; 功能（=priority+1）&lt; 对话（=priority+2）</li><li>若触发本插件事件，所有插件中优先级大于此值的事件都将被阻断，因此本插件建议设置较大的值。</li></ul><h3 id="SPARKAPI-IG-SIZE">SPARKAPI_IG_SIZE</h3><table><thead><tr><th style="text-align:center">分辨率（可选值）</th><th style="text-align:center">消耗图点数</th></tr></thead><tbody><tr><td style="text-align:center">[512,512]</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">[640,360]</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">[640,480]</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">[640,640]</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center">[680,512]</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center">[512,680]</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center">[768,768]</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">[720,1280]</td><td style="text-align:center">12</td></tr><tr><td style="text-align:center">[1280,720]</td><td style="text-align:center">12</td></tr><tr><td style="text-align:center">[1024,1024]</td><td style="text-align:center">14</td></tr></tbody></table><h3 id="命令相关：sparkapi-commands、sparkapi-commands-info">命令相关：sparkapi_commands、sparkapi_commands_info</h3><ul><li><p>如有需要，以下命令相关配置项请在<code>./.venv/Lib/nonebot_plugin_sparkapi/config.py</code>修改：</p><ol><li>sparkapi_commands：指令表</li><li>sparkapi_commands_info：指令表说明（用于生成帮助信息）</li></ol></li><li><p>在<code>config.py</code>文件中，已经用缩进表示了命令之间的从属关系。一级命令为主命令，二级命令为子命令。</p></li><li><p>命令格式由 NoneBot 机器人项目下的配置文件<code>.env</code>中的<code>COMMAND_START</code>和<code>COMMAND_SEP</code>决定（请参考 NoneBot 文档）。默认情况下，<code>COMMAND_START</code>为<code>[&quot;/&quot;]</code>，<code>COMMAND_SEP</code>为<code>[&quot;.&quot;]</code>。</p></li><li><p>一级命令帮助信息会出现在<code>help</code>中，二级命令帮助信息在单独使用一级命令时出现。</p></li><li><p>以二级命令<code>preset_create</code>为例，默认配置下：</p><ul><li>预设管理命令<code>preset</code>、二级命令<code>create</code>。</li><li>完整命令格式为<code>/preset.create</code>。</li><li>这个命令不会出现在<code>/help</code>的帮助信息中，但会在发送<code>/preset</code>时告知用户命令和用法。</li></ul></li></ul><h2 id="🎉-使用">🎉 使用</h2><h3 id="指令表（默认）">指令表（默认）</h3><p>以下所有指令均可在 <a href="http://config.py">config.py</a> 中修改，且无需重写菜单/指令生成函数</p><table><thead><tr><th style="text-align:center">指令（默认配置下）</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">直接发送对话内容<br>SPARKAPI_COMMAND_CHAT（若不为空）+对话内容</td><td style="text-align:center">与机器人进行对话</td></tr><tr><td style="text-align:center">/help</td><td style="text-align:center">显示帮助信息</td></tr><tr><td style="text-align:center">/preset</td><td style="text-align:center">显示人物预设菜单和预设相关命令项</td></tr><tr><td style="text-align:center">/preset.create</td><td style="text-align:center">创建自定义人物预设</td></tr><tr><td style="text-align:center">/preset.set</td><td style="text-align:center">选择人物预设并切换</td></tr><tr><td style="text-align:center">/preset.show</td><td style="text-align:center">显示自定义人物预设详情</td></tr><tr><td style="text-align:center">/preset.delete</td><td style="text-align:center">删除自定义人物预设</td></tr><tr><td style="text-align:center">/session</td><td style="text-align:center">显示保存的对话记录和会话管理相关命令项</td></tr><tr><td style="text-align:center">/session.save</td><td style="text-align:center">保存当前对话上下文</td></tr><tr><td style="text-align:center">/session.load</td><td style="text-align:center">加载保存的对话上下文</td></tr><tr><td style="text-align:center">/session.show</td><td style="text-align:center">显示保存的对话记录</td></tr><tr><td style="text-align:center">/session.delete</td><td style="text-align:center">删除保存的对话记录</td></tr><tr><td style="text-align:center">/clear</td><td style="text-align:center">清除当前对话上下文</td></tr><tr><td style="text-align:center">/image</td><td style="text-align:center">AI 绘图</td></tr><tr><td style="text-align:center">/ppt</td><td style="text-align:center">AI 生成 PPT</td></tr></tbody></table><h3 id="自带人物预设">自带人物预设</h3><ol><li>智能助手（默认）</li><li>李白</li></ol><h3 id="效果图">效果图</h3><details> <summary>效果图</summary><p><img src="https://source.cclmsy.cc/Images/nbp_Sparkapi/demo.png" alt="Demo"><br><a href="https://source.cclmsy.cc/Images/nbp_Sparkapi/%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E%E6%98%9F%E7%81%AB%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E9%A1%B9%E7%9B%AE%E6%B1%87%E6%8A%A5.pptx">DemoPPT: 科大讯飞星火语言模型项目汇报.pptx</a></p></details><h2 id="📝-更新日志">📝 更新日志</h2><ul><li>2024.8.21 v2.0.8<ul><li>感谢开发者<a href="https://github.com/wyf7685">wyf7685</a>为本项目整体重写，提供优化功能实现、多平台适配等帮助！</li><li>修复了FL_IMGGEN和FL_PPTGEN配置项无效的问题</li><li>新增对 Spark Pro-128K 模型的支持</li></ul></li><li>2024.7.12 v2.0.5<ul><li>信息存储改为 UTF-8 编码</li></ul></li><li>2024.7.11 v2.0.2<ul><li>尝试通过不验证 SSL 证书规避 SSL 证书验证问题</li></ul></li><li>2024.7.10 v2.0.0<ul><li>项目重写</li><li>支持会话存储和加载、会话管理</li><li>支持预设和历史记录持久化（基于 json）</li><li>优化命令、功能的实现方式</li><li>调整了配置项和指令表</li></ul></li><li>2024.6.30 v1.5.0<ul><li>适配星火 4.0API</li></ul></li><li>2024.6.25 v1.4.5<ul><li><s>使用默认的 SSL 证书</s></li></ul></li><li>2024.6.9 v1.4.4<ul><li>优化项目结构</li><li>优化部分功能的实现方式</li></ul></li><li>2024.5.30 v1.4.1<ul><li>新增 AI 生成 PPT 功能</li></ul></li><li>2024.5.29 v1.4.0<ul><li>项目重构</li><li>新增 AI 绘图功能</li></ul></li><li>2024.5.17 v1.2.0<ul><li>简化了初始命令</li><li>模块结构优化</li></ul></li><li>2024.5.16 v1.1.0<ul><li><s>存储和加载单次会话（基于 pickle）</s></li><li>改用异步方式请求 API</li></ul></li><li>2024.5.15 v1.0.0<ul><li>支持 AI 对话</li><li>支持上下文关联</li><li>支持自定义预设、预设管理</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 机器人 </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数字图像处理》笔记</title>
      <link href="/posts/Note_Image_Processing.html"/>
      <url>/posts/Note_Image_Processing.html</url>
      
        <content type="html"><![CDATA[<h1>二、数字图像处理基础</h1><h2 id="2-1-数字图像采集">2.1.数字图像采集</h2><ol><li>当前普遍采用的图像传感器：CCD、CMOS<ul><li>共同点：利用感光二极管进行光电转换，获取图像并转换为数字数据</li></ul></li><li>采样：空间坐标离散化<ul><li>均匀采样：等间隔划分成$N$行$M$列的网格</li></ul></li><li>量化：灰度值离散化<ul><li>均匀量化：将灰度值划分为$L$（通常为$2^k$）个等间隔的区间</li><li>通常取$k=8,L=256$，灰度从小到大，像素从暗到亮</li></ul></li></ol><h2 id="2-2-数字图像表示">2.2.数字图像表示</h2><ol><li>通常采用$N\times M$大小的矩阵表示具有$N$行$M$列的数字图像</li><li>左上角坐标为$(0,0)$，每个坐标的函数值$f(x,y)$表示该点的灰度值</li><li>像素：每个坐标表示的单元格</li></ol><h2 id="2-3-分辨率与图像存储">2.3.分辨率与图像存储</h2><ol><li>空间分辨率：一般指数字图像的阵列大小$N\times M$</li><li>灰度分辨率：指数字图像的灰度级别$L$（通常为$2^k$）<ul><li>灰度：图像中每个像素的亮度值，通常用0-255表示。灰度级别越多，图像越清晰。</li></ul></li><li>图像存储：长×宽×位数×通道数/8<ul><li>一幅空间分辨率为$N\times M$，灰度分辨率为$2^k$的RGB数字图像，需要$N\times M\times k\times 3 / 8 B$存储（$1B=8bit$）</li></ul></li></ol><h2 id="2-4-像素间关系">2.4.像素间关系</h2><ol><li>相邻与邻域（以$p(x,y)$为例）<ul><li>4邻域：上下左右四个像素，记为$N_4§$</li><li>对角邻域：上左、上右、下左、下右四个像素，记为$N_D§$</li><li>8邻域：九宫格，记为$N_8§$</li></ul></li><li>像素的邻接性<ul><li>4邻接：$p$与$N_4§$中的像素相邻</li><li>8邻接：$p$与$N_8§$中的像素相邻</li><li>m邻接（混合邻接）：先进行4邻接，若存在四宫格中仅对角存在像素，则对角连接</li></ul></li><li>像素的连通性<ul><li>按照对应邻接性连接像素，形成连通块</li></ul></li><li>像素的距离<ul><li>欧几里得距离（欧氏距离，范数2）：$d(p_1,p_2)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$</li><li>曼哈顿距离（街区距离，范数1）：$d(p_1,p_2)=|x_1-x_2|+|y_1-y_2|$</li><li>棋盘距离（范数$\infty$）：$d(p_1,p_2)=\max(|x_1-x_2|,|y_1-y_2|)$</li><li>$D_m$距离：m邻接后，$p_1$到$p_2$的最短路径长度</li></ul></li></ol><p><img src="https://source.cclmsy.cc/Images/Posts/IP/IP08.png" alt=""></p><h2 id="2-5-习题">2.5. 习题</h2><ol><li>数字图像处理的五个经典应用领域：媒体通信、宇宙探索、气象预报、侦缉破案、考古</li><li>二值图像：具有两种灰度值的图像，但不一定是0和1。黑白图像一定是二值图像，但二值图像不一定是黑白图像。</li><li>视觉适应性：人眼对突然的亮度变化需要时间适应，亮适应性的时间比暗适应性短得多。</li><li>马赫带效应：人眼对两个颜色之间的边界，亮度感知受影响。较暗的色块靠近边界的一侧看起来更暗。</li><li>为什么在某些图像处理中，需要对图像的灰度进行对数运算？<ul><li>大量实验表明人的视觉感知到的主观亮度与进入人眼的光强度成对数关系。如此处理可以达到更好的视觉效果。</li></ul></li></ol><h1>三、数字图像的基本运算</h1><h2 id="3-1-矩阵统计量">3.1.矩阵统计量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mean, stddev = cv2.meanStdDev(img) <span class="comment"># 均值、标准差</span></span><br><span class="line">minVal, maxVal, minLoc, maxLoc = cv2.minMaxLoc(img) <span class="comment"># 最小值、最大值、最小值位置、最大值位置</span></span><br><span class="line">coeff = stddev / mean <span class="comment"># 变异系数</span></span><br></pre></td></tr></table></figure><h2 id="3-2-灰度直方图">3.2.灰度直方图</h2><ul><li>$H§=[h(r_0),h(r_1),\cdots,h(r_{L-1})]$</li><li>$h(r_i)=n_i$</li><li>统计图像中每个灰度级别的像素个数</li><li>用于分析图像的对比度、亮度等信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hist = cv2.calcHist([img], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>]) <span class="comment"># 计算直方图</span></span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line"><span class="comment"># images: list[MatLike]  图像列表</span></span><br><span class="line"><span class="comment"># channels : list[int]  通道</span></span><br><span class="line"><span class="comment"># mask : MatLike 掩码，大小与输入图像相同，1表示统计，0表示不统计</span></span><br><span class="line"><span class="comment"># histSize : list[int] 直方图中bin的个数（柱的个数）</span></span><br><span class="line"><span class="comment"># ranges : list[int] 灰度值范围，通常为[0, 256]，表示0-255的灰度值范围</span></span><br><span class="line">hist = cv2.calcHist([img], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>//<span class="number">8</span>], [<span class="number">0</span>, <span class="number">256</span>]) <span class="comment"># 计算binwidth=8的直方图</span></span><br><span class="line">plt.hist(img.ravel(), <span class="number">256</span>//<span class="number">8</span>, [<span class="number">0</span>, <span class="number">256</span>]) <span class="comment"># 绘制直方图</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ul><li>对比度越小，直方图中像素分布越集中；对比度越大，直方图中像素分布越分散均匀<ul><li>对比度：最亮与最暗像素之间的差异，可以表示为最大灰度和最小灰度的比值</li></ul></li><li>亮度越低，直方图中像素分布越靠近左侧</li></ul><h3 id="灰度直方图的特征">灰度直方图的特征</h3><ol><li>所有函数值的总和是MN</li><li>只反映每种像素值出现的次数，不反映像素的空间分布</li><li>一幅图像的直方图是唯一的，但不同图像的直方图可以相同（由第二点决定）</li></ol><h3 id="归一化直方图">归一化直方图</h3><ul><li>$P(r_k)=\dfrac{h(r_k)}{MN}$</li><li>将直方图中的像素个数转换为频率</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hist = hist.ravel()/hist.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><h2 id="3-3-图像的几何运算">3.3.图像的几何运算</h2><p>修改像素之间的空间关系，由两种基本操作组成：</p><ol><li>空间变换：改变像素之间的空间关系</li><li>灰度级插值：确定空间变换后的像素灰度值</li></ol><h3 id="3-3-1-空间变换">3.3.1.空间变换</h3><h4 id="3-3-1-1-平移变换">3.3.1.1.平移变换</h4><p>$$<br>\begin{cases}<br>x_1=x_0+\Delta x\\<br>y_1=y_0+\Delta y<br>\end{cases}<br>$$</p><h4 id="3-3-1-2-旋转变换">3.3.1.2.旋转变换</h4><p>记旋转前（角坐标系）：</p><p>$$<br>\begin{cases}<br>x_0=r\cos\theta\\<br>y_0=r\sin\theta<br>\end{cases}<br>$$</p><p>顺时针旋转$\alpha$角度：</p><p>$$<br>\begin{cases}<br>x_1=r\cos(\theta-\alpha)\\<br>y_1=r\sin(\theta-\alpha)<br>\end{cases}\\<br>=\begin{cases}<br>x_1=r\cos\theta\cos\alpha+r\sin\theta\sin\alpha\\<br>y_1=r\sin\theta\cos\alpha-r\cos\theta\sin\alpha<br>\end{cases}\\<br>=\begin{cases}<br>x_1=x_0\cos\alpha+y_0\sin\alpha\\<br>y_1=-x_0\sin\alpha+y_0\cos\alpha<br>\end{cases}<br>$$</p><h4 id="3-3-1-3-镜像变换">3.3.1.3.镜像变换</h4><ol><li>水平镜像：$x_1=M-x_0,y_1=y_0$</li><li>垂直镜像：$x_1=x_0,y_1=N-y_0$</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_flip = cv2.flip(img, <span class="number">1</span>) <span class="comment"># 1水平镜像，0垂直镜像，-1水平+垂直镜像</span></span><br></pre></td></tr></table></figure><h4 id="3-3-1-4-缩放变换">3.3.1.4.缩放变换</h4><p>$$<br>\begin{cases}<br>x_1=kx_0 \\<br>y_1=ky_0<br>\end{cases}<br>$$</p><h4 id="3-3-1-5-转置变换">3.3.1.5.转置变换</h4><p>$$<br>\begin{cases}<br>x_1=y_0\\<br>y_1=x_0<br>\end{cases}<br>$$</p><h3 id="3-3-2-灰度级插值">3.3.2.灰度级插值</h3><h4 id="3-3-2-0-前向映射与反向映射">3.3.2.0.前向映射与反向映射</h4><ol><li>前向映射：原图像的一个像素映射到目标图像的多个像素（放大）</li><li>反向映射：原图像的多个像素映射到目标图像的一个像素（缩小）</li></ol><h4 id="3-3-2-1-最近邻插值-零阶内插">3.3.2.1.最近邻插值/零阶内插</h4><p>取前向映射变换所得位置，最近的的整数像素位置作为灰度值。<br>计算简单，容易产生锯齿。</p><h4 id="3-3-2-2-双线性插值">3.3.2.2.双线性插值</h4><p>记：原像素位置$(0,0),(0,1),(1,0),(1,1)$，反向映射变换所得位置$(x,y)$在它们中间。</p><p>根据像素相对四点的位置，求取算术平均值作为灰度值。</p><p>$$<br>f(x,0)=(1-x)f(0,0)+xf(1,0)\\<br>f(x,1)=(1-x)f(0,1)+xf(1,1)\\<br>f(x,y)=(1-y)f(x,0)+yf(x,1)<br>$$</p><h1>四、空间域图像增强</h1><p>图像增强技术可以分为两大类：空间域方法和频率域方法。<br>空间域方法以对图像的像素进行直接处理为基础，基于点运算的方法，在单个像素层面上进行。<br>统一表示：$g(x,y)=T[f(x,y)]$，其中算子T是一种点操作。</p><h2 id="4-1-基于点运算的图像增强方法">4.1.基于点运算的图像增强方法</h2><h3 id="4-1-1-对比度拉伸-分段线性变换">4.1.1.对比度拉伸/分段线性变换</h3><p>一种通过增强图像的对比度来改善图像质量的方法。</p><ul><li>一种典型处理：压缩最暗和最亮部分，拉伸中间部分。</li></ul><p><img src="https://source.cclmsy.cc/Images/Posts/IP/IP01.png" alt=""></p><ul><li>均匀变亮/均匀变暗：与原始灰度成线性关系。</li></ul><p><img src="https://source.cclmsy.cc/Images/Posts/IP/IP02.png" alt=""></p><h3 id="4-1-2-窗切片">4.1.2.窗切片</h3><p>一种强制某区间的灰度值为给定值的方法。</p><ul><li>区外灰度值不变</li></ul><p><img src="https://source.cclmsy.cc/Images/Posts/IP/IP03.png" alt=""></p><h3 id="4-1-3-修剪变换">4.1.3.修剪变换</h3><p>去除较暗和较亮部分，拉伸中间部分，特殊的对比度拉伸。</p><p><img src="https://source.cclmsy.cc/Images/Posts/IP/IP04.png" alt=""></p><h3 id="4-1-4-其他变换">4.1.4.其他变换</h3><ul><li>对数变换：$s=c\log(1+r)$</li><li>幂次变换：$s=cr^\gamma$</li><li>离散化：$s=0\ if\ r&lt;b\ else\ L-1$</li></ul><h2 id="4-2-基于直方图的图像增强方法">4.2.基于直方图的图像增强方法</h2><h3 id="4-2-1-直方图均衡化">4.2.1.直方图均衡化</h3><p>将一副已知图像变换成灰度具有均匀概率分布的图像，通过增大灰度值范围和对比度实现图像增强。</p><ul><li>记原图像$f$的灰度级为$L$，对原图像$f$进行直方图均衡化得到的新图像为$g$。图像直方图均衡化的步骤如下：</li></ul><ol><li>统计原图像$f$中各个灰度级的像素个数，得到原图像的直方图$H(f)$。<ul><li>给定 $16\times16$的图像$f$灰度级$L=8$</li><li>给定 $H(f)=[29,40,32,27,13,10,6,3]$</li></ul></li><li>对原图像的直方图$H(f)$进行归一化处理，得到归一化直方图$P(f)$。<ul><li>归一化直方图$P(f)=[0.18,0.25,0.20,0.17,0.08,0.06,0.04,0.02]$</li></ul></li><li>计算归一化直方图$P(f)$的累积分布函数$C(f)$（前缀和）。<ul><li>累积分布函数$C(f)=[0.18,0.43,0.63,0.80,0.88,0.94,0.98,1.00]$</li></ul></li><li>计算新灰度级$t_i=round((L-1)c(i))$（四舍五入）<ul><li>$[1,3,4,6,6,7,7,7]$</li></ul></li><li>将原图像$f$中的灰度级$i$替换为新灰度级$t_i$，得到直方图均衡化后的新图像$g$。</li><li>统计新图像$g$中各个灰度级的像素个数，得到新图像的直方图$H(g)$。<ul><li>$H(g)=[0,29,0,40,32,0,40,19]$</li></ul></li><li>对新图像的直方图$H(g)$进行归一化处理，得到新图像的归一化直方图$P(g)$。<ul><li>$P(g)=[0.00,0.18,0.00,0.25,0.20,0.00,0.25,0.12]$</li></ul></li></ol><ul><li>通过直方图均衡化，可以使得图像的灰度值分布更加均匀，从而增强图像的对比度。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_eq = cv2.equalizeHist(img) <span class="comment"># 直方图均衡化</span></span><br></pre></td></tr></table></figure><h3 id="4-2-2-直方图规定化">4.2.2.直方图规定化</h3><p>直方图均衡化能显著的增强整个图像的对比度，但增强效果不易控制。通过直方图规定化，可以人为地改变直方图的形状。</p><ul><li>图像直方图规定化的步骤如下：</li></ul><ol><li>统计原图像$f$中各个灰度级的像素个数，得到原图像的直方图$H(f)$。<ul><li>给定$64\times64$的图像$f$灰度级$L=8$</li><li>给定 $H(f)=[790,1023,850,656,329,245,122,81]$</li></ul></li><li>对原图像的直方图$H(f)$进行归一化处理，得到归一化直方图$P(f)$。<ul><li>$P(f)=[0.19,0.25,0.21,0.16,0.08,0.06,0.03,0.02]$</li></ul></li><li>计算归一化直方图$P(f)$的累积分布函数$C(f)$（前缀和）。<ul><li>$C(f)=[0.19,0.44,0.65,0.81,0.89,0.95,0.98,1.00]$</li></ul></li><li>对于给定的目标信息，求出目标累积分布函数$C_1(f_1)$。<ul><li>假设给定$P_1(f_1)=[0,0,0,0.15,0.2,0.3,0.2,0.15]$</li><li>$C_1(f_1)=[0,0,0,0.15,0.35,0.65,0.85,1.00]$</li></ul></li><li>比较$C(f)$和$C(f_1)$，对于原图像$f$每个灰度级$i$，找到$|C(i)-C_1(j)|$最接近的$j$，得到映射关系。<ul><li>$C(f)=[0.19,0.44,0.65,0.81,0.89,0.95,0.98,1.00]$</li><li>$C_1(f_1)=[0,0,0,0.15,0.35,0.65,0.85,1.00]$</li><li>$T(i)=[3,4,5,6,6,7,7,7]$</li></ul></li><li>将原图像$f$中的灰度级$i$替换为新灰度级$t_i$，得到直方图均衡化后的新图像$g$。</li><li>统计新图像$g$中各个灰度级的像素个数，得到新图像的直方图$H(g)$。<ul><li>$H(g)=[0,0,0,790,1023,850,985,448]$</li></ul></li><li>对新图像的直方图$H(g)$进行归一化处理，得到新图像的归一化直方图$P(g)$。<ul><li>$P(g)=[0,0,0,0.19,0.25,0.21,0.24,0.11]$</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">f = cv2.imread(<span class="string">&#x27;lenna.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">f1 = cv2.imread(<span class="string">&#x27;Flower.png&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line">Hf = cv2.calcHist([f], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">Pf = Hf / np.<span class="built_in">sum</span>(Hf)</span><br><span class="line">Cf = [np.<span class="built_in">sum</span>(Pf[:i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line"></span><br><span class="line">Hf1 = cv2.calcHist([f1], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">Pf1 = Hf1 / np.<span class="built_in">sum</span>(Hf1)</span><br><span class="line">Cf1 = [np.<span class="built_in">sum</span>(Pf1[:i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line"></span><br><span class="line">Tr = np.zeros(<span class="number">256</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    tmp_h = np.ones(<span class="number">256</span>) * Cf1[i]</span><br><span class="line">    tmp = np.fabs(Cf - tmp_h) <span class="comment"># 对应元素相减取绝对值</span></span><br><span class="line">    Tr[i] = np.argmin(tmp) <span class="comment"># 找到最小值的索引</span></span><br><span class="line"></span><br><span class="line">out = cv2.LUT(f, Tr)</span><br></pre></td></tr></table></figure><h2 id="4-滤波">4.*.滤波</h2><ul><li>利用像素和其邻域像素的灰度值进行图像增强的方法。</li><li>空间滤波分为平滑滤波和锐化滤波。</li><li>filter：滤波器，用于对图像进行滤波处理</li><li>mask：滤波器的模板，用于计算滤波后的像素值</li></ul><h2 id="4-3-基于空间平滑滤波的图像增强方法">4.3.基于空间平滑滤波的图像增强方法</h2><ul><li>平滑滤波<ul><li>目的：去除（细小）噪声、平滑图像</li><li>本质：对像素和其邻域像素的灰度值进行加权平均</li></ul></li></ul><h3 id="4-3-1-线性滤波方法——邻域平均滤波">4.3.1.线性滤波方法——邻域平均滤波</h3><ul><li>mask：$h=\dfrac{1}{9}\begin{bmatrix}1&amp;1&amp;1 \\ 1&amp;1&amp;1 \\ 1&amp;1&amp;1\end{bmatrix}$</li><li>可以调整mask的大小和权重，实现不同的平滑效果。<ul><li>参数越大，平滑效果越明显，图像越模糊。</li><li>一般中心像素权重最大，边缘像素权重较小。</li></ul></li><li>可以根据Gaussian分布确定mask的权重，实现高斯滤波。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ksize = (<span class="number">5</span>, <span class="number">5</span>) <span class="comment"># mask大小，奇数</span></span><br><span class="line">img_blur = cv2.blur(img, ksize) <span class="comment"># 邻域平均滤波</span></span><br><span class="line">img_gaussian = cv2.GaussianBlur(img, ksize, <span class="number">0</span>) <span class="comment"># 高斯滤波</span></span><br></pre></td></tr></table></figure><h3 id="4-3-2-非线性滤波方法——中值滤波">4.3.2.非线性滤波方法——中值滤波</h3><ul><li>中值滤波窗口形状不定：矩形、圆形、十字形等</li><li>选取窗口内像素的中值作为中心像素的灰度值</li><li>优点：在减少边缘模糊方面比邻域平均效果好，对消除冲激噪声效果好</li><li>缺点：对消除高斯噪声效果差</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_median = cv2.medianBlur(img, <span class="number">5</span>) <span class="comment"># 中值滤波</span></span><br></pre></td></tr></table></figure><h2 id="4-4-基于空间锐化滤波的图像增强方法">4.4.基于空间锐化滤波的图像增强方法</h2><ul><li>锐化滤波<ul><li>目的：增强图像的边缘、轮廓</li><li>要求：图像具有较高的信噪比</li><li>锐化处理通常和边缘检测结合使用</li></ul></li><li>梯度<ul><li>函数$z=f(x,y)$在点$(x,y)$处的梯度：$\nabla f(x,y)=\left[\dfrac{\partial f}{\partial x},\dfrac{\partial f}{\partial y}\right]^T$</li><li>梯度是一个向量，具有方向和模</li><li>梯度的方向$\theta$：$\theta=\arctan\left(\dfrac{\partial f}{\partial y}/\dfrac{\partial f}{\partial x}\right)$</li><li>梯度的模$G$：<ul><li>按2-范数计算，对应欧几里得距离（欧氏距离）：$|\nabla f_{(2)}|=\sqrt{\left(\dfrac{\partial f}{\partial x}\right)^2+\left(\dfrac{\partial f}{\partial y}\right)^2}$</li><li>按1-范数计算，对应曼哈顿距离（街区距离）：$|\nabla f_{(1)}|=|\dfrac{\partial f}{\partial x}|+|\dfrac{\partial f}{\partial y}|$</li><li>按$\infty$-范数计算，对应棋盘距离：$|\nabla f_{(\infty)}|=\max(|\dfrac{\partial f}{\partial x}|,|\dfrac{\partial f}{\partial y}|)$</li></ul></li></ul></li><li>由于数字图像的离散性，偏导使用差分表示：<ul><li>一阶水平：$\Delta_y f(x,y)=f(x,y+1)-f(x,y)$</li><li>一阶垂直：$\Delta_x f(x,y)=f(x+1,y)-f(x,y)$</li><li>二阶水平：$\Delta_{yy} f(x,y)=f(x,y+1)+f(x,y-1)-2f(x,y)$</li><li>二阶垂直：$\Delta_{xx} f(x,y)=f(x+1,y)+f(x-1,y)-2f(x,y)$</li></ul></li></ul><h3 id="4-4-1-罗伯特算子（Roberts-Operator）">4.4.1.罗伯特算子（Roberts Operator）</h3><ul><li>$G=|\Delta_x f(x,y)|+|\Delta_y f(x,y)|$</li><li>$h=\begin{bmatrix}1&amp;0\\0&amp;-1\end{bmatrix}或\begin{bmatrix}0&amp;1\\-1&amp;0\end{bmatrix}$</li><li>优点：交叉差分法，简单，计算量小。</li><li>缺点：使用像素少，对噪声敏感。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_roberts = cv2.filter2D(img, -<span class="number">1</span>, np.array([[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]])) <span class="comment"># 罗伯特算子</span></span><br></pre></td></tr></table></figure><h3 id="4-4-2-拉普拉斯算子（Laplacian-Operator）">4.4.2.拉普拉斯算子（Laplacian Operator）</h3><ul><li>$G=|\Delta_{xx} f(x,y)|+|\Delta_{yy} f(x,y)|$</li><li>常用mask：<ul><li>$h_{4,1}=\begin{bmatrix}0&amp;1&amp;0\\1&amp;-4&amp;1\\0&amp;1&amp;0\end{bmatrix}$</li><li>$h_{4,2}=\dfrac{1}{2}\begin{bmatrix}1&amp;0&amp;1\\0&amp;-4&amp;0\\1&amp;0&amp;1\end{bmatrix}$</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_laplacian = cv2.Laplacian(img, cv2.CV_64F, ksize=<span class="number">3</span>) <span class="comment"># 拉普拉斯算子，参数越大，线条越粗</span></span><br></pre></td></tr></table></figure><h3 id="4-4-3-普瑞维特算子（Prewitt-Operator）">4.4.3.普瑞维特算子（Prewitt Operator）</h3><ul><li>近似一阶导数</li><li>常用mask:<ul><li>$h_1 = \begin{bmatrix}1&amp;1&amp;1\\0&amp;0&amp;0\\-1&amp;-1&amp;-1\end{bmatrix}$</li><li>其余通过旋转得到</li></ul></li></ul><h3 id="4-4-4-索贝尔算子（Sobel-Operator）">4.4.4.索贝尔算子（Sobel Operator）</h3><ul><li>近似一阶导数，往往用于估计水平和垂直方向的梯度</li><li>常用mask:<ul><li>$h_1 = \begin{bmatrix}-1&amp;-2&amp;-1\\0&amp;0&amp;0\\1&amp;2&amp;1\end{bmatrix}$</li><li>$h_2 = \begin{bmatrix}-1&amp;0&amp;1\\-2&amp;0&amp;2\\-1&amp;0&amp;1\end{bmatrix}$</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img_sobelx = cv2.Sobel(img, cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>, ksize=<span class="number">3</span>) <span class="comment"># x方向梯度（竖直），ksize越大，成块的色块越大</span></span><br><span class="line">img_sobely = cv2.Sobel(img, cv2.CV_64F, <span class="number">0</span>, <span class="number">1</span>, ksize=<span class="number">3</span>) <span class="comment"># y方向梯度（水平）</span></span><br><span class="line">img_sobel = cv2.magnitude(img_sobelx, img_sobely) <span class="comment"># 梯度幅值</span></span><br></pre></td></tr></table></figure><h1>五、频率域图像增强</h1><ul><li>三大类正交变换：正弦型变换、方波型变换、基于特征向量的变换</li><li>卷积：一种数学算子，施加于两个函数$f,g$，产生第三个函数。<ul><li>定义：$(f*g)(t)=\int_{-\infty}^{+\infty}f(\tau)g(t-\tau)d\tau=\int_{-\infty}^{+\infty}f(t-\tau)g(\tau)d\tau$</li></ul></li><li>频率域图像处理流程：<ul><li>$原图像f(x,y)\xrightarrow{傅里叶变换}F(u,v)\xrightarrow{H(u,v)滤波}G(u,v)\xrightarrow{傅里叶逆变换}结果图像g(x,y)$</li></ul></li></ul><h2 id="5-1-离散傅里叶变换（Discrete-Fourier-Transform，DFT）">5.1.离散傅里叶变换（Discrete Fourier Transform，DFT）</h2><ul><li>傅里叶变换将一个信号从时间域转换到频率域，反傅里叶变换将一个信号从频率域转换到时间域。</li><li>离散傅里叶变换是正弦型变换</li></ul><h3 id="5-1-1-一维连续傅里叶变换">5.1.1.一维连续傅里叶变换</h3><ul><li>一阶连续函数$f(x)$的傅里叶变换：$F(u)=\int_{-\infty}^{+\infty}f(x)e^{-j2\pi ux}dx$（j为虚数单位）</li><li>一阶连续函数$f(x)$的反傅里叶变换：$f(x)=\int_{-\infty}^{+\infty}F(u)e^{j2\pi ux}du$</li><li><strong>欧拉公式</strong>：$e^{j\theta}=\cos\theta+j\sin\theta$</li></ul><h3 id="5-1-2-一维离散傅里叶变换">5.1.2.一维离散傅里叶变换</h3><ul><li>给定时间序列$x[n],n=0,1,2,\cdots,N-1$<ul><li>离散傅里叶变换为：<ul><li>$X[k]=\sum\limits_{n=0}^{N-1}x[n]e^{-j2\pi kn/N}$</li></ul></li><li>离散傅里叶逆变换为：<ul><li>$x[n]=\dfrac{1}{N}\sum\limits_{k=0}^{N-1}X[k]e^{j2\pi kn/N}$</li></ul></li></ul></li><li>以$N=4$为例，利用欧拉定理可知：<ul><li>$\begin{bmatrix}X_0\\X_1\\X_2\\X_3\end{bmatrix}=\begin{bmatrix}e^{-0\cdot i\pi/2}&amp;e^{-0\cdot i\pi}&amp;e^{-0\cdot i3\pi/2}&amp;e^{-0\cdot i2\pi}\\e^{-0\cdot i\pi/2}&amp;e^{-1\cdot i\pi}&amp;e^{-2\cdot i3\pi/2}&amp;e^{-3\cdot i2\pi}\\e^{-0\cdot i\pi/2}&amp;e^{-2\cdot i\pi}&amp;e^{-4\cdot i3\pi/2}&amp;e^{-6\cdot i2\pi}\\e^{-0\cdot i\pi/2}&amp;e^{-3\cdot i\pi}&amp;e^{-6\cdot i3\pi/2}&amp;e^{-9\cdot i2\pi}\end{bmatrix}\begin{bmatrix}x_0\\x_1\\x_2\\x_3\end{bmatrix}=\begin{bmatrix}1&amp;1&amp;1&amp;1\\1&amp;-i&amp;-1&amp;i\\1&amp;-1&amp;1&amp;-1\\1&amp;i&amp;-1&amp;-i\end{bmatrix}\begin{bmatrix}x_0\\x_1\\x_2\\x_3\end{bmatrix}$</li></ul></li></ul><h3 id="5-1-3-二维离散傅里叶变换">5.1.3.二维离散傅里叶变换</h3><ul><li>对于给定的二维离散信号$f(x,y)$，$x\in[0,M-1],y\in[0,N-1]$<ul><li>二维离散傅里叶变换：<ul><li>$F(u,v)=\sum\limits_{x=0}^{M-1}\sum\limits_{y=0}^{N-1}f(x,y)e^{-j2\pi(\dfrac{ux}{M}+\dfrac{vy}{N})}$</li></ul></li><li>二维离散傅里叶逆变换：<ul><li>$f(x,y)=\dfrac{1}{\sqrt{MN}}\sum\limits_{u=0}^{M-1}\sum\limits_{v=0}^{N-1}F(u,v)exp({j2\pi(\dfrac{ux}{M}+\dfrac{vy}{N})})$</li></ul></li></ul></li><li>可分离性：傅里叶变换中的指数项可分离成只含有x,u的一项和只含有y,v的一项的乘积<ul><li>$exp(-j2\pi\dfrac{ux+vy}{N})=exp(-j2\pi\dfrac{ux}{N})\cdot exp(-j2\pi\dfrac{vy}{N})$</li><li>即$F(u,v)=\sum\limits_{x=0}^{N-1}F(x,v)exp(-j2\pi\dfrac{ux}{N})$</li><li>结论：对每个x，对行进行一次一维DFT，对每个y，对列进行一次一维DFT，可以得到二维DFT</li></ul></li><li>零频率分量与平均值<ul><li>$F(0,0)=\dfrac{1}{\sqrt{MN}}\sum\limits_{x=0}^{M-1}\sum\limits_{y=0}^{N-1}f(x,y)$</li><li>结论：$F(0,0)$与图像的平均值成正比，$k=\sqrt{MN}$</li></ul></li><li>共轭对称性<ul><li>$F(u,v)=F^*(-u,-v)$</li><li>结论：对于实数图像，其频谱是共轭对称的</li></ul></li><li>平移不变性<ul><li>空间域平移：$f(x-x_0,y-y_0)\leftrightarrow F(u,v)exp(-j2\pi\dfrac{ux_0}{M})exp(-j2\pi\dfrac{vy_0}{N})$</li><li>频率域平移：$f(x,y)exp(j2\pi\dfrac{ux_0}{M})exp(j2\pi\dfrac{vy_0}{N})\leftrightarrow F(u-u_0,v-v_0)$</li><li>结论：在空间域中平移图像，频率域只发生相移，不发生幅度变化；在频率域中平移图像，空间域只发生相移，图像幅值不变。</li></ul></li><li>周期性<ul><li>$|F(u,v)|=|F(u+M,v+N)|=|F(-u,-v)|=|F(M-u,N-v)|$</li></ul></li></ul><h3 id="5-1-4-OpenCV">5.1.4.OpenCV</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">img_dft = cv2.dft(np.float32(img), flags=cv2.DFT_COMPLEX_OUTPUT) <span class="comment"># 二维离散傅里叶变换</span></span><br><span class="line"><span class="comment"># flags: cv2.DFT_COMPLEX_OUTPUT（输出为复数数组）、cv2.DFT_REAL_OUTPUT（只输出实数数组）</span></span><br><span class="line">img_idft = cv2.idft(img_dft) <span class="comment"># 二维离散傅里叶逆变换，输出为复数数组</span></span><br><span class="line">img_dftshf = np.fft.fftshift(img_dft) <span class="comment"># 频谱中心化</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当图像数组的大小为2的幂次方时，dft()的运算速度最快</span></span><br><span class="line">rows, cols = img.shape</span><br><span class="line">new_rows = cv2.getOptimalDFTSize(rows) <span class="comment"># 获取最优行数</span></span><br><span class="line">new_cols = cv2.getOptimalDFTSize(cols) <span class="comment"># 获取最优列数</span></span><br><span class="line"></span><br><span class="line">dft_mag, dft_pol = cv2.cartToPolar(img_dft[:,:,<span class="number">0</span>], img_dft[:,:,<span class="number">1</span>]) <span class="comment"># 极坐标转换</span></span><br></pre></td></tr></table></figure><h2 id="5-2-图像的傅里叶频谱分析">5.2.图像的傅里叶频谱分析</h2><h3 id="5-2-1-频谱图像关于-M-2-N-2-对称">5.2.1.频谱图像关于$(M/2,N/2)$对称</h3><h3 id="5-2-2-频谱中心化前后的频谱图像">5.2.2.频谱中心化前后的频谱图像</h3><ul><li>中心化前：频谱图像的原点位于左上角。低频分量位于图像的四角，高频分量位于图像的中心。</li><li>中心化后：频谱图像的原点位于中心。低频分量位于图像的中心，高频分量位于图像的四角。</li><li>由于傅里叶变换的周期性，可以将中心化前的图像组成$2\times2$的周期图像，取中心部分即为中心化后的图像。</li></ul><h3 id="5-2-3-傅里叶变换的意义">5.2.3.傅里叶变换的意义</h3><ol><li>简化计算：傅里叶变换将空间域图像转换到频率域，在空间域中处理图像时用到的复杂卷积运算，等同于在频率域中进行简单的乘法运算。</li><li>用频谱图表示的频率域图像中：<ul><li>中心部位是能量集中的低频特征，反映图像的平滑部分</li><li>边缘部位是能量分散的高频特征，对应于细节、边缘、结构复杂区域、突变部位和噪声</li><li>因此，频率域中滤波的概念更直观、更易理解</li></ul></li><li>某些特定的应用需求只能在频率域进行处理，如频率域图像特征提取、数据压缩、纹理分析等</li></ol><h2 id="5-3-基于频率域滤波的图像噪声消除——频率域低通滤波">5.3.基于频率域滤波的图像噪声消除——频率域低通滤波</h2><ul><li>图像的边缘和噪声对应于傅里叶频谱的高频成分。</li><li>低通滤波器：保留低频成分，抑制高频成分。</li><li>可以削弱噪声影响，但是会模糊边缘细节，降低图像清晰度。</li><li>与空间域平滑滤波效果类似。</li></ul><h3 id="5-3-1-理想低通滤波器">5.3.1.理想低通滤波器</h3><p>设置一个截止频率$D_0$，只保留频率小于$D_0$的成分。</p><ul><li>理想低通滤波器：$H(u,v)=\begin{cases}1&amp;D(u,v)\leq D_0\\0&amp;D(u,v)&gt;D_0\end{cases}$</li><li>其中，$D(u,v)$是频率域中点$(u,v)$到中心的距离。若变换被中心化，注意调整$D(u,v)$的计算方式。</li><li>理想低通滤波器无法通过电子器件实现。</li></ul><h3 id="5-3-2-巴特沃斯低通滤波器（Butterworth-Lowpass-Filter）">5.3.2.巴特沃斯低通滤波器（Butterworth Lowpass Filter）</h3><ul><li>n阶巴特沃斯低通滤波器：$H(u,v)=\dfrac{1}{1+[D(u,v)/D_0]^{2n}}$</li><li>巴特沃斯低通滤波器能够物理实现。</li></ul><h3 id="5-4-3-其他低通滤波器">5.4.3.其他低通滤波器</h3><ul><li>梯形低通滤波器</li><li>n指数型低通滤波器</li></ul><h2 id="5-4-基于频率域滤波的图像增强——频率域高通滤波">5.4.基于频率域滤波的图像增强——频率域高通滤波</h2><ul><li>图像的边缘和细节对应于傅里叶频谱的高频成分。</li><li>高通滤波器：保留高频成分，抑制低频成分。</li></ul><h3 id="5-4-1-理想高通滤波器">5.4.1.理想高通滤波器</h3><p>与理想低通滤波器相反，只保留频率大于$D_0$的成分。</p><ul><li>理想高通滤波器：$H(u,v)=\begin{cases}1&amp;D(u,v)&gt;D_0\\0&amp;D(u,v)\leq D_0\end{cases}$</li></ul><h3 id="5-4-2-巴特沃斯高通滤波器（Butterworth-Highpass-Filter）">5.4.2.巴特沃斯高通滤波器（Butterworth Highpass Filter）</h3><ul><li>n阶巴特沃斯高通滤波器：$H(u,v)=1-\dfrac{1}{1+[D_0/D(u,v)]^{2n}}$</li></ul><h3 id="5-4-3-高频增强滤波器">5.4.3.高频增强滤波器</h3><ul><li>高通滤波会滤除低频成分，导致整体形象变暗。</li><li>高频增强滤波器：$H_e(u,v)=kH(u,v)+c$<ul><li>$k&gt;1$：增强高频成分</li><li>$c$：适当保留低频成分</li></ul></li></ul><h2 id="5-5-带通滤波和带阻滤波">5.5.带通滤波和带阻滤波</h2><ul><li>带通滤波：只保留频率在两个截止频率之间的成分。</li><li>带阻滤波：只保留频率在两个截止频率之外的成分。</li></ul><h2 id="5-6-习题">5.6.习题</h2><ol><li>空间域图像和模板之间的运算是一种卷积运算。由卷积定理，空域的卷积可以通过频域中图像的傅立叶变换和模板的傅立叶变换间的乘积运算来实现。所以，对频域中的转移函数求傅立叶反变换即可得到用于空域卷积的模板。</li></ol><h1>七、图像压缩编码</h1><h2 id="7-1-离散余弦变换（Discrete-Cosine-Transform，DCT）">7.1.离散余弦变换（Discrete Cosine Transform，DCT）</h2><ul><li>DCT变换避免了复数运算。若图像矩阵是实数矩阵，则DCT变换后的矩阵也是实数矩阵。</li><li>DCT是一种正交变换，变换矩阵是正交矩阵，变换核是可分离的。</li><li>DCT有快速算法。</li><li>DCT具有更强的信息集中能力。</li></ul><h3 id="7-1-1-一维离散余弦变换">7.1.1.一维离散余弦变换</h3><ul><li>给定长度为N的一维信号$x[n],n=0,1,2,\cdots,N-1$<ul><li>一种常用的1D-DCT形式：$X[u]=a(u)\sum\limits_{m=0}^{N-1}x[m]cos(\dfrac{(2m+1)u\pi}{2N})$，其中$a(u)=\begin{cases}\sqrt{\dfrac{1}{N}}&amp;u=0\\\sqrt{\dfrac{2}{N}}&amp;u&gt;0\end{cases}$</li></ul></li><li>以$N=4$为例<ul><li>1D-DCT：$\begin{bmatrix}X_0\\X_1\\X_2\\X_3\end{bmatrix}=\begin{bmatrix}0.5&amp;0.5&amp;0.5&amp;0.5\\0.65&amp;0.27&amp;-0.27&amp;-0.65\\0.5&amp;-0.5&amp;-0.5&amp;0.5\\0.27&amp;-0.65&amp;0.65&amp;-0.27\end{bmatrix}\begin{bmatrix}x_0\\x_1\\x_2\\x_3\end{bmatrix}$</li><li>1D-IDCT：$\begin{bmatrix}x_0\\x_1\\x_2\\x_3\end{bmatrix}=\begin{bmatrix}0.5&amp;0.65&amp;0.5&amp;0.27\\0.5&amp;0.27&amp;-0.5&amp;-0.65\\0.5&amp;-0.27&amp;-0.5&amp;0.65\\0.5&amp;-0.65&amp;0.5&amp;-0.27\end{bmatrix}\begin{bmatrix}X_0\\X_1\\X_2\\X_3\end{bmatrix}$</li></ul></li></ul><h3 id="7-1-2-二维离散余弦变换">7.1.2.二维离散余弦变换</h3><ul><li>给定二维信号$x[m,n],m=0,1,2,\cdots,M-1,n=0,1,2,\cdots,N-1$<ul><li>2D-DCT：<ul><li>$C(u,v)=a(u)a(v)\sum\limits_{m=0}^{M-1}\sum\limits_{n=0}^{N-1}f(x,y)cos(\dfrac{(2x+1)u\pi}{2M})cos(\dfrac{(2y+1)v\pi}{2N})$</li></ul></li><li>2D-IDCT：<ul><li>$f(x,y)=\sum\limits_{u=0}^{M-1}\sum\limits_{v=0}^{N-1}a(u)a(v)C(u,v)cos(\dfrac{(2x+1)u\pi}{2M})cos(\dfrac{(2y+1)v\pi}{2N})$</li></ul></li><li>其中，$a(u)=\begin{cases}\sqrt{\dfrac{1}{N}}&amp;u=0\\\sqrt{\dfrac{2}{N}}&amp;u&gt;0\end{cases}$</li></ul></li></ul><h3 id="7-1-3-OpenCV">7.1.3.OpenCV</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img_dct = cv2.dct(img.astype(np.float32)) <span class="comment"># 二维离散余弦变换</span></span><br><span class="line">img_idct = cv2.idct(img_dct) <span class="comment"># 二维离散余弦逆变换</span></span><br></pre></td></tr></table></figure><h2 id="7-2-数字图像压缩编码基础">7.2.数字图像压缩编码基础</h2><h3 id="7-2-1-信息冗余">7.2.1.信息冗余</h3><ul><li>图像压缩的原理<ul><li>图像信号存在大量的冗余</li><li>人眼对图像的感知有限，可以以一定失真为代价换取数据量减少</li></ul></li><li>压缩率：$压缩率=\dfrac{原始数据量}{压缩后数据量}$</li><li>信息冗余<ul><li>空间冗余：相邻像素之间具有相关性</li><li>时间冗余：视频序列中相邻帧之间具有相关性</li><li>编码冗余：由编码方式导致的冗余</li><li>心理-视觉冗余：人眼对图像的感知有限，某些信息不重要</li></ul></li><li>图像质量的主观评价：人的主观感受，如图像的清晰度、色彩、对比度等。</li><li>图像质量的客观评价：信噪比（SNR）、峰值信噪比（PSNR）、均方误差（MSE）等。</li></ul><h3 id="7-2-2-图像质量的客观评价">7.2.2.图像质量的客观评价</h3><p>原始图像$f$，压缩后的图像$g$，图像大小为$M\times N$</p><h4 id="7-2-2-1-均方误差（Mean-Square-Error，MSE）">7.2.2.1.均方误差（Mean Square Error，MSE）</h4><ul><li>$MSE=\dfrac{1}{MN}\sum\limits_{x=0}^{M-1}\sum\limits_{y=0}^{N-1}[f(x,y)-g(x,y)]^2$</li></ul><h4 id="7-2-2-2-信噪比（Signal-to-Noise-Ratio，SNR）">7.2.2.2.信噪比（Signal-to-Noise Ratio，SNR）</h4><ul><li>$SNR=10\log_{10}\dfrac{\sigma^2}{MSE}$</li><li>其中$\sigma^2=\dfrac{1}{MN}\sum\limits_{x=0}^{M-1}\sum\limits_{y=0}^{N-1}f^2(x,y)$（原始图像的平方平均）</li></ul><h4 id="7-2-2-3-峰值信噪比（Peak-Signal-to-Noise-Ratio，PSNR）">7.2.2.3.峰值信噪比（Peak Signal-to-Noise Ratio，PSNR）</h4><ul><li>$PSNR=10\log_{10}\dfrac{max(I)^2}{MSE}$</li><li>通常$max(I)=L-1$</li></ul><h2 id="7-3-图像压缩编码">7.3.图像压缩编码</h2><ul><li>图像压缩编码处理流程：$f(x,y)\xrightarrow{信源编码器}\xrightarrow{信道编码器}信道传输\xrightarrow{信道解码器}\xrightarrow{信源解码器}g(x,y)$</li><li>信源编码：通过减少冗余来压缩数据的过程。<ul><li>信源编码器模型：$f(x,y)\rightarrow映射变换器\rightarrow量化器\rightarrow符号编码器\rightarrow 信道$</li><li>信源解码器模型：$信道\rightarrow符号解码器\rightarrow反量化器\rightarrow反向映射变换器\rightarrow g(x,y)$</li></ul></li><li>信道编码：也称差错控制编码，是一种在发送端给原数据添加与原数据相关的冗余信息，以便在接收端检测和纠正错误的编码方式。用于对抗传输过程中的噪声干扰。<ul><li>汉明码、循环冗余校验码（CRC）</li></ul></li></ul><h3 id="7-3-1-信息量与信息熵">7.3.1.信息量与信息熵</h3><ul><li>事件提供的信息量：$I(x)=-\log_2P(x)$</li><li>信源：$X,x_i=p_i$，$x_i$发生的概率为$p_i$</li><li>信源熵：$H(X)=-\sum\limits_{i=1}^n p_i\log_2p_i$（比特/符号）<ul><li>信源的平均信息量，即信源发出一个符号所携带的平均信息量</li><li>非负，在所有事件概率均等时，熵最大</li></ul></li></ul><h3 id="7-3-2-编码">7.3.2.编码</h3><ul><li>编码：由信源消息集到码字集的映射</li><li>根据长度是否相等分为：等长码和变长码</li><li>香农定理：无干扰下，平均码长的下限为信源熵</li><li>压缩比：$压缩比C=\dfrac{信源的平均比特率n}{编码后平均码长n_d}$</li><li>最大压缩比：$C_{max}=\dfrac{n}{H(X)}$</li></ul><h3 id="7-3-3-哈夫曼编码">7.3.3.哈夫曼编码</h3><ul><li>带权路径长度（WPL）：$WPL=\sum\limits_{i=1}^n p_i l_i$</li><li>算法：<ul><li>每次选取权重最小的两个节点，合并到一个新的节点，新节点的权重为两个节点的权重之和</li><li>直到所有节点合并到一起，最终得到一棵树</li><li>每个叶子节点代表一个源符号，从根节点到叶子节点的路径上的编码即为哈夫曼编码</li></ul></li></ul><h3 id="7-3-4-算术编码">7.3.4.算术编码</h3><ul><li>根据权重分配概率</li><li>符号序列映射为$[0,1)$的一个子区间</li><li>设$a:30%,b:70%$，则$a=[0,0.3),b=[0.3,1),aa=[0,0.09),ab=[0.09,0.3),ba=[0.3,0.51),bb=[0.51,1)$</li></ul><h2 id="7-4-位平面编码">7.4.位平面编码</h2><ul><li>位平面分解：一幅$m$比特表示灰度的图像，可以看作$m$个二值图像序列</li><li>在位平面中存在大量具有相同值的区域，可以利用连续的0和1进行高效的压缩编码和传输</li></ul><h3 id="7-4-1-格雷码分解编码">7.4.1.格雷码分解编码</h3><ul><li>格雷码：相邻两个数的二进制码只有一位不同</li><li>设源图像中像素灰度值原$m$位为$x_{m-1}\cdots x_1x_0$，则有：$\begin{cases}g_i=x_i\oplus x_{i-1}\\g_{m-1}=x_{m-1}\end{cases}$</li><li>这种方式保证了相邻像素的格雷码值只有一位不同，在位平面上的连续0和1的序列更多，有利于压缩编码</li></ul><h2 id="7-5-游程编码-行程编码">7.5.游程编码/行程编码</h2><ul><li>适用于连续的0和1较多的序列</li><li>缺点：对于交替的0和1，效果不好甚至会增加编码长度</li></ul><h3 id="7-5-1-基本思想">7.5.1.基本思想</h3><ul><li>对于连续的原符号，用一个符号和一个计数值来表示</li><li>如：$aaaaabbbcccc\rightarrow a5b3c4$</li></ul><h3 id="7-5-2-表0的游程编码">7.5.2.表0的游程编码</h3><ul><li>用一个$k$位二进制数表示相邻两个$1$之间$0$的个数</li><li>如：$0(14)10(9)110(20)10(30)110(11)1（括号内为连续0的数量）\rightarrow 1110(14),1001(9),0000(0),1111 0101(15+5=20),1111 1111(15+15=30),0000(0),1011(11),0000(0)（括号内为二进制表示数的含义）$</li></ul><h3 id="7-5-3-国际传真标准CCITT-T-4-G3">7.5.3.国际传真标准CCITT T.4(G3)</h3><ul><li>采用了霍夫曼编码和游程编码相结合的方法，对每种白长码字和黑长码字进行霍夫曼编码。</li><li>每一行总是以白长开始，允许为0；以唯一行尾（EOL）码字结束。</li></ul><h2 id="7-6-变换编码">7.6.变换编码</h2><h1>九、图像分割</h1><h2 id="9-1-图像分割的基本概念">9.1.图像分割的基本概念</h2><ul><li>图像分割：依据图像的灰度、颜色、纹理、边缘等特征，把图像分成各自满足某种特征的连通区域的集合。</li><li>特征：灰度、颜色、纹理、形状、边缘轮廓等</li></ul><h2 id="9-2-基于边缘检测的图像分割——哈夫变换（Hough-Transform）">9.2.基于边缘检测的图像分割——哈夫变换（Hough Transform）</h2><ul><li>边缘：具有不同灰度的区域的边界</li><li>常用算子：Roberts、Sobel、Prewitt、Laplacian、Canny</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edge = cv2.Canny(img, <span class="number">80</span>, <span class="number">240</span>) <span class="comment"># Canny边缘检测，建议参数3是参数2的3倍</span></span><br></pre></td></tr></table></figure><ul><li>哈夫变换：用于在数字图像中检测直线、圆等形状特征</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">lines = cv2.HoughLinesP(image, rho, theta, threshold, lines=<span class="literal">None</span>, minLineLength=<span class="literal">None</span>, maxLineGap=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 1. image--输入，必须是二值图像，推荐以canny边缘检测结果作为输入;</span></span><br><span class="line"><span class="comment"># 2. rho--线段以像素为单位的距离精度，double类型，推荐值1.0;</span></span><br><span class="line"><span class="comment"># 3. theta--线段以弧度为单位的角度精度，推荐值numpy.pi/180；</span></span><br><span class="line"><span class="comment"># 4. threshlod--累加平面的阈值参数,int类型， 超过阈值才被检测出线段, 值越大, 意味着检出的线段越长, 检出的线段个数越少</span></span><br><span class="line"><span class="comment"># 5. minLineLength--线段以像素为单位的最小，需根据具体场景设定；</span></span><br><span class="line"><span class="comment"># 6. maxLineGap--同一方向上两条线段判定为一条线段的最大允，值越大则同一方向上允许的断裂越大；</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    x1, y1, x2, y2 = line[<span class="number">0</span>] <span class="comment"># 线段的两个端点</span></span><br><span class="line">    cv2.line(img, (x1, y1), (x2, y2), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>) <span class="comment"># 画线</span></span><br><span class="line"></span><br><span class="line">circles = cv2.HoughCircles(image, method, dp, minDist, param1, param2, minRadius, maxRadius)</span><br><span class="line"><span class="comment"># 1. image: 输入的灰度图像</span></span><br><span class="line"><span class="comment"># 2. method: 检测方法，可为cv2.HOUGH_GRADIENT（梯度法霍夫圆检测）、cv2.HOUGH_GRADIENT_ALT（另一种梯度法）</span></span><br><span class="line"><span class="comment"># 3. dp: 文档上写的是图像分辨率与累加器分辨率的比值，通常为1</span></span><br><span class="line"><span class="comment"># 4. minDist：圆心之间最小距离，如果距离太小，会产生很多相交的圆</span></span><br><span class="line"><span class="comment"># 5. param1：canny检测的双阈值中的高阈值，低阈值是它的一半</span></span><br><span class="line"><span class="comment"># 6. param2：最小投票数（基于圆心的投票数）</span></span><br></pre></td></tr></table></figure><h2 id="9-3-基于阈值的图像分割方法">9.3.基于阈值的图像分割方法</h2><p>提取物体与背景在灰度上的差异，将图像分为具有不同灰度级目标区域和背景区域</p><h3 id="9-3-1-基于单一阈值的图像分割">9.3.1.基于单一阈值的图像分割</h3><ul><li>找到一个介于目标和背景灰度之间的阈值$T$，将图像分为两部分</li><li>$m(x,y)=\begin{cases}1&amp;f(x,y)&gt;T\\0&amp;f(x,y)\leq T\end{cases}$</li></ul><h3 id="9-3-2-一种阈值确定方法的步骤">9.3.2. 一种阈值确定方法的步骤</h3><ol><li>选择一个初始估计值$T_0$</li><li>以$T_0$进行图像分割，计算两个像素集合各自的平均灰度值$M_1$和$M_2$</li><li>计算新的阈值$T_1=\dfrac{M_1+M_2}{2}$</li></ol><h3 id="9-3-3-自适应阈值">9.3.3.自适应阈值</h3><p>将图像分为$N\times N$个小区域，对每个小区域分别计算一个阈值</p><h2 id="9-4-基于区域的图像分割方法">9.4.基于区域的图像分割方法</h2><p>根据图像的灰度、颜色、纹理和图像像素统计特征的均匀性等图像的空间局部特征，将图像中的像素划归到各个物体或区域中。</p><h3 id="9-4-1-区域生长法">9.4.1.区域生长法</h3><ul><li>根据事先定义的相似性准则，将具有相似性质的像素点合并成一个区域</li><li>步骤：<ol><li>选择和确定一组能够正确代表所需区域的种子<ul><li>原则：接近聚类中心的像素/红外图像目标检测中最亮的像素/按位置要求/根据经验</li></ul></li><li>确定在生长过程中合并相邻像素的相似性原则<ul><li>颜色（彩色图像）/灰度值差/和已知区域构成某种形状或尺寸</li></ul></li><li>确定终止生长过程的条件或规则<ul><li>一般：没有满足合并条件的像素</li><li>其他：区域大小、灰度差、形状等触发一定条件</li></ul></li><li>从种子像素开始，逐步合并相邻像素，直到满足终止条件</li></ol></li></ul><h3 id="9-4-2-分裂合并法">9.4.2.分裂合并法</h3><ul><li>从整幅图像开始，根据图像中区域间某种不一致性，逐步分裂成更小的区域；再根据相邻子区域的某种一致性准则，逐步合并。</li><li>图像四叉树表示法：<img src="https://source.cclmsy.cc/Images/Posts/IP/IP05.png" alt=""></li><li>步骤：<ol><li>对初始图像$R_0$进行一次四分裂得到四个子区域$R_1,R_2,R_3,R_4$</li><li>对于所有图像$R_i$进行检测，若满足分裂规则（$P(R_i)=TRUE$），则对该区域进行四分裂</li><li>对于所有图像$R_i$进行检测，若相邻区域满足合并规则（$M(R_i,R_j)=TRUE$），则合并这两个区域</li><li>重复步骤2和3，直到不再有区域满足分裂或合并规则</li></ol></li></ul><h1>十二、形态学图像处理</h1><h2 id="12-1-二值形态学的基本运算">12.1.二值形态学的基本运算</h2><h3 id="12-1-1-膨胀运算">12.1.1.膨胀运算</h3><p>$A\oplus B={x|(\hat{B})_y\cap A\neq\emptyset}$</p><p><img src="https://source.cclmsy.cc/Images/Posts/IP/IP07.png" alt=""></p><p>计算过程：<br>创建一个与原图像$A$形状同的全0图像$G$。<br>对于原图像$A$中的每一个1所在的像素，将结构元素$B$的原点放在该位置，将$B$中的1对应的位置在$G$中置1。</p><p><img src="https://source.cclmsy.cc/Images/Posts/IP/IP10.png" alt=""></p><ul><li>图$G$中：白0表示原来是1新图像是0；灰1表示原来是1新图像还是1；黑2表示原来是0，新图像是1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">1</span>), np.uint8) <span class="comment"># 5x1的结构元素</span></span><br><span class="line">img_dilate = cv2.dilate(img, kernel, iterations=<span class="number">1</span>) <span class="comment"># 膨胀运算</span></span><br></pre></td></tr></table></figure><h3 id="12-1-2-腐蚀运算">12.1.2.腐蚀运算</h3><p>$A\ominus B={x|(\hat{B})_y\subseteq A}$</p><p><img src="https://source.cclmsy.cc/Images/Posts/IP/IP06.png" alt=""></p><p>计算过程：<br>创建一个与原图像$A$形状同的全0图像$G$。<br>对于原图像$A$中的每一个1所在的像素，将结构元素$B$的原点放在该位置。<br>若$B$中的1对应的位置在$A$中都是1，则将$G$中该位置置1；<br>否则，$G$中该位置为0。</p><p><img src="https://source.cclmsy.cc/Images/Posts/IP/IP11.png" alt=""></p><ul><li>图$G$中：白0表示原来是1新图像是0；灰1表示原来是1新图像还是1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel = np.ones((<span class="number">3</span>,<span class="number">1</span>), np.uint8) <span class="comment"># 3x1的结构元素</span></span><br><span class="line">img_dilate = cv2.dilate(img, kernel, iterations=<span class="number">1</span>) <span class="comment"># 膨胀运算</span></span><br></pre></td></tr></table></figure><h3 id="12-1-3-开运算">12.1.3.开运算</h3><ul><li>先腐蚀后膨胀</li><li>$A\circ B=(A\ominus B)\oplus B$</li><li>能够消除外部噪点，平滑轮廓</li></ul><h3 id="12-1-4-闭运算">12.1.4.闭运算</h3><ul><li>先膨胀后腐蚀</li><li>$A\bullet B=(A\oplus B)\ominus B$</li><li>能够消除内部噪点，保持物体的面积和形状</li></ul><h3 id="12-1-5-四种基本运算的性质">12.1.5.四种基本运算的性质</h3><p>单调性、扩展性、交换性、结合性、平移不变性</p><h2 id="12-2-二值图像的形态学处理">12.2.二值图像的形态学处理</h2><h3 id="12-2-1-形态滤波">12.2.1.形态滤波</h3><p>形态滤波器：先开后闭/先闭后开</p><h3 id="12-2-2-边界提取">12.2.2.边界提取</h3><p>原图像-腐蚀图像=边界图像</p><h3 id="12-2-3-区域填充">12.2.3.区域填充</h3><ol><li>先对原图像$f$取反得到$f_c$</li><li>对$f_c$进行膨胀运算，得到$f_1$</li><li>对$f_1$和$f_c$求交集，得到$f_2$</li><li>对$f_2$和$f$求并集，得到目标图像$g$</li></ol><h3 id="12-2-4-骨架提取">12.2.4.骨架提取</h3><p>通过迭代腐蚀和差分运算，得到图像的骨架</p><h3 id="12-2-5-物体识别-击中击不中变换">12.2.5.物体识别/击中击不中变换</h3><p>利用具有特定形状的结构元素，对图像进行腐蚀运算，根据内部像素的变化判断物体的形状</p><h1>零一、彩色图像与颜色模型</h1><h2 id="01-1-彩色图像的概述">01.1.彩色图像的概述</h2><ol><li>颜色模型：也称作颜色空间，常见的包括：HSI、HSV、RGB、NTSC、YCbCr等</li><li>光谱分布和彩色感觉是多对一关系：为了得到某一种彩色感觉，可以用不同光谱分布的光以适当比例混合而成，参与混合的光的成分不唯一</li><li>三基色原理：合理地选取三种基本颜色，几乎自然界中所有颜色都可以用这三种颜色的适当混合来表示</li><li>彩色电视及图像处理系统的彩色显示器，都采用红绿蓝三色作为三基色</li></ol><h2 id="01-2-HSI">01.2.HSI</h2><h3 id="01-2-1-HSI">01.2.1.HSI</h3><ul><li>HSI模型：色调（Hue）、饱和度（Saturation）、亮度/灰度（Intensity）</li><li>色调：反映颜色的类别，决定于彩色光的光谱成分，是“质”的特征</li><li>饱和度：反映颜色的纯度，即色彩的浓淡。纯色光谱色的含量越多，饱和度越高</li><li>亮度/灰度：决定了彩色光的强度</li><li>色调和饱和度合称“色度”</li></ul><h3 id="01-2-2-HSI模型">01.2.2.HSI模型</h3><p><img src="https://source.cclmsy.cc/Images/Posts/IP/IP09.png" alt=""></p><ul><li>HSI模型可以表示为一个纺锤体</li><li>色调$H$对应极坐标的$\rho$，饱和度$S$对应极坐标的$\theta$，亮度$I$对应垂直坐标$z$</li><li>$\theta=0,120,240$对应红、绿、蓝三原色</li><li>$I$越大，越靠近白色；$I$越小，越靠近黑色</li></ul><h3 id="01-2-3-HSI与RGB之间的转换">01.2.3.HSI与RGB之间的转换</h3><ol><li>求色调$H$</li></ol><ul><li>$\theta=\arccos(\dfrac{[(R-G)+(R-B)]}{2\sqrt{(R-G)^2+(R-B)(G-B)}})$</li><li>$H=\begin{cases}\theta&amp;G\geq B\\2\pi-\theta&amp;G&lt;B\end{cases}$</li></ul><ol start="2"><li>求饱和度$S$<ul><li>$S=1-\dfrac{3min(R,G,B)}{R+G+B}$</li></ul></li><li>求亮度$I$<ul><li>$I=\dfrac{R+G+B}{3}$</li></ul></li></ol><h2 id="01-3-HSV">01.3.HSV</h2><h3 id="01-3-1-HSV">01.3.1.HSV</h3><ul><li>与HSI类似，只是计算亮度的方式不同</li><li>V：Value，表示颜色的亮度</li></ul><h3 id="01-3-2-HSV与RGB之间的转换">01.3.2.HSV与RGB之间的转换</h3><ul><li>$V=\dfrac{max(R,G,B)}{255}$</li></ul><h2 id="01-4-YUV">01.4.YUV</h2><h3 id="01-4-1-YUV">01.4.1.YUV</h3><ul><li>欧洲电视系统所采用的一种颜色编码</li><li>Y：亮度信号；U、V：色差信号</li></ul><h3 id="01-4-2-YUV与RGB之间的转换">01.4.2.YUV与RGB之间的转换</h3><ul><li>$Y=0.299R+0.587G+0.114B$</li><li>$U=-0.147R-0.289G+0.436B$</li><li>$V=0.615R-0.515G-0.100B$</li></ul><h3 id="01-4-3-YUV的优点">01.4.3.YUV的优点</h3><ul><li>采用YUV色彩空间，可以将亮度信号和色度信号分开处理，使得黑白电视机也能接收彩色信号</li><li>与RGB相比，最大的优点在于只需要占用极少的带宽，适合于传输和存储</li></ul><h2 id="01-5-YCbCr">01.5.YCbCr</h2><h3 id="01-5-1-YCbCr">01.5.1.YCbCr</h3><ul><li>DVD、DV摄像机、数字电视等消费类视频产品中广泛使用的一种颜色编码</li><li>Y：亮度信号；Cb：蓝色与参考值的差；Cr：红色与参考值的差</li></ul><h3 id="01-5-2-YCbCr与RGB之间的转换">01.5.2.YCbCr与RGB之间的转换</h3><p>$$<br>\begin{bmatrix} Y\\Cb\\Cr\end{bmatrix}=\begin{bmatrix}16\\128\\128\end{bmatrix}+\begin{bmatrix}0.257&amp;0.504&amp;0.098\\-0.148&amp;-0.291&amp;0.439\\0.439&amp;-0.368&amp;-0.071\end{bmatrix}\begin{bmatrix}R\\G\\B\end{bmatrix}<br>$$</p><h3 id="01-5-3-YCbCr与YUV的对比">01.5.3.YCbCr与YUV的对比</h3><ul><li>YUV：适合于模拟电视系统</li><li>YCbCr：适合于数字系统</li></ul><h2 id="01-6-彩色图像增强">01.6.彩色图像增强</h2><ol><li>单分量变化，亮度增强</li><li>单分量变化，饱和度增强</li><li>每个像素看作向量，以向量方式处理</li></ol><h1>零二、图像特征与理解</h1><h2 id="02-1-边界表示：链码">02.1.边界表示：链码</h2><h3 id="02-1-1-链码">02.1.1.链码</h3><ul><li>用一组数字序列来表示边界的形状</li><li>以右向为0，顺时针方向为正方向，为每个方向编码。分为：4方向链码、8方向链码</li><li>从边界最左上角的像素开始，按照逆时针方向，将边界上的像素点用链码表示</li><li>链码是一个循环序列</li></ul><p><img src="https://source.cclmsy.cc/Images/Posts/IP/IP12.png" alt=""></p><ul><li>上图的链码<ul><li>4方向链码：$00333332322121110101$</li><li>8方向链码：$07666553321202$</li></ul></li></ul><h3 id="02-1-2-链码归一化">02.1.2.链码归一化</h3><p>对链码进行循环右移，直到链码的字典序最小</p><h3 id="02-1-3-链码一阶差分">02.1.3.链码一阶差分</h3><p>对链码进行模下差分，即$x_i=(x_i-x_{i-1}+n)\mod n$（n为链码的方向数）</p><h2 id="02-2-二值图像的几何特征">02.2.二值图像的几何特征</h2><h3 id="02-2-1-位置">02.2.1.位置</h3><p>一般以物体面积的重心表示物体的位置<br>$$<br>\begin{cases}<br>x_c=\dfrac{1}{N}\sum\limits_{i=1}^N x_i\\\\<br>y_c=\dfrac{1}{N}\sum\limits_{i=1}^N y_i<br>\end{cases}<br>$$</p><h3 id="02-2-2-方向">02.2.2.方向</h3><ul><li>物体的方向：物体的主轴方向</li><li>确定主轴：（旋转）寻找最小外接矩形，主轴与矩形的长边平行</li></ul><h3 id="02-2-3-面积">02.2.3.面积</h3><p>物体的像素个数</p><h3 id="02-2-4-周长">02.2.4.周长</h3><ol><li>链码计算：$C=n_0+\sqrt{2}n_1$（$n_0$为偶数方向的个数，$n_1$为奇数方向的个数）</li><li>边界所占面积</li><li>边界的长度</li></ol><h3 id="02-2-5-形状">02.2.5.形状</h3><ol><li>矩形度：$R=\dfrac{A}{A_r}$（$A$为物体面积，$A_r$为最小外接矩形的面积）</li><li>宽长比：$W=\dfrac{W_r}{L_r}$（$W_r$为最小外接矩形的宽度，$L_r$为最小外接矩形的长度）</li><li>圆形度<ol><li>周长平方与面积的比值：$\dfrac{C^2}{A}$</li><li>面积与平均半径的比值：$\dfrac{A}{\bar{r}^2}$</li></ol></li><li>偏心率</li></ol><h2 id="02-3-形状描述子">02.3.形状描述子</h2><ul><li>傅里叶描述子</li><li>边界链码</li><li>微分链码</li></ul><h2 id="02-4-矩描述">02.4.矩描述</h2><h2 id="02-5-纹理分析：灰度共生矩阵">02.5.纹理分析：灰度共生矩阵</h2><p><img src="https://source.cclmsy.cc/Images/Posts/IP/IP13.png" alt=""></p><ul><li>数组合数量</li></ul><h1>考试重点</h1><ul><li><a href="#32%E7%81%B0%E5%BA%A6%E7%9B%B4%E6%96%B9%E5%9B%BE">3.2 灰度直方图</a></li><li><a href="#42%E5%9F%BA%E4%BA%8E%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA%E6%96%B9%E6%B3%95">4.2 基于直方图的图像增强方法</a><ul><li>直方图均衡化</li></ul></li><li><a href="#43%E5%9F%BA%E4%BA%8E%E7%A9%BA%E9%97%B4%E5%B9%B3%E6%BB%91%E6%BB%A4%E6%B3%A2%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA%E6%96%B9%E6%B3%95">4.3 基于空间平滑滤波的图像增强方法</a></li><li><a href="#44%E5%9F%BA%E4%BA%8E%E7%A9%BA%E9%97%B4%E9%94%90%E5%8C%96%E6%BB%A4%E6%B3%A2%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA%E6%96%B9%E6%B3%95">4.4 基于空间锐化滤波的图像增强方法</a></li><li><a href="#51%E7%A6%BB%E6%95%A3%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2discrete-fourier-transformdft">5.1 2D-DFT</a><ul><li>2D-DFT的性质</li><li>图像的傅里叶频谱图特性分析</li></ul></li><li><a href="#71%E7%A6%BB%E6%95%A3%E4%BD%99%E5%BC%A6%E5%8F%98%E6%8D%A2discrete-cosine-transformdct">7.1 DCT</a></li><li><a href="#73%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81">7.3 图像压缩编码</a><ul><li>Huffman编码</li></ul></li><li><a href="#74%E4%BD%8D%E5%B9%B3%E9%9D%A2%E7%BC%96%E7%A0%81">7.4 位平面编码</a></li><li><a href="#93%E5%9F%BA%E4%BA%8E%E9%98%88%E5%80%BC%E7%9A%84%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E6%96%B9%E6%B3%95">9.3 基于阈值的图像分割</a></li><li><a href="#94%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E6%96%B9%E6%B3%95">9.5 基于区域的图像分割</a></li><li><a href="#121%E4%BA%8C%E5%80%BC%E5%BD%A2%E6%80%81%E5%AD%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97">12.2 二值形态学基本运算</a></li><li><a href="#122%E4%BA%8C%E5%80%BC%E5%9B%BE%E5%83%8F%E7%9A%84%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86">12.2 二值图像的形态学处理</a></li></ul><h1>cv2/np</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv2.imread(filename, flag) <span class="comment"># 读取图像</span></span><br><span class="line"><span class="comment"># filename: str 图像文件名 &quot;lenna.jpg&quot;</span></span><br><span class="line"><span class="comment"># flag: int cv2.IMREAD_COLOR（默认彩色）、cv2.IMREAD_GRAYSCALE（灰度）</span></span><br><span class="line">img[:,:,] <span class="comment"># 行切片、列切片、通道（BGR）</span></span><br><span class="line">b,g,r = cv2.split(img) <span class="comment"># 分离通道 </span></span><br><span class="line">img_rgb = cv2.merge([r,g,b]) <span class="comment"># 合并通道</span></span><br><span class="line">img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) <span class="comment"># 转换为灰度图</span></span><br><span class="line">cv2.imshow(<span class="string">&quot;image&quot;</span>, img) <span class="comment"># 显示图像 </span></span><br><span class="line">cv2.waitKey() <span class="comment"># 等待键盘输入</span></span><br><span class="line">cv2.destroyAllWindows() <span class="comment"># 关闭所有窗口</span></span><br><span class="line"><span class="comment"># 求反色：255-原像素值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">400</span>,<span class="number">600</span>):</span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">400</span>,<span class="number">600</span>):</span><br><span class="line">         img[i,j] = [<span class="number">255</span>-img[i,j][<span class="number">0</span>],<span class="number">255</span>-img[i,j][<span class="number">1</span>],<span class="number">255</span>-img[i,j][<span class="number">2</span>]] </span><br><span class="line">img_cat = cv2.hconcat([r,g,b]) <span class="comment"># 从左到右水平拼接图像</span></span><br></pre></td></tr></table></figure><h1>plt</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">221</span>) <span class="comment"># 2行2列，第1个图</span></span><br><span class="line">plt.imshow(img) <span class="comment"># 显示图像</span></span><br><span class="line">plt.title(<span class="string">&#x27;Original&#x27;</span>) <span class="comment"># 图像标题</span></span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>) <span class="comment"># 关闭坐标轴</span></span><br><span class="line"></span><br><span class="line">hist = cv2.calcHist([img], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>//<span class="number">8</span>], [<span class="number">0</span>, <span class="number">256</span>]) </span><br><span class="line">plt.subplot(<span class="number">222</span>) <span class="comment"># 2行2列，第2个图</span></span><br><span class="line">plt.plot(hist) <span class="comment"># 绘制hist折线图（坐标0-31）</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">223</span>) <span class="comment"># 2行2列，第3个图</span></span><br><span class="line">plt.hist(img.ravel(), <span class="number">256</span>//<span class="number">8</span>, [<span class="number">0</span>, <span class="number">256</span>]) <span class="comment"># 绘制binwidth=8的直方图（坐标0-255）</span></span><br><span class="line"><span class="comment"># img.ravel()：将图像转换为一维数组</span></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《计算机组成原理》笔记</title>
      <link href="/posts/Note_Principle_of_Computer.html"/>
      <url>/posts/Note_Principle_of_Computer.html</url>
      
        <content type="html"><![CDATA[<h1>一、计算机系统概论</h1><h2 id="1-1-计算机系统简介">1.1 计算机系统简介</h2><h3 id="1-1-1-计算机系统的组成">1.1.1 计算机系统的组成</h3><ol><li>计算机由<strong>硬件</strong>与<strong>软件</strong>两部分组成</li><li>软件分为<strong>系统软件</strong>与<strong>应用软件</strong>两大类<ul><li>系统软件：管理整个计算机系统</li><li>应用软件：根据任务需要编制的程序</li></ul></li></ol><h3 id="1-1-2-计算机系统的层次结构">1.1.2 计算机系统的层次结构</h3><table><thead><tr><th>层次</th><th>说明</th></tr></thead><tbody><tr><td>应用层</td><td>用户直接使用的软件</td></tr><tr><td>高级语言机器$M_4$</td><td>高级语言编译成汇编语言</td></tr><tr><td>汇编语言机器$M_3$</td><td>汇编语言汇编成机器语言</td></tr><tr><td>操作系统机器$M_2$</td><td>用机器语言解释操作系统</td></tr><tr><td>机器语言机器$M_1$</td><td>用微程序解释机器指令</td></tr><tr><td>微程序机器$M_0$</td><td>用硬件直接执行微指令</td></tr></tbody></table><p>虚拟机器：$M_4$、$M_3$、$M_2$；实际机器：$M_1$；微程序机器：$M_0$</p><ul><li>机器语言、汇编语言、高级语言的区别<ul><li>机器语言是一种用二进制代码表示的计算机语言，机器可以直接执行用机器语言编写的程序。</li><li>汇编语言是一种用助记符表示的与机器语言一一对应的语言，用汇编语言编写的程序需经过汇编后才能执行。</li><li>高级语言是一种接近人类自然语言的与计算机结构无关的语言，用高级语言编写的程序要经过解释和编译才能执行。</li></ul></li></ul><h2 id="1-2-计算机的基本组成">1.2 计算机的基本组成</h2><h3 id="1-2-1-冯·诺依曼计算机的特点">1.2.1 冯·诺依曼计算机的特点</h3><ol><li>核心特征：存储程序的工作方式</li><li>计算机由五大功能部件组成：运算器、控制器、存储器、输入设备、输出设备<ul><li>运算器：完成算术运算和逻辑运算</li><li>控制器：控制程序的执行</li><li>存储器：存放指令和数据</li><li>输入输出设备：与外部环境交换信息</li></ul></li><li>指令和数据用二进制代码表示<ul><li>原因：<ol><li>二进制编码的运算规则简单</li><li>制造2个稳定状态的物理器件较容易</li><li>便于使用逻辑电路实现算术运算</li></ol></li></ul></li><li>工作原理：存储程序、程序控制<ul><li>存储程序程序控制方式：事先编写程序，再由计算机把这些程序存储起来，然后连续地、快速地执行程序，从而完成各种运算过程。</li><li>根据存储程序原理，计算机具有五大功能：数据传送、数据存储、数据处理、操作控制、操作判断</li></ul></li><li>基本工作方式：控制流驱动方式</li><li>指令和数据以同等地位存放在存储器中，可按地址寻访</li><li>指令由操作码和地址码组成</li><li>以运算器为中心</li></ol><h3 id="1-2-2-计算机的硬件框图">1.2.2 计算机的硬件框图</h3><p>改进：以存储器为核心<br><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC02.png" alt="冯·诺依曼计算机结构VS以存储器为中心的体系结构"><br>（实线：数据传输；虚线：指令传输）<br><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC01.png" alt="冯·诺依曼体系结构VS哈弗体系结构"></p><h2 id="1-3-计算机硬件的主要技术指标">1.3 计算机硬件的主要技术指标</h2><h3 id="1-3-1-字长">1.3.1 字长</h3><ul><li>机器字长：计算机一次能处理的二进制数的位数，通常与CPU的寄存器位数有关。等于ALU位数，直接影响数据总线和存储字长的位数</li><li>指令字长：计算机指令中二进制代码的总位数。</li><li>存储字长：存储器的一个存储单元中能存放的二进制数的位数。</li><li>三者可以相当也可以不等，视不同机器而定。</li></ul><h3 id="1-3-2-存储容量">1.3.2 存储容量</h3><ul><li>存储容量：计算机存储器中能存放的二进制数的位数</li><li>存储容量 = 主存+辅存 = 存储单元数×存储字长 （/8（字节））</li></ul><h3 id="1-3-3-存储器带宽">1.3.3 存储器带宽</h3><ul><li>存储器带宽：存储器的数据传输速率</li><li>存储器带宽=存储字数/存储周期（字/秒）</li><li>存储字长（字长）：一个存储单元中存放的二进制数的位数</li><li>字节：8位二进制数</li></ul><h3 id="1-3-4-运算速度">1.3.4 运算速度</h3><ol><li>CPI（Cycle Per Instruction）：每条指令的平均时钟周期数<ul><li>$CPI = CPU时钟周期数 \div 指令数（加权平均）$</li><li>注意平均指令周期（时间）与CPI（时钟周期数）的区别</li></ul></li><li>MIPS（Million Instructions Per Second）：每秒执行的百万条指令数<ul><li>$MIPS = \dfrac{指令条数N}{执行时间t×10^6} = \dfrac{主频f}{CPI\times 10^6}$</li></ul></li><li>主频f：CPU时钟频率；时钟周期T：CPU时钟周期</li><li>执行时间t：执行一组指令所需的时间<ul><li>$t = \dfrac{指令条数N\times CPI}{主频f}$ = $\dfrac{指令条数N}{MIPS\times 10^6}$</li></ul></li><li>每秒浮点运算次数：FLOPS（Floating Point Operations Per Second）</li></ol><h1>二、计算机发展史（了解）</h1><h1>三、系统总线</h1><h2 id="3-1-总线的基本概念">3.1 总线的基本概念</h2><h3 id="3-1-1-总线的作用">3.1.1 总线的作用</h3><ul><li>总线：连接各个部件的信息传输线，各个部件共享的传输介质</li><li>提供信息交换时所需的数据、地址、时序和控制信息</li><li>提供一个共同遵循的协议或标准</li></ul><h2 id="3-2-总线的分类（按连接部件）">3.2 总线的分类（按连接部件）</h2><ol><li>片内总线：CPU内部的总线</li><li>系统总线：CPU与其他部件之间的总线<ul><li>根据传输的信息划分：数据总线、地址总线、控制总线</li><li>数据总线：双向，位数与机器字长相关</li><li>地址总线：单向，位数与存储单元个数相关</li><li>控制总线：双向，传输控制信息</li></ul></li><li>通信总线：连接计算机与其它系统的总线</li></ol><h2 id="3-3-总线的特性与性能指标">3.3 总线的特性与性能指标</h2><h3 id="3-3-1-总线的特性">3.3.1 总线的特性</h3><ol><li>机械特性（物理特性）：总线的物理连接方式（根数、插口形状）</li><li>电气特性：传输方向、有效电平范围</li><li>功能特性：根据传输的信息划分（数据、地址、控制）</li><li>时间特性：同步、异步、功能复用</li></ol><h3 id="3-3-2-总线的性能指标">3.3.2 总线的性能指标</h3><ol><li>总线宽度：数据总线的位数</li><li>总线带宽：单位时间内传输的数据量（Bps：字节/秒）</li><li>总线时钟频率：总线的工作频率</li><li>总线复用</li><li>信号线数量</li><li>总线控制方式</li></ol><h2 id="3-4-总线结构">3.4 总线结构</h2><h3 id="3-4-1-总线事务">3.4.1 总线事务</h3><ol><li>总线事务：从请求总线到完成总线使用的操作序列</li><li>典型事务：存储器R/W，I/O-R/W，中断请求，DMA请求</li><li>典型事务操作：请求、仲裁、地址传输、数据传输、总线释放</li></ol><h3 id="3-4-2-单总线结构">3.4.2 单总线结构</h3><p><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC25.png" alt=""></p><ul><li>结构简单、使用方便、易扩充</li><li>统一编址、简化指令系统、存储空间减少</li><li>共享总线、分时使用、通讯速度慢</li><li>高速设备的高速性能得不到发挥</li></ul><h3 id="3-4-3-双总线结构1：增加CPU-主存的存储总线">3.4.3 双总线结构1：增加CPU-主存的存储总线</h3><p><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC26.png" alt=""></p><ul><li>存储总线有效的降低了系统总线的负载，提高了并行性能</li><li>需要增加专门的I/O指令，存储空间增加</li><li>结构简单、易扩充</li></ul><h3 id="3-4-4-双总线结构2：增加I-O总线">3.4.4 双总线结构2：增加I/O总线</h3><p><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC27.png" alt=""></p><h3 id="3-4-5-三总线结构">3.4.5 三总线结构</h3><p><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC28.png" alt=""></p><ul><li>高速与低速传输活动分离<ul><li>I/O设备与主存之间的通信和CPU活动分离</li><li>高速设备靠近CPU，低速设备远离CPU</li></ul></li><li>不同层次的总线之间采用桥接方式连接和缓冲</li></ul><h3 id="3-4-6-总线结构与设备性能之间的关系">3.4.6 总线结构与设备性能之间的关系</h3><ul><li>最大存储容量：单总线系统中，内存要为外部设备预留地址</li><li>指令系统：单总线结构无需专门的I/O指令</li><li>吞吐率：三总线系统比单总线系统大得多</li></ul><h3 id="3-4-7-采用南北桥结构的奔腾机系统总线结构">3.4.7 采用南北桥结构的奔腾机系统总线结构</h3><p><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC29.png" alt="南北桥结构"></p><ul><li>北桥靠近CPU，连接高速设备：主存、图形设备、CPU</li><li>南桥连接低速设备：I/O设备、硬盘、USB、网卡</li><li>南北桥之间通过PCI总线连接</li></ul><h2 id="3-5-总线控制">3.5 总线控制</h2><h3 id="3-5-1-信息传送方式">3.5.1 信息传送方式</h3><ol><li>串行传送<ul><li>位信息从低到高在一条传输线上逐位以脉冲方式传送</li><li>成本低、速度慢、传输距离远</li></ul></li><li>并行传送<ul><li>每位一条数据线，同时传送多位信息</li><li>速度快、传输距离短</li></ul></li><li>分时传送<ul><li>采用总线复用技术，地址数据共用</li><li>分时使用总线</li></ul></li></ol><h3 id="3-5-2-总线判优控制（总线仲裁）">3.5.2 总线判优控制（总线仲裁）</h3><ul><li>总线仲裁：多个设备同时请求总线时，由总线控制器判定哪个设备优先使用总线</li><li>根据总线控制部件的位置，仲裁方式分为两类：集中式、分布式</li></ul><table><thead><tr><th>集中式仲裁</th><th>链式查询方式</th><th>计数器定时查询方式</th><th>独立请求方式</th></tr></thead><tbody><tr><td>控制线</td><td>3根：总线状态BS，总线请求BR，总线授权BG</td><td>$2+log_2n$根：总线状态BS，总线请求BR，地址计数线（$log_2n$根）</td><td>$2n$根：总线请求BR（$n$根），总线授权BG（$n$根）</td></tr><tr><td>响应速度</td><td>慢</td><td>慢</td><td>快</td></tr><tr><td>优先级</td><td>固定</td><td>可适当变化</td><td>可灵活调整</td></tr><tr><td>故障敏感性</td><td>敏感</td><td>不敏感</td><td>不敏感</td></tr><tr><td>扩展性</td><td>容易</td><td>困难</td><td>容易</td></tr></tbody></table><h3 id="3-5-3-总线定时">3.5.3 总线定时</h3><ul><li>总线定时主要解决通信双方如何获知传输开始和传输结束，通信双方如何配合的问题</li><li>同步方式：用公共时钟信号对传输过程的每一步进行控制，适合快速设备<ul><li>无应答方式</li><li>事件时刻由总线时钟信号决定，采用公共时钟，数据传输率高</li><li>木桶效应：必须按照最慢的设备定时</li></ul></li><li>异步方式：用应答信号对传输过程进行控制。又分为非互锁、半互锁和全互锁；适合慢速设备<ul><li>不互锁<ul><li>主模块：发出请求一段时间，认为副模块收到请求，撤销请求并通信</li></ul></li><li>半互锁<ul><li>主模块：发出请求，收到副模块应答后撤销请求并通信</li><li>副模块：收到请求后应答一段时间，认为主模块收到应答，撤销应答并通信</li></ul></li><li>全互锁<ul><li>主模块：发出请求，收到副模块应答后撤销请求并通信</li><li>副模块：收到请求后应答，收到主模块撤销请求后撤销应答并通信</li></ul></li></ul></li><li>半同步方式：结合同步方式和异步方式的特点，在同步时钟的控制下进行采样和应答</li><li>分离式通信</li></ul><h2 id="3-5-4-总线通讯控制-总线传输过程">3.5.4 总线通讯控制/总线传输过程</h2><ol><li>总线申请（总线仲裁）：部件提出请求，总线控制器确定将下一个总线使用权分配给谁</li><li>地址阶段（总线寻址）：主设备通过总线发出从部件的存储器地址或I/O端口地址及相关命令，启动从设备</li><li>数据传输阶段</li><li>结束阶段：主部件撤消总线请求等有关信息，总线控制器释放总线</li></ol><h2 id="3-6-例题">3.6 例题</h2><ol><li>假定某总线的时钟周期为50ns,每次总线传输需要1个时钟周期，总线宽度为32位，存储器的存储周期为300ns,求同步方式下从该存储器中读一个字时总线的数据传输率为多少?<ul><li>同步方式下按顺序进行以下步骤：<ol><li>送地址和读命令：1个总线周期 = 50ns</li><li>存储器读数据：300ns</li><li>总线传输数据：1个总线周期 = 50ns</li></ol></li><li>一个字的总时间：$50+300+50=400ns$</li><li>数据传输率：$32bit/8/400ns=10MBps$</li></ul></li><li>系统总线传输的信息类型为：数据、地址、控制信号<ul><li>握手应答信号是通信总线传输的信息类型！</li></ul></li><li>提高同步总线数据传输速率的方法<ol><li>增加总线宽度</li><li>增加总线时钟频率</li><li>支持突发传输</li></ol><ul><li>地址/数据线复用不能提高数据传输速率</li></ul></li><li>主存通过<strong>总线类型</strong>识别地址和数据</li></ol><h1>四、存储器</h1><h2 id="4-1-概述">4.1 概述</h2><h3 id="4-1-1-存储器的分类">4.1.1 存储器的分类</h3><ol><li>按存储介质分类<ul><li>半导体存储器（易失性：断电即失）<ul><li>TTL：高速</li><li>MOS：高集成度、低功耗、低成本、应用广泛</li></ul></li><li>磁表面存储器：磁头+磁载体</li><li>磁芯存储器：体积大、功耗大、工艺复杂</li><li>激光存储器：CD、DVD</li></ul></li><li>按存取方式分类<ul><li>物理地址和存取时间无关（随机访问）<ul><li>随机存储器（RAM） 可读可写<ul><li>SRAM（静态RAM）：速度快、价格高、集成度低</li><li>DRAM（动态RAM）：速度慢、价格低、集成度高</li></ul></li><li>只读存储器（ROM）<ul><li>M：Masked（掩模）；P：Programmable（可编程）；E：Erasable（可擦写）；EE：Electrically-Erasable（电可擦写）</li></ul></li></ul></li><li>物理地址和存取时间有关（串行访问）<ul><li>顺序存储器：磁带</li><li>直接存储器：磁盘</li></ul></li></ul></li><li>按在计算机中的作用分类<ul><li>$<br>存储器\begin{cases}<br>主存\begin{cases}<br>随机存储器（RAM）\begin{cases}<br>SRAM \\<br>DRAM<br>\end{cases} \\<br>只读存储器（ROM）\begin{cases}<br>MROM\\<br>PROM\\<br>EPROM\\<br>EEPROM<br>\end{cases}<br>\end{cases}\\<br>闪速存储器（Flash Memory）\\<br>辅助存储器\begin{cases}<br>磁盘\\<br>磁带\\<br>光盘<br>\end{cases}\\<br>缓存（Cache）<br>\end{cases}<br>$</li></ul></li></ol><h3 id="4-1-2-存储器的层次结构">4.1.2 存储器的层次结构</h3><ol><li>存储系统的层次结构（自上到下从内到外） <figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CPU寄存器</span><br><span class="line">缓存<span class="keyword">Cache</span>（SRAM）（内存）</span><br><span class="line">主存储器（DRAM） （内存）</span><br><span class="line">磁盘 （辅助存储器）</span><br><span class="line">磁带、光盘 （辅助存储器）</span><br></pre></td></tr></table></figure></li><li>存储器的主要特性（自上到下）</li></ol><ul><li>速度：快 -&gt; 慢<ul><li>存储时间、存取周期、存储带宽</li></ul></li><li>容量：小 -&gt; 大</li><li>价格：贵 -&gt; 便宜</li></ul><ol start="3"><li>存储器的层次结构的作用</li></ol><ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC03.png" alt="存储器的层次结构"></li><li>缓存-主存层次：解决CPU与主存之间速度不匹配的问题<ul><li>透明：对系统程序员和应用程序员屏蔽</li><li>主存储器、实地址、物理地址</li></ul></li><li>主存-辅存层次：解决存储系统的容量问题<ul><li>不透明：系统程序员可以对此层次进行修改</li><li>虚拟存储器、虚地址、逻辑地址</li></ul></li></ul><ol start="4"><li>存储系统为什么采用分层体系结构？<ul><li>采用层次化存储体系的目的包括两方面：其一是解决快速的CPU和慢速的主存之间的速度差异；其二是解决主存容量不够大的问题。存储系统的分级结构由Cache、主存和辅助存储器三级结构构成。其理论基础是时间局部性原理和空间局部性原理，Cache—主存存储层次解决了主存速度不快的问题；而主存-辅存存储层次解决了主存容量不足的问题。</li></ul></li></ol><h2 id="4-2-主存储器">4.2 主存储器</h2><h3 id="4-2-1-概述">4.2.1 概述</h3><ol><li>主存的基本组成<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC05.png" alt=""></li><li>存储体：存储数据</li><li>MAR：存储器地址寄存器，保存要访问的存储单元地址<ul><li>经过译码器进行译码，选定存储单元</li></ul></li><li>MDR：存储器数据寄存器，存储要写入或读出的数据<ul><li>通过读写电路和控制电路控制数据的读写</li></ul></li></ul></li><li>主存中存储单位地址分配方式<ul><li>子地址+字节地址</li><li>大端存储（大尾存储）：<code>0x12345678</code>存储为<code>12 34 56 78</code></li><li>小端存储（小尾存储）：<code>0x12345678</code>存储为<code>78 56 34 12</code></li><li>（小格中顺序正常，大格中顺序颠倒） 小端存储例：x86</li><li>n根地址线可按字节寻址$2^n$个字节（按字寻址按比例计算）</li></ul></li><li>主存中的数据组织和边界对齐</li></ol><ul><li>寄巧：每种数据类型的数据存储在存储器中的<strong>起始地址</strong>必须是该数据所占字节数的<strong>整数倍</strong></li></ul><ol><li>主存储器的技术指标<ol><li>字长：一个存储单元存放的二进制数的位数</li><li>存储容量：存储器中能存放的二进制数的总位数</li></ol><ul><li>存储容量=存储单元数×存储字长（位）/8（字节）</li></ul><ol start="3"><li>存储速度：由存取周期表示</li></ol><ul><li>存取周期：连续2次存取所需的最小时间间隔</li><li>分为读周期和写周期</li></ul><ol start="4"><li>存储器带宽=存储字数/存储周期（字/秒）=(存储字数*存储字长)/8/存储周期（字节/秒）</li></ol></li></ol><h3 id="4-2-2-半导体存储芯片">4.2.2 半导体存储芯片</h3><ol><li>基本结构与芯片容量<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC13.png" alt="半导体存储芯片"></li><li>例：地址线10位；数据线8位</li><li>存储单元：$2^{10}$个；存储字长：8位；芯片容量：$2^{10}\times 8=1K*8位=8Kbit=1KB$</li><li>片选线CS/CE：选择芯片Chip Select/Enable</li><li>读写控制线WE/OE：读写控制Write/Output Enable</li></ul></li><li>译码驱动方式<ul><li>单译码结构：$n$位地址输入，经$n$位译码器译码，指向$2^n$个存储单元</li><li>双译码结构：将存储芯片阵列，分为行译码和列译码，指向$2^{2n}$个存储单元<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC04.png" alt="静态存储器芯片结构"></li><li>地址译码器：将二进制地址译码为存储单元的物理地址（类比3-8线译码器）</li><li>Y向驱动器：将地址译码后的列地址送到存储矩阵的列选择线</li></ul></li></ul></li></ol><h3 id="4-2-3-随机存取存储器（RAM）">4.2.3 随机存取存储器（RAM）</h3><ol><li>SRAM（静态RAM）<ol><li>存储原理：触发器<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC06.png" alt="SRAM存储单元"></li><li>中心与GND相连的T1, T2：存储数据</li><li>中心与VCC相连的T3, T4：补充电荷</li><li>外侧的T5-T8：T5、T6行选，T7、T8列选</li></ul></li><li>SRAM芯片（以Intel 2114为例）<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC14.png" alt="SRAM芯片"></li><li>地址线：$A_{9-0}$，地址数=$2^{10}$个</li><li>数据线：$I/O_{3-0}$，数据位数=$4$位</li><li>芯片存储容量=$2^{10}\times 4bit=1K\times 4bit$</li></ul></li><li>SRAM的不足<ul><li>晶体管数量多，集成度低，功耗大</li></ul></li></ol></li><li>DRAM（动态RAM）<ol><li>分单管式和三管式，存储原理：电容</li><li>DRAM的优点</li></ol><ul><li>存储密度高，集成度高，功耗低</li><li>速度慢，需要刷新</li></ul><ol start="3"><li>DRAM刷新<ol><li>刷新：DRAM存储单元中的电荷会逐渐泄漏，需要定期刷新补充</li><li>刷新周期：存储器两次完整刷新之间的时间间隔</li><li>刷新方式：集中式、分散式、异步式（假设刷新周期为2ms）<ul><li>集中式<ul><li>一个刷新间隔（2ms）：|-----R/W/维持-----|—集中刷新n行—|</li><li>在数据丢失之前集中刷新所有行</li><li>保持存储单体的高速特性，存在死区（死时间）</li><li>死区=存取周期*刷新行数，死时间率=死区/刷新间隔</li><li>场景：实时性要求不高</li></ul></li><li>分散式<ul><li>一个刷新间隔（小于2ms）：|R/W|刷新第0行|R/W|刷新第1行|…|R/W|刷新第n行|</li><li>存储周期=读写+刷新：各刷新周期分散安排在存取周期中</li><li>过度刷新，通常刷新间隔远小于所需最大刷新间隔，芯片性能下降</li><li><strong>不存在死区</strong></li></ul></li><li>异步式<ul><li>一个刷新间隔（2ms）：|R/W|R/W|…|R/W|刷新第0行|R/W|R/W|…|R/W|刷新第n行|</li><li>每行每隔一定时间/多次读写后刷新一次，（平均）分散在一个刷新间隔的任意部分</li><li>存在死区，但可以将刷新安排在指令译码阶段</li></ul></li></ul></li></ol></li></ol></li><li>SRAM与DRAM的比较</li></ol><table><thead><tr><th></th><th>SRAM</th><th>DRAM</th></tr></thead><tbody><tr><td>存储原理</td><td>触发器</td><td>电容</td></tr><tr><td>集成度</td><td>低</td><td>高</td></tr><tr><td>刷新</td><td>不需要</td><td>需要</td></tr><tr><td>存储成本（功耗）</td><td>高</td><td>低</td></tr><tr><td>速度</td><td>快（无需重写）</td><td>慢（需重写）</td></tr><tr><td>破坏性读出</td><td>非</td><td>是</td></tr><tr><td>送行列地址</td><td>同时</td><td>分2次</td></tr><tr><td>主要用途</td><td>Cache高速缓存</td><td>主存</td></tr></tbody></table><h3 id="4-2-4-只读存储器（ROM）">4.2.4 只读存储器（ROM）</h3><p>MROM：Masked（掩模）<br>PROM：Programmable（可编程）<br>EPROM：Erasable P（可擦写可编程）<br>EEPROM：Electrically-Erasable P（电可擦写可编程）<br>Flash Memory：闪速存储器</p><h3 id="4-2-5-主存与CPU的连接方式（不考察）">4.2.5 主存与CPU的连接方式（不考察）</h3><ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC07.png" alt="主存与CPU的连接方式"></li><li>$MREQ(存储器请求)\Rightarrow CS(片选线)$</li><li>$A_{17-0}(地址线)\Rightarrow A$：存储单元数=$2^{18-10} K$个</li><li>$R/W(读写控制)\Rightarrow WE(写使能)$</li><li>$D_{31-0}(数据线)\Rightarrow D$：数据位数=$32$位</li></ul><h3 id="4-2-6-存储器容量扩展（不考察）">4.2.6 存储器容量扩展（不考察）</h3><ul><li>位扩展（DBUS）：增加存储字长<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC08.png" alt="位扩展"></li><li>方法：<ul><li>MREQ、A同时连接$n$个芯片</li><li>R/W同时连接所有RAM芯片</li><li>D位数扩展到原来的$n$倍，按顺序分配给每个芯片</li></ul></li><li>特点：<ul><li>从每个芯片内部相同的地址单元中读取数据，同时读写</li><li>位扩展后的存储容量=单元数×（字长×片数）</li></ul></li></ul></li><li>字扩展（ABUS）：增加存储单元数<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC09.png" alt="字扩展"></li><li>方法：<ul><li>D同时连接$n$个芯片</li><li>R/W同时连接所有RAM芯片</li><li>MREQ连接到3-8译码器的OE</li><li>A位数增加$log_2n$，原来的部分与每一片连接，增加的部分分配给3-8译码器</li><li>3-8译码器的输出连接到$n$个芯片的CS（片选）</li></ul></li><li>特点：<ul><li>从单个芯片（组）中的地址单元中读取数据</li><li>字扩展后的存储容量=（单元数×片数）×字长</li></ul></li></ul></li><li>字位综合扩展：同时增加存储单元数和存储字长<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC10.png" alt="字位扩展"></li><li>方法：<ul><li>R/W同时连接所有RAM芯片组</li><li>D位数扩展到原来的$n$倍，连接每个芯片组</li><li>MREQ连接到3-8译码器的OE</li><li>A位数增加$log_2n$，原来的部分与每一片连接，增加的部分分配给3-8译码器</li><li>3-8译码器的输出连接到$n$个芯片的CS（片选）</li></ul></li></ul></li><li>例：存储器容量扩展<ul><li>需求：<ul><li>0x0000到3FFF为ROM存储区域</li><li>0x4000到0x5FFF为保留地址区域</li><li>0x6000到0xFFFF为RAM地址区域</li><li>RAM的控制信号为CS#和WE#，CPU地址线A15~A0，数据线D7~D0，控制信号有读写控制R/W#和访存请求MREQ#</li></ul></li><li>材料：16K×8 ROM 4K×8 RAM</li><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC11.png" alt="存储器容量扩展"></li><li>注意：<ul><li>译码器一位信号对应两片芯片时，高位地址（$A_{12}$）参与片选</li><li>译码器两位信号对应一片芯片时，信号取或传入片选</li></ul></li><li>不同区域选择芯片类型：<ul><li>系统程序区域：ROM</li><li>保留区域：无需选择</li><li>用户程序区域：RAM</li></ul></li></ul></li></ul><h3 id="4-2-7-优化主存性能的方法">4.2.7 优化主存性能的方法</h3><ol><li>采用高速器件：SDRAM（同步DRAM）</li><li>增加Cache：采用层级结构 Cache-主存 （CDRAM）</li><li>双端口存储器</li></ol><ul><li>具有两个独立的读写控制线</li><li>地址不冲突时，可并行读写</li></ul><ol start="4"><li>增加字长、每个存储周期存取多个字：单体多字存储器（位扩展）</li></ol><ul><li>多个单字长存储器并行工作</li><li>共用一个地址寄存器</li><li>单存储周期内访问多个存储字</li></ul><ol start="5"><li>将主存分为多个模块，并行存取：多体并行存储器</li></ol><ul><li>高位交叉、顺序编址（顺序方式）（字扩展）</li><li>低位交叉、轮流编址（交叉方式）<ul><li>流水线式存储：<ul><li>总线传输周期$\tau$，存储周期$T$，交叉模数$m$</li><li>流水线方式存储的条件：$T=m\tau$</li><li>连续传输n个字的时间：$T+(n-1)\tau$</li></ul></li><li>存储体数量：不小于$\dfrac{存储周期}{总线传输周期}$</li></ul></li><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC12.png" alt="多模块存储器"></li></ul><table><thead><tr><th></th><th>高位交叉</th><th>低位交叉</th></tr></thead><tbody><tr><td>相邻数据地址</td><td>同一存储体</td><td>不同存储体</td></tr><tr><td>地址寄存器</td><td>一个</td><td>每个存储体一个</td></tr><tr><td>局部性原理</td><td>高位片选，多模块串行</td><td>低位片选，多模块并行</td></tr><tr><td>性能</td><td>无提升</td><td>提升</td></tr><tr><td>故障隔离</td><td>方便</td><td>-</td></tr><tr><td>连续读取$n$个字的时间</td><td>$nT$</td><td>$T+(n-1)\tau$</td></tr></tbody></table><h2 id="4-3-高速缓存存储器Cache">4.3 高速缓存存储器Cache</h2><h3 id="4-3-1-概述">4.3.1 概述</h3><ol><li>Cache解决的问题</li></ol><ul><li>避免CPU“空等”状态</li><li>弥补CPU与主存的速度差异</li></ul><ol start="2"><li>程序访问的局部性原理</li></ol><ul><li>时间局部性：刚访问过的数据很可能马上再次访问</li><li>空间局部性：刚访问过的数据附近的数据很可能马上访问</li><li>优化手段：调度算法（时间局部性）；预读优化（空间局部性）</li></ul><ol start="3"><li>Cache的工作原理</li></ol><ul><li>主存地址：n位=m位主存块号+b位块内地址（字地址）</li><li>Cache地址：c位Cache块号+b位块内地址（c &lt;&lt; m）</li><li>按块存储，块大小相同</li><li>命中（HIT）：Cache中有所需数据</li><li>缺失（MISS）：Cache中无所需数据，需要从主存中读取</li><li>标记记录某缓存块对应的主存块号</li></ul><ol start="4"><li>命中率、访问时间、访问效率</li></ol><ul><li>记$N$为访问次数，$N_c$为命中次数，$N_m$为缺失次数（访问主存次数）；$t_c$为Cache存取时间，$t_m$为主存存取时间</li><li>命中率：$h=\dfrac{N_c}{N}$ / 缺失率：$1-h$</li><li>平均访问时间：$t_{avg}=ht_c+(1-h)t_m$</li><li>访问效率：$E=\dfrac{t_c}{t_{avg}}$</li></ul><ol start="5"><li>关键技术</li></ol><ul><li>数据查找、地址映射、替换策略、写入策略</li></ul><ol start="6"><li>Cache的读操作</li></ol><ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC15.png" alt="Cache的读操作"></li></ul><ol start="7"><li>Cache的写操作</li></ol><ul><li>写穿法（Write Through）：写Cache同时写主存<ul><li>优点：维持了主存和Cache的数据一致性</li><li>缺点：写主存次数多，在连续多次更新同一数据时效率低</li></ul></li><li>写回法（Write Back）：只写Cache，标记为脏，被替换时才写回主存<ul><li>优点：减少了写主存次数，提高了效率</li><li>缺点：需要额外的标记位和判断，增加了Cache复杂度</li></ul></li></ul><ol start="8"><li>Cache的改进</li></ol><ul><li>增加Cache级数（CPU片内、片外）</li><li>统一Cache（指令、数据共用）和分立Cache（指令、数据分开）</li></ul><h3 id="4-3-2-Cache-主存地址映射">4.3.2 Cache-主存地址映射</h3><ol><li>直接映射</li></ol><ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC16.png" alt="直接映射"></li><li>根据Cache块数对主存块号取模，只能存放在对应模数的位置</li><li>主存地址n位=t位标记位+c位Cache块号+b位块内地址（t+c=m）</li></ul><ol start="2"><li>全相联映射（主存容量大考虑采用）</li></ol><ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC17.png" alt="全相联映射"></li><li>任意主存块可以存放在任意Cache块中</li><li>主存地址n位=m位标记位+b位块内地址</li></ul><ol start="3"><li>组相联映射</li></ol><ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC18.png" alt="组相联映射"></li><li>组间直接映射，组内全相联映射，先分组</li><li>组数$2^q$，组内Cache块数$2^r$，$q+r=c$</li><li>主存地址n位=(t+r)位标记位+q(c-r)位组号+b位块内地址</li></ul><table><thead><tr><th></th><th>直接映射</th><th>全相联映射</th><th>组相联映射</th></tr></thead><tbody><tr><td>冲突</td><td>最容易</td><td>最不容易</td><td>中等</td></tr><tr><td>Cache利用率</td><td>低</td><td>高</td><td>中等</td></tr><tr><td>淘汰算法</td><td>无</td><td>需要</td><td>需要</td></tr></tbody></table><h3 id="4-3-3-Cache的替换策略">4.3.3 Cache的替换策略</h3><ol><li>先进先出（FIFO）</li></ol><ul><li>优点：易实现、开销小</li><li>缺点：未考虑局部性原理，被替换的数据再次被访问</li></ul><ol start="2"><li>近期最少使用（Least Recently Used，LRU）</li></ol><ul><li>优点：减少了被替换的数据再次被访问的概率，提高了命中率</li></ul><ol start="3"><li>随机法</li></ol><h2 id="4-4-存储器的校验">4.4 存储器的校验</h2><ol><li>概述</li></ol><ul><li>存储器校验的意义：解决编码在时间、空间上传输可靠性问题；减少基于软件检错的代价</li><li>码距：两个合法码之间的不同位数。<ul><li>码距越大，抗干扰能力、纠错能力越强，数据冗余越大，编码效率越低</li></ul></li><li>检错和纠错：检错位数=码距//2，纠错位数=（码距-1）//2</li></ul><ol start="2"><li>奇偶校验（以偶校验为例）</li></ol><ul><li>待传输数据：$D_1D_2D_3D_4D_5D_6D_7D_8$</li><li>校验位：$P=D_1\oplus D_2\oplus D_3\oplus D_4\oplus D_5\oplus D_6\oplus D_7\oplus D_8$（奇校验取反）</li><li>发送与接收的数据：$D_1D_2D_3D_4D_5D_6D_7D_8P$（末尾加校验码）</li><li>检错码：$G=D_1\oplus D_2\oplus D_3\oplus D_4\oplus D_5\oplus D_6\oplus D_7\oplus D_8\oplus P$<ul><li>$G=0$，无错；$G=1$，有错</li></ul></li><li>码距：2</li><li>检1位错，纠0位错</li></ul><ol start="3"><li>汉明校验</li></ol><ul><li>待传输数据：$D_n…D_3D_2D_1$</li><li>增加校验位$P$数量：$k$，$2^k\geq n+k+1$ （$n=4$时，$k=3$）</li><li>校验位$P_i$处于$2^{i-1}$位置，即传输数据：$H_{7-1}=D_4D_3D_2P_3D_1P_2P_1$</li><li>校验位$P_i$为位置下标二进制第$i$位为1的数据（除自己外）的异或和。<ul><li>$P_1= H_3\oplus H_5\oplus H_7=D_1\oplus D_2\oplus D_4$</li><li>$P_2= H_3\oplus H_6\oplus H_7=D_1\oplus D_3\oplus D_4$</li><li>$P_3= H_5\oplus H_6\oplus H_7=D_2\oplus D_3\oplus D_4$</li></ul></li><li>检错码$G_i$为位置下标二进制第$i$位为1的数据的异或和。<ul><li>$G_1=H_1\oplus H_3\oplus H_5\oplus H_7=P_1\oplus D_1\oplus D_2\oplus D_4$</li><li>$G_2=H_2\oplus H_3\oplus H_6\oplus H_7=P_2\oplus D_1\oplus D_3\oplus D_4$</li><li>$G_3=H_4\oplus H_5\oplus H_6\oplus H_7=P_3\oplus D_2\oplus D_3\oplus D_4$</li></ul></li><li>每一组数据都是一次偶校验</li><li>检错码的排列$G_3G_2G_1$所示的二进制数表示出错的位置</li><li>码距：3</li><li>检1位错，纠1位错</li><li>实现检2位错<ul><li>开头增加一个总偶校验位$P_4=H_1\oplus H_2\oplus H_3\oplus H_4\oplus H_5\oplus H_6\oplus H_7$</li><li>检错码：$G_4=P_4\oplus H_1\oplus H_2\oplus H_3\oplus H_4\oplus H_5\oplus H_6\oplus H_7$</li></ul></li><li>优点<ul><li>编码效率高：数据增加一倍，校验位增加1位</li><li>可纠正1位错，检错2位错</li></ul></li></ul><ol start="4"><li>CRC循环冗余校验</li></ol><ul><li>待传输数据：$1100$</li><li>约定一个$r+1$位二进制数$1011$（r=3）</li><li>将待传输数据左移$r$位，得到$1100|000$</li><li>做模二除法，做减法时做异或，余数首位为1时商上1</li><li>$1100000\div1011=1110\cdots 010$其中余数$010$是校验位</li><li>$1100|000$和余数$010$相加，得到传输数据$D=1100|010$</li><li>接收方将接收到的数据$D$除以约定的数$1011$，余数为0则无错</li></ul><h2 id="4-5-辅助存储器-外存储器">4.5 辅助存储器/外存储器</h2><h3 id="4-5-1-概述">4.5.1 概述</h3><ul><li>磁表面存储器、硬盘存储器、光盘存储器</li><li>特点；容量大、速度慢、价格低、长期存储、非破坏性读出</li><li>原理：电磁变换</li></ul><h3 id="4-5-2-磁表面存储器的技术指标">4.5.2 磁表面存储器的技术指标</h3><ol><li>记录密度</li></ol><ul><li>道密度$D_t(TPI)$</li><li>位密度$D_b(BPI)$</li><li>面密度$D_s=D_t\times D_b$</li></ul><ol start="2"><li>$圆柱面数N_c=(外径R-内径r)\times F_t$</li><li>$磁道长度l=2\pi r(内径)$</li><li>$存储容量C=l\times D_b\times N_c\times 盘面数$</li><li>$寻址时间/定位时间T_a=寻道时间t_s+等待时间t_w$</li><li>数据传输率$D_r$：单位时间传输的数据量</li><li>误码率：$\dfrac{错误位数}{总位数}$，通常用CRC校验纠正</li></ol><h3 id="4-5-3-硬磁盘存储器">4.5.3 硬磁盘存储器</h3><ol><li>类型</li></ol><ul><li>固定磁头/移动磁头</li><li>可换盘/固定盘</li></ul><ol start="2"><li>结构</li></ol><ul><li>$主机\Leftrightarrow 磁盘控制器\Leftrightarrow 磁盘驱动器\Leftrightarrow 磁盘盘片$</li></ul><ol start="3"><li>磁盘控制器：主机与磁盘驱动器之间的接口</li></ol><ul><li>功能：数据传输、数据校验、磁盘调度、磁盘格式化</li></ul><h3 id="4-5-4-软盘存储器">4.5.4 软盘存储器</h3><table><thead><tr><th></th><th>硬盘</th><th>软盘</th></tr></thead><tbody><tr><td>速度</td><td>快</td><td>慢</td></tr><tr><td>磁头</td><td>固定/活动、浮动</td><td>固定、接触盘片</td></tr><tr><td>盘片</td><td>固定、盘组、大部分不可换</td><td>可换盘片</td></tr><tr><td>价格</td><td>高</td><td>低</td></tr><tr><td>工作环境</td><td>苛刻</td><td></td></tr></tbody></table><h3 id="4-5-5-光盘存储器">4.5.5 光盘存储器</h3><ul><li>采用光存储技术，利用激光读写</li><li>第一代：非磁性介质、不可擦写</li><li>第二代：磁性介质、可擦写</li><li>只读型/只写一次型：热作用</li><li>可擦写型：热磁效应</li></ul><h1>五、输入输出系统</h1><h2 id="5-1-概述">5.1 概述</h2><h3 id="5-1-1-输入输出系统的发展概况">5.1.1* 输入输出系统的发展概况</h3><ol><li>早期阶段<ul><li>分散连接</li><li>CPU与I/O设备 串行工作</li><li>程序查询方式</li></ul></li><li>接口模块和DMA阶段<ul><li>总线连接</li><li>CPU与I/O设备 并行工作</li><li>中断方式/直接存储器访问（DMA）</li></ul></li><li>具有通道结构的阶段</li><li>具有I/O处理机的阶段</li></ol><h3 id="5-1-2-输入输出系统的组成">5.1.2* 输入输出系统的组成</h3><ol><li>I/O软件<ul><li>I/O指令：CPU指令的部分。 操作码|命令码|设备码<ul><li>操作码：I/O指令的标志，指出该指令是I/O指令</li><li>命令码：指出I/O操作的类型：输入、输出、状态测试、控制</li><li>设备码：指出I/O设备的地址（端口号）</li></ul></li><li>通道指令<ul><li>通道：具有特殊功能的处理器IOP</li><li>指出要传输的字节数、数据地址、操作命令</li></ul></li></ul></li><li>I/O硬件<ul><li>接口方式：设备、I/O接口：设备通过接口连接到总线，和主机进行数据交换</li><li>通道方式：设备、设备控制器、通道</li></ul></li></ol><h3 id="5-1-3-I-O设备与主机的联系方式">5.1.3 I/O设备与主机的联系方式</h3><ol><li>外设分类<ul><li>按功能：输入设备、输出设备</li><li>按速度：低速设备、中速设备、高速设备</li><li>按作用：人机交互设备、外存储器设备、通信设备</li></ul></li><li>I/O设备的编址方式<ul><li>统一编址方式：将I/O设备看作是内存地址的一部分，共用地址空间，指令集相对简单</li><li>不统一编址方式：内存之外专设I/O设备地址空间，有专门的I/O指令集</li></ul></li><li>设备寻址：通过设备选择电路</li><li>传送方式：串行、并行</li><li>联络方式/外围设备定时方式<ul><li>立即响应方式（极慢的设备）</li><li>异步工作采用应答信号联络（慢速和中速设备）</li><li>同步工作采用同步时标联络（高速设备）</li></ul></li><li>I/O设备和主机的连接方式<ul><li>辐射式（分散连接）：每台设备都配有独立的控制电路和信号线</li><li>总线式：便于增删设备</li></ul></li></ol><h2 id="5-2-I-O端口">5.2 I/O端口</h2><ol><li>设置I/O端口的原因<ul><li>外部设备工作的异步性：外部设备工作的时钟和时序与微处理器不同</li><li>速度差异：外部设备的速度远远低于微处理器</li><li>信号线与数据格式不同</li><li>便于外设发展</li></ul></li><li>I/O端口的功能<ul><li>实现数据缓冲</li><li>执行CPU的命令返回外设状态</li><li>设备选择</li><li>数据格式、信号的转换</li><li>中断管理</li></ul></li><li>I/O接口的组成<ul><li>基本电路：寄存器及逻辑控制</li><li>端口地址译码电路</li><li>供选电路：可选器件</li></ul></li></ol><h2 id="5-3-I-O控制方式-信息交换方式-总览">5.3 I/O控制方式 / 信息交换方式 总览</h2><ol><li>程序查询方式<ul><li>$启动设备\Rightarrow 反复查询设备状态直至设备准备好\Rightarrow 传输单个数据\Rightarrow 结束设备$</li><li>信息交换完全由CPU执行程序实现</li><li>串行工作、反复查询、系统效率低</li><li>用于早期计算机系统</li></ul></li><li>程序中断方式<ul><li>$CPU发起指令\Rightarrow 设备准备数据+CPU处理其他进程\Rightarrow 设备准备好数据，向CPU发出中断请求\Rightarrow CPU响应中断$</li><li>主动告知避免反复查询</li><li>仍需CPU占用</li><li>一次中断传输数据少，CPU开销大</li></ul></li><li>直接存储器存取（DMA）方式<ul><li>适用于成组数据传输</li><li>传输阶段DMAC从CPU接管总线，直接在内存及外设之间进行，节约了中断开销</li><li>需要更多硬件</li></ul></li><li>通道方式<ul><li>通道：具有特殊功能的处理器IOP，独立于CPU，分担I/O处理，可实现外设的统一管理和DMA操作</li><li>通道执行通道程序来完成CPU指定的I/O任务，通道程序是由一系列通道指令组成的</li></ul></li></ol><h2 id="5-4-程序中断方式">5.4 程序中断方式</h2><ol><li><p>中断概念</p><ul><li>中断：CPU暂时中止现行程序的执行，转去执行为某个随机事件服务的中断处理子程序，处理完后自动恢复原程序的执行</li><li>作用：实现CPU与I/O设备的并行工作、故障处理等</li></ul></li><li><p>中断的分类</p><ul><li>$<br>中断\begin{cases}<br>内中断（异常）：来自CPU内部\begin{cases}<br>软件中断\\<br>异常\begin{cases}<br>故障Fault\\<br>陷阱Trap\\<br>终止Abort<br>\end{cases}<br>\end{cases} \\<br>外中断（强迫中断）：来自CPU外部\begin{cases}<br>不可屏蔽中断NMI：由系统内部硬件引发的中断\\<br>可屏蔽中断INTR：由外设通过中断请求线向处理器申请<br>\end{cases}<br>\end{cases}<br>$</li></ul></li><li><p>中断系统基本功能</p><ol><li>中断请求的保持和清除：硬件实现</li><li>中断仲裁：多个中断请求同时到达时，确定优先级</li><li>中断源识别：获取中断号（识别中断源）</li><li>中断处理</li><li>中断控制</li></ol><ul><li>中断触发方式：边沿触发、电平触发</li><li>中断排队方式：优先级高先服务</li></ul></li><li><p>单级中断和多级中断</p><ul><li>单级中断：所有中断同级，离CPU近的优先，处理中断时不响应其他中断</li><li>多级中断：优先级高的中断可打断优先级低的中断，中断嵌套</li></ul></li><li><p>优先级划分一般规律</p><ul><li>硬件中断最高，程序错误中断其次</li><li>NMI&gt;INTR</li><li>DMA&gt;I/O</li><li>高速设备&gt;低速设备</li><li>输入设备&gt;输出设备</li><li>实时设备&gt;非实时设备</li></ul></li><li><p>中断屏蔽字与优先级设定</p><ul><li>以A,B,C为例，设定优先级B&gt;C&gt;A</li><li>A：100；B：111；C：101</li><li>0所在的位置表示允许被该位中断</li></ul></li><li><p>缺点</p><ol><li>传输一次数据就要中断一次，CPU开销大</li><li>效率低，不适合高速传输系统</li></ol></li></ol><h2 id="5-5-DMA（直接存储器存取）方式">5.5 DMA（直接存储器存取）方式</h2><ol><li>优点<ul><li>外设与主存间建立一个由硬件管理的数据通路</li><li>CPU不介入外设与主存的数据传输</li><li>减少CPU开销，提高系统效率</li></ul></li><li>内存争用： DMA控制器和CPU可能同时访问内存<ol><li>DMA访内过程中，停止CPU访问内存<ul><li>DMA批量数据传输周期过长，CPU长期无法访内</li><li>外设传送两个数据的时间间隔大于存储周期，内存未充分利用</li></ul></li><li>DMA与CPU交替访问内存<ul><li>每个CPU工作周期分成两段：DMA访内和CPU访内</li><li>无主存使用权移交过程</li></ul></li><li>周期挪用法<ul><li>DMA要求访问主存时，CPU暂停一个或多个存储周期。一个数据传送结束后，CPU继续运行。</li></ul></li></ol></li></ol><h1>六、计算机的运算方法</h1><h1>6.1 无符号数和有符号数</h1><h2 id="6-1-1-无符号数">6.1.1 无符号数</h2><p>按照规定的长度（字长）以二进制保存，只有数值部分，没有符号位。</p><h2 id="6-1-2-有符号数">6.1.2 有符号数</h2><ol><li>机器数与真值<ul><li>机器数：计算机内部表示的数</li><li>真值：数的实际值</li><li>四种机器码：原码、反码、补码、移码<ul><li>最高位表示符号：0为正，1为负</li><li>其余位表示数值</li><li>小数的定点表示：原码、反码、补码</li></ul></li></ul></li><li>原码<ul><li>整数：数值位表示小数点前的整数部分</li><li>小数：数值位表示小数点后的小数部分（绝对值小于1）</li><li>特点：<ol><li>有+0(0,000)和-0(1,000)两种0</li><li>加、减运算方式不统一，符号相异不能直接计算</li></ol></li></ul></li><li>反码<ul><li>正数：原码</li><li>负数：其正数原码的各位取反</li><li>特点：<ol><li>有+0(0,000)和-0(1,111)两种0</li><li>运算较复杂</li></ol></li></ul></li><li>补码<ul><li>正数：原码</li><li>负数：反码+1</li><li>特点：<ol><li>0有唯一的表示方式</li><li>加、减运算方式统一</li><li>机器数的唯一表示</li><li>小数可以表示-1(1.000)</li></ol></li><li>补码运算：<ol><li>$[[X]_补]_补=-(-X)=X$</li><li>//2：右移1位，最高位补符号位（正数补0，负数补1）</li><li>*2：左移1位，最低位补0，符号位变化即为溢出</li><li>不同位数加减法：位数少的数，高位补符号位直至位数相同，然后按位加减</li></ol></li></ul></li><li>移码<ul><li>补码的符号位取反</li><li>保持数据原有的大小顺序，便于比较</li><li>仅用于表示整数，通常用于浮点数的阶码</li></ul></li></ol><h1>6.2 小数的浮点表示（原码表示）</h1><ol><li>表示格式<ul><li>$N=S\times r^j$</li><li>S：尾数（小数）；r：基数($2^k$)；j：阶码（二进制表示）</li><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC19.png" alt="浮点数表示"></li><li>$S_f$：浮点数的符号</li><li>$n$：决定浮点数的精度</li><li>$m$：决定浮点数的表示范围</li></ul></li><li>规格化数<ul><li>基数$r=2^k$时</li><li>尾数$S$的最高的$k$位（小数点后$k$位）不全为0</li><li>特别的，$r=2$时，S=0.1xxxxxx</li><li>尾数左右移动$k$位，阶码变化$1$</li></ul></li><li>表示范围<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC20.png" alt="浮点数表示范围"></li><li>尾数$S$：$0,[2^{-n},1-2^{-n}]$</li><li>阶码$j$：$[-2^m+1,2^m-1]$</li><li>表示范围：$[-(1-2^{-n})\times 2^{2^m-1},-(2^{-n})\times 2^{-2^m+1}],0,[2^{-n}\times 2^{-2^m+1},(1-2^{-n})\times 2^{2^m-1}]$</li></ul></li><li>机器0<ul><li>尾数$S=0$的数：x,xxxx;0.0000000000</li><li>阶码小于等于精度（$-2^m+1,-15$）的数：1,0000(-16);x.xxxxxxxxxx</li><li>阶码用移码时，机器$0$为：0,0000;0.0000000000</li></ul></li><li>IEEE754 Standard<ul><li>构成：符号位$m_s$（数符），阶码$E$（含阶符，移码表示，基数为2），尾数$M$（隐去开头的1，原码表示）</li><li>$(-1)^{m_s}\times 1.M\times 2^E$</li><li>偏置值：阶码的移码与原码的差值（$2^{k-1}-1$）</li></ul></li></ol><table><thead><tr><th></th><th>符号位</th><th>阶码</th><th>尾数</th><th>总位数</th></tr></thead><tbody><tr><td>单精度float</td><td>1</td><td>8</td><td>23</td><td>32</td></tr><tr><td>双精度double</td><td>1</td><td>11</td><td>52</td><td>64</td></tr><tr><td>临时实数</td><td>1</td><td>15</td><td>64</td><td>80</td></tr></tbody></table><h1>6.3 定点运算</h1><h2 id="6-3-1-移位运算">6.3.1 移位运算</h2><ol><li>算术移位与逻辑移位<ul><li>算术移位：符号位不变</li><li>逻辑移位：左移右移补0</li></ul></li><li>算术移位添补</li></ol><table><thead><tr><th>正负</th><th>码值</th><th>添补</th></tr></thead><tbody><tr><td>+</td><td>原码、反码、补码</td><td>补0</td></tr><tr><td>-</td><td>原码</td><td>补0</td></tr><tr><td>-</td><td>反码</td><td>补1</td></tr><tr><td>-</td><td>补码</td><td>左移补0，右移补1</td></tr></tbody></table><ol start="3"><li>丢失有效位<ul><li>左移丢高位：溢出</li><li>右移丢低位：损失精度</li></ul></li></ol><h2 id="6-3-2-加减法运算">6.3.2 加减法运算</h2><ol><li>补码加减运算公式<ol><li>加法：$[A]_补+[B]_补=[A+B]_补$</li><li>减法：$[A]_补-[B]_补=[A+(-B_补)]_补=[A]_补+[-B]_补$</li><li>连同符号位一起相加，溢出位舍去</li><li>真实溢出：正正得负/负负得正</li></ol></li><li>硬件实现<ol><li>串行加法器：逐位相加，进位传递<ol><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC21.png" alt="串行加法器"></li><li>缺点：高位依赖低位，速度慢</li><li>$S_i=X_i\oplus Y_i\oplus C_{i-1}$</li><li>$C_i=X_iY_i+X_iC_{i-1}+Y_iC_{i-1}=X_iY_i+(X_i\oplus Y_i)C_{i-1}$</li></ol></li><li>并行加法器：每一位并行计算<ol><li>原理<ol><li>记：<ul><li>$G_i=X_iY_i$：生成位（Generate）</li><li>$P_i=X_i\oplus Y_i$：传递位（Propagate）</li></ul></li><li>则：<ul><li>$C_i = G_i + P_iC_{i-1}$</li></ul></li><li>传递得到：<ul><li>$C_i = G_i + P_iG_{i-1} + P_iP_{i-1}G_{i-2} + \cdots + P_iP_{i-1}\cdots P_1C_0$</li><li>$以i=4为例，C_4 = G_4 + P_4G_3 + P_4P_3G_2 + P_4P_3P_2G_1 + P_4P_3P_2P_1C_0$</li></ul></li><li>记：<ul><li>$G_4^* = G_4 + P_4G_3 + P_4P_3G_2 + P_4P_3P_2G_1$：组进位生成位</li><li>$P_3^* = P_4P_3P_2P_1$：组进位传递位</li><li>$C_4 = G_4^* + P_4^*C_0$：组进位传递函数</li></ul></li><li>$S_i=P_i\oplus C_{i-1}$</li></ol></li><li>1级门电路延迟-与门异或门电路：计算$G_i,P_i$<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC22.png" alt="1级门电路"></li></ul></li><li>2级门电路延迟-先行进位电路：计算$C_i$<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC23.png" alt="2级门电路"></li></ul></li><li>四位快速加法器<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC24.png" alt="四位快速加法器"></li></ul></li></ol></li></ol></li></ol><h2 id="6-3-3-乘法运算">6.3.3 乘法运算</h2><ul><li>思想：移位相加</li></ul><h3 id="6-3-3-1-原码乘法">6.3.3.1 原码乘法</h3><ul><li>符号位：单独计算</li><li>数值位：从$Y$的最低位开始，逐位决定$SUM$是否加$X$，然后$Sum$右移一位。</li></ul><p><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC30.png" alt="原码乘法"></p><h3 id="6-3-3-2-（重点）补码乘法：Booth算法">6.3.3.2 （重点）补码乘法：Booth算法</h3><ul><li>给定：$[X]_补,[Y]_补$，求$[X]_补\times [Y]_补$</li></ul><ol><li>求$[-X]_补$，$[Y]_补$最后补一位0</li><li>当前$Y$的末2位$Y_{-2}Y_{-1}$决定$SUM$加$X,0,-X$的哪一个<ul><li>$SUM+=X\times (Y_{-1}-Y_{-2})=\begin{cases}<br>0 &amp; Y_{-2}Y_{-1}=00\\<br>X &amp; Y_{-2}Y_{-1}=01\\<br>-X &amp; Y_{-2}Y_{-1}=10\\<br>0 &amp; Y_{-2}Y_{-1}=11<br>\end{cases}$</li></ul></li><li>右移$SUM$，左边补符号位</li><li>去掉$Y$的最低位，重复步骤2-3，直到$Y$只剩1位</li></ol><p><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC31.png" alt="补码乘法"></p><h2 id="6-3-4-除法运算">6.3.4 除法运算</h2><h3 id="6-3-4-1-恢复余数法">6.3.4.1 恢复余数法</h3><ul><li>给定：$[X]_补,[Y]_补$，求$[X]_补\div [Y]_补$（$X,Y$为正数）</li></ul><ol><li>求$[-Y]_补$</li><li>计算$X+=(-Y)$</li><li>若双符号位为$11$，即$X$为负数，不够减，则该位为$0$，恢复余数：$X+=Y$</li><li>若双符号位为$00$，即$X$为正数，够减，该位为$1$</li><li>$X$左移一位，右边补0</li><li>重复步骤2-5，直到$X$左移$4$位（$Y$的位数）</li><li>当前的余数为$X\times 2^{-4}$</li></ol><p><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC32.png" alt="恢复余数法"></p><h3 id="6-3-4-2-重点-非恢复余数法-加减交替法">6.3.4.2 (重点)非恢复余数法/加减交替法</h3><ul><li>给定：$[X]_补,[Y]_补$，求$[X]_补\div [Y]_补$（$X,Y$为正数）</li></ul><ol><li>求$[-Y]_补$</li><li>若双符号位为$00$，即$X$为正数，计算$X+=(-Y)$（第一次必定做减法）</li><li>若双符号位为$11$，即$X$为负数，计算$X+=Y$</li><li>若双符号位为$00$，即$X$为正数，该位为$1$</li><li>若双符号位为$11$，即$X$为负数，该位为$0$</li><li>$X$左移一位，右边补0</li><li>重复步骤2-6，直到$X$左移$4$位（$Y$的位数）</li><li>当前的余数为$X\times 2^{-4}$</li></ol><p><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC33.png" alt="非恢复余数法"></p><h1>6.4 浮点运算</h1><p><a href="#62-%E5%B0%8F%E6%95%B0%E7%9A%84%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA%E5%8E%9F%E7%A0%81%E8%A1%A8%E7%A4%BA">规格化浮点数</a></p><h2 id="6-4-1-浮点加减法">6.4.1 浮点加减法</h2><p>例：<br>$$<br>X=2^{E_x}M_x=2^{101}\times 0.11011011 \\<br>Y=2^{E_y}M_y=2^{111}\times-0.10101100<br>$$<br>尾数在计算机中以补码表示，可存储10位尾数，2位符号位，阶码以补码表示，双符号位, 求$X+Y$</p><h3 id="6-4-1-1-将X-Y转化为带符号的浮点补码格式">6.4.1.1 将X,Y转化为带符号的浮点补码格式</h3><p>$$<br>X=00101,00.11011011 \\<br>Y=00111,11.01010100(-0.10101100)<br>$$</p><h3 id="6-4-1-2-对阶">6.4.1.2 对阶</h3><ul><li>原则：小阶对大阶</li></ul><ol><li>计算$[-E_y]_补=11001$</li><li>计算阶差$E=E_x+(-E_y)=00101+11001=11110=-2(D)&lt;0$</li><li>$X$是小阶，$M_x$右移$|E|=2$位：$M_x=00.0011011011$，$E=111$</li><li>$X=00111,00.0011011011$</li></ol><h3 id="6-4-1-3-尾数求和-差">6.4.1.3 尾数求和/差</h3><p>$$M=M_x+M_y=00.0011011011+11.01010100=11.1000101011 \\<br>X+Y=00111,11.1000101011<br>$$</p><h3 id="6-4-1-4-结果规格化">6.4.1.4 结果规格化</h3><ul><li>双符号位为$11$，是负数，规格化到小数点后一位为$0$。（本题中，$M$双符号位为$11$）</li><li>双符号位为$00$，是正数，规格化到小数点后一位为$1$。</li><li>结果左移一位得到：<br>$$<br>X+Y=00110,11.000101011<br>$$</li><li>尾数溢出时可能需要尾数右移</li></ul><h3 id="6-4-1-5-舍入处理">6.4.1.5 舍入处理</h3><ul><li>0舍1入：$X+Y=00111,11.00010110$</li><li>截断：$X+Y=00111,11.00010101$</li></ul><h3 id="6-4-1-6-得出结果">6.4.1.6 得出结果</h3><p>$$<br>X+Y=00110,11.00010101 \\<br>=2^{110}\times -0.11101011<br>$$</p><h3 id="6-4-1-7-溢出判断">6.4.1.7 溢出判断</h3><p>根据阶码的双符号位进行判断：</p><ul><li>01：正溢出</li><li>10：负溢出</li></ul><h2 id="6-4-2-浮点乘法-除法">6.4.2 浮点乘法/除法</h2><ul><li>乘法：尾数定点相乘，阶码相加</li><li>除法：尾数定点相除，阶码相减</li></ul><h1>七、指令系统</h1><h1>7.0 基本概念</h1><ol><li>指令：计算机能直接识别、执行的操作命令（机器指令）；冯诺依曼结构“程序控制”原理实现的载体</li><li>指令集：一台计算机能执行的全部指令的集合</li><li>等长指令（MIPS）/变长指令（x86）</li><li>指令系统的特点：完备、高效、规整、兼容</li><li>为什么说“指令系统是计算机系统硬件与软件之间的界面”？<ul><li>从程序的编写与执行角度看，指令规定了计算机的操作类型及操作数地址，它们是产生各种控制信号的基础。</li><li>从硬件设计角度看，在设计计算机的时候先要确定硬件能够直接执行哪些操作，表现为一组指令集合，称之为计算机的指令系统。</li><li>因此，指令系统体现了一台计算机的软、硬件界面。</li></ul></li></ol><h1>7.1 机器指令</h1><h2 id="7-1-1-指令的一般格式">7.1.1 指令的一般格式</h2><p>$操作码OP|(寻址模式Mode)|地址码A_1|地址码A_2|\cdots$</p><ol><li>操作码字段：反映机器（对什么数据）做什么操作<ol><li><ul><li>定长操作码：总操作种类=2^k</li><li>变长操作码：操作码向不用的地址码字段扩展</li></ul></li><li>扩展操作码技术<ul><li>假设二操作数指令格式为：$OP(4)|A_1(6)|A_2(8)$ 15条</li><li>只保留全1为长操作数的锚点，那么：<ul><li>单操作数指令格式可以为：$1111|OP(6)|A_1(8)$ 63条</li><li>无操作数指令格式可以为：$1111|111111|OP(8)$ 256条</li></ul></li><li>原则：短操作码不能是长操作码的前缀</li><li>可以根据实际指令数量，通过保留多个锚点，识别更多的操作码：<ul><li>假设二操作数指令有10条，则可以保留6个锚点</li><li>可用于单操作数指令的条数变为$6\times 2^6$ 条</li><li>按需分配后剩下的可以作为无操作数指令的锚点</li></ul></li><li>例题：设某指令系统指令字长16位，每个地址码为6位。若要求设计二地址指令15条、一地址指令34条，问最多还可设计多少条零地址指令？<ul><li>指令格式：$OP(4)|A_1(6)|A_2(6)$</li><li>二地址指令条数15，保留锚点数$2^4-15=1$</li><li>一地址指令条数34，保留锚点数$1\times 2^6 - 34 = 30$</li><li>零地址指令条数：$30\times 2^6 = 1920$</li></ul></li></ul></li><li>经常使用的操作设计为短操作码，不常用的设计为长操作码</li></ol></li><li>操作数字段（地址码字段）：<ul><li>四地址指令（$OP|A_1|A_2|A_3|A_4$）：$(A_1)OP(A_2)\rightarrow A_3$，下一条指令位于$A_4$</li><li>三地址指令（$OP|A_1|A_2|A_3$）：$(A_1)OP(A_2)\rightarrow A_3$，下一条指令位于$PC+1$（利用$PC$代替$A_4$）</li><li>二地址指令（$OP|A_1|A_2$）：$(A_1)OP(A_2)\rightarrow AC$，下一条指令位于$PC+1$（利用$AC$代替$A_3$）</li><li>一地址指令（$OP|A_1$）：$(A_1)OP(AC)\rightarrow AC$，下一条指令位于$PC+1$（利用$AC$代替$A_2,A_3$）</li><li>零地址指令（$OP$）：基本的无操作数操作指令，如空操作、停机、中断、返回等</li><li>访存次数：取指令1次+读取操作数次数+存结果到操作数次数（若存入AC则不计）</li><li>直接寻址范围：$2^k$，k是单个地址码位数</li><li>减少操作数个数的优点：<ol><li>利用硬件资源代替地址码字段</li><li>扩大指令的寻址范围</li><li>缩短指令字长</li></ol></li></ul></li></ol><h2 id="7-1-2-指令字长">7.1.2 指令字长</h2><ol><li>指令字长决定于：</li></ol><ul><li>操作码的长度</li><li>操作数地址的长度</li><li>操作数的个数</li></ul><ol start="2"><li><ul><li>定长指令：指令字长=存储字长</li><li>变长指令：通常按字节的倍数存储</li></ul></li></ol><h1>7.2* 操作数类型和操作类型</h1><h2 id="7-2-1-操作数类型">7.2.1 操作数类型</h2><ol><li>地址：用于表示地址的无符号整数</li><li>数字：定点数、浮点数、十进制数</li><li>字符：ASCII</li><li>逻辑：逻辑数据/运算</li></ol><h2 id="7-2-2-数据在存储器中的存储方式">7.2.2 数据在存储器中的存储方式</h2><ul><li>边界对齐/边界不对齐</li><li>大端存储/小端存储</li></ul><h2 id="7-2-3-操作类型">7.2.3 操作类型</h2><p>1.数据传送 2.算术/逻辑运算 3.移位运算 4.控制转移</p><h1>7.3 寻址方式</h1><h2 id="7-3-1-指令寻址">7.3.1 指令寻址</h2><ol><li>顺序寻址：通过程序计数器PC+指令占用字节数，自动生成下一条指令地址<ul><li>PC的变化时机：每当CPU从存储器中读取出一个字节时，PC+1</li></ul></li><li>跳跃寻址：通过指令中的转移类操作，跳转到指定地址</li></ol><h2 id="7-3-2-数据寻址">7.3.2 数据寻址</h2><p>$操作码OP|(寻址模式Mode)|地址码A_1|地址码A_2|\cdots$</p><p>记：形式地址$D$/寄存器地址$R$、实际地址$E$、实际操作数$S$、基址/变址寄存器$B$、解地址符号$()$</p><ol><li>隐含寻址：操作数地址隐含在操作码或寄存器中（有利于减少指令字长）</li><li>立即寻址：操作数直接在指令中给出（补码，形式地址位数限制了范围）$S=D$</li><li>直接寻址：操作数在存储器中，地址码在指令中给出 $E=D$</li><li>寄存器寻址：操作数在寄存器中，寄存器编号在指令中给出 $E=R$</li><li>间接寻址：地址码指向的存储器中存放的地址是操作数的地址（二级指针）$E=(D),S=((D))$<ul><li>优点：减少指令字长，增加寻址范围，方便编程</li><li>缺点：两次访存，速度慢，已淘汰</li></ul></li><li>寄存器间接寻址：地址码（寄存器编号）指向的寄存器中存放的地址是操作数地址（应用广泛）$E=®$</li><li>相对寻址：操作数地址=PC+偏移量 $E=D+(PC)$</li><li>基址/变址寻址：操作数地址=基址/变址+偏移量（可以指定通用寄存器作为基址/变址寄存器）$E=D+(B)$</li><li>堆栈寻址：操作数地址=栈顶指针寄存器SP<ul><li>入栈：SP-1（上移），存入数据</li><li>出栈：取出数据，SP+1（下移）</li><li>单次变化量取决于主存编址方式：<ul><li>按字编址：$SP\pm 1$</li><li>按字节编址存储字长32位：$SP\pm 4(32/8)$</li></ul></li></ul></li></ol><h1>7.4 指令格式分析与设计</h1><h2 id="7-4-1-指令格式分析">7.4.1 指令格式分析</h2><p>例：$OP(15-12)|Mode(11-9)|Reg(8-6)|Mode(5-3)|Reg(2-0)$</p><ol><li>二地址指令</li><li>操作码：最多支持16种指令</li><li>寻址方式：源数据和目的数据都最多支持8种寻址方式</li><li>寄存器个数：源地址和目的地址都最多支持8个寄存器</li><li>可寻址范围：<ul><li>直接寻址范围：$2^3=8$（寄存器地址）</li><li>间接寻址范围：默认存储字长=指令字长，$2^{16}=64K$（存储器地址）</li></ul></li></ol><h1>7.5 RISC/CISC</h1><ul><li>CISC：复杂指令集计算机（Complex Instruction Set Computer）</li><li>RISC：精简指令集计算机（Reduced Instruction Set Computer）</li><li>80-20规律：经典程序中80%的指令只使用了处理机指令集20%的指令</li></ul><table><thead><tr><th></th><th>CISC</th><th>RISC</th></tr></thead><tbody><tr><td>指令系统</td><td>复杂、庞大</td><td>简单、精简</td></tr><tr><td>指令数目</td><td>一般&gt;200</td><td>一般&lt;100</td></tr><tr><td>指令字长</td><td>变长</td><td>定长</td></tr><tr><td>寻址方式</td><td>多</td><td>少</td></tr><tr><td>访存指令</td><td>不限</td><td>只有LOAD/STORE</td></tr><tr><td>单条指令执行时间</td><td>相差较大</td><td>多数在一个周期内</td></tr><tr><td>各指令使用频度</td><td>相差较大</td><td>都较常用</td></tr><tr><td>通用寄存器数量</td><td>较少</td><td>多</td></tr><tr><td>目标代码</td><td>难以优化</td><td>优化编译生成高效代码</td></tr><tr><td>控制方式</td><td>大多为微程序控制</td><td>大多为硬布线控制</td></tr></tbody></table><h1>八、CPU的结构和功能</h1><h1>8.0 基本概念</h1><ol><li>CPU的功能（控制器：1~4，ALU：5）<ol><li>程序控制：控制程序的顺序执行</li><li>操作控制：产生完成每条指令所需的控制命令</li><li>时序控制：对各种操作实施时间上的控制</li><li>异常控制：处理中断</li><li>数据加工：对数据进行算术运算和逻辑运算</li></ol></li><li>CPU的组成：<ol><li>专用寄存器以及通用寄存器:程序控制元生成各种微操作命令序列</li><li>算术逻辑单元ALU：进行算术运算和逻辑运算</li><li>控制器：中断系统用于处理各种中断</li></ol></li><li>数据通路分为：共享通路（总线型）、专用通路（看作多总线型）</li></ol><h1>8.1 CPU的结构</h1><ol><li>寄存器</li><li>ALU</li><li>控制单元和中断系统<ul><li>控制器的基本功能：取指令、分析指令、执行指令</li></ul></li></ol><h1>8.2 指令周期</h1><p>指令周期：去除并执行一条指令所需要的全部时间</p><ol><li>取址周期：取指令的时间</li><li>间址周期：用于间址寻址取操作数</li><li>执行周期：执行指令，存取操作数和结果的时间</li><li>中断周期：CPU采用中断方式实现主机和I/O设备的通信时，发送中断信号的时间</li></ol><p><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC34.png" alt="指令周期"></p><ul><li>提高机器速度的方法<ol><li>提高访存速度：高速芯片、Cache、多体并行</li><li>提高I/O和主机之间的传输速度：中断、DMA、I/O处理机、多总线</li><li>提高CPU的运算速度：高速芯片、改进算法、快速进位链</li></ol></li></ul><h1>8.3 指令流水线</h1><p>指令流水线：将指令执行过程分为多个阶段，使多条指令在不同阶段同时执行（并行性）</p><h2 id="8-3-1-影响流水线性能的因素">8.3.1 影响流水线性能的因素</h2><ol><li>结构相关：不同指令争用同一功能部件产生资源冲突</li><li>数据相关：不同指令因重叠操作，可能改变操作数的读/写访问顺序<ul><li>读后写/写后读/写后写</li></ul></li><li>控制相关：分支指令的执行可能改变程序计数器的值，导致流水线中的其他指令失效</li></ol><h2 id="8-3-2-流水线性能">8.3.2 流水线性能</h2><ol><li>吞吐率$T_p$：单位时间内完成的指令数/输出结果的数量<ul><li>设$m$段流水线的各段时间为$\Delta t$</li><li>最大吞吐率：$\dfrac{1}{\Delta t}$</li><li>实际吞吐率：连续处理$n$条指令的吞吐率：$\dfrac{n}{(m+n-1)\Delta t}$</li></ul></li><li>加速比$S_p$：流水线处理速度与非流水线处理速度的比值<ul><li>加速比=原处理时间/流水线处理时间&gt;1</li><li>连续处理$n$条指令的加速比：$S_p=\dfrac{nm\Delta t}{(m+n-1)\Delta t}=\dfrac{mn}{m+n-1}$</li></ul></li><li>效率$E_p$：流水线中各功能段的利用率<ul><li>由于流水线有建立时间和排空时间 ，因此各功能段的设备不可能一直处于工作状态</li><li>$E_p=\dfrac{实际工作的时空区域}{总时空区域}=\dfrac{n}{m+n-1}$</li></ul></li></ol><h2 id="8-3-3-流水线的多发技术">8.3.3 流水线的多发技术</h2><ol><li>超标量技术：多个流水线并行执行多条指令</li><li>超流水线技术：将流水线分为多个较短的段，提高吞吐率</li><li>超长指令字技术VLIW：将多条能够并行操作的指令组合成一条指令，提高吞吐率</li></ol><h2 id="8-3-4-流水线结构">8.3.4 流水线结构</h2><ol><li>指令流水线：取指令、指令译码、地址形成、取操作数、操作执行、写回结果</li><li>运算流水线（浮点数）：对阶功能、尾数相加、规格化</li></ol><h1>8.4 指令周期与时序</h1><ul><li>时钟周期=节拍脉冲=震荡周期：完成一次微操作的时间</li><li>机器周期=CPU周期：从主存读出一条指令的<strong>最短时间</strong></li><li>指令周期：从主存取一条指令到执行完毕的时间</li></ul><p><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC35.png" alt="时序"></p><h1>8.5 控制器设计</h1><table><thead><tr><th></th><th>硬布线控制器</th><th>微程序控制器</th></tr></thead><tbody><tr><td>逻辑</td><td>同步逻辑</td><td>存储逻辑</td></tr><tr><td>特点</td><td>繁、快、贵</td><td>简、慢、廉</td></tr><tr><td>更改</td><td>难</td><td>易</td></tr></tbody></table><h2 id="8-5-1-硬布线控制器">8.5.1 硬布线控制器</h2><ol><li>设计时序产生器：根据固定机器周期、节拍数固定构建状态图</li><li>画出指令周期流程图</li><li>找控制信号产生条件</li><li>写出逻辑表达式</li><li>化简表达式</li><li>利用组合逻辑电路实现</li></ol><p>优化：有限状态机、异步控制</p><p>特点：</p><ul><li>结构复杂、无规则</li><li>设计和调试困难</li><li>不可改变指令系统和功能</li><li>速度快、成本高</li></ul><h2 id="8-5-2-微程序控制器">8.5.2 微程序控制器</h2><p>（计组实验相关）</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024牛客寒假06</title>
      <link href="/posts/ACM_2024Winter_NCD06.html"/>
      <url>/posts/ACM_2024Winter_NCD06.html</url>
      
        <content type="html"><![CDATA[<h1>A.宇宙的终结</h1><p><strong>1签</strong></p><h2 id="题意">题意</h2><p>在$[1,100]$中给定的某个区间内找到一个数，它是$3$个不同素数的积。</p><h2 id="解题思路">解题思路</h2><p>打出$100$以内素数表，然后暴力枚举判定。</p><p>手算也行，$100$以内答案只有$30,42,66,70,78$。</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ll&gt; phi=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,<span class="number">53</span>,<span class="number">59</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">79</span>,<span class="number">83</span>,<span class="number">89</span>,<span class="number">97</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pend</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;p:phi)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x%p==<span class="number">0</span>) &#123; cnt++; x/=p; &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=<span class="number">3</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="keyword">if</span>(x==<span class="number">1</span>&amp;&amp;cnt==<span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll l,r;cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,l,r) <span class="keyword">if</span>(<span class="built_in">pend</span>(i)) &#123;cout &lt;&lt; i &lt;&lt; endl;<span class="keyword">return</span>;&#125; </span><br><span class="line">    cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ll&gt; ans=&#123;<span class="number">30</span>,<span class="number">42</span>,<span class="number">66</span>,<span class="number">70</span>,<span class="number">78</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll l,r;cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:ans) <span class="keyword">if</span>(x&gt;=l&amp;&amp;x&lt;=r) &#123;cout &lt;&lt; x &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.爱恨的纠葛</h1><p><strong>思维</strong></p><h2 id="题意-2">题意</h2><p>给定$2$个长度为$n$的数组$a,b$。调整$a$数组使得$|a_i-b_i|$的最小值最小。</p><h2 id="解题思路-2">解题思路</h2><p>在$a,b$中分别找到一个数，它们的差的绝对值最小。</p><p>对数组$a$排序，在数组$a$中二分查找$b_i$的最近邻，记录差的绝对值最小的一对的下标$i,j$，最后把$a_i$和$a_j$交换使这一对在同一位置。</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span>,<span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cin &gt;&gt; b[i];</span><br><span class="line">    <span class="built_in">SORT</span>(a);</span><br><span class="line">    ll mindif=INF,idxa=<span class="number">-1</span>,idxb=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> it=<span class="built_in">upper_bound</span>(<span class="built_in">ALL</span>(a),b[i]);</span><br><span class="line">        <span class="keyword">if</span>(it!=a.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            t=<span class="built_in">abs</span>(b[i]-*it);</span><br><span class="line">            <span class="keyword">if</span>(t&lt;mindif)</span><br><span class="line">            &#123;</span><br><span class="line">                mindif=t;</span><br><span class="line">                idxa=i;</span><br><span class="line">                idxb=it-a.<span class="built_in">begin</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(it!=a.<span class="built_in">begin</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            it--;</span><br><span class="line">            t=<span class="built_in">abs</span>(b[i]-*it);</span><br><span class="line">            <span class="keyword">if</span>(t&lt;mindif)</span><br><span class="line">            &#123;</span><br><span class="line">                mindif=t;</span><br><span class="line">                idxa=i;</span><br><span class="line">                idxb=it-a.<span class="built_in">begin</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[idxa],a[idxb]);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cout &lt;&lt; a[i] &lt;&lt; <span class="built_in">Presentation</span>(i,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C.心绪的解剖</h1><p><strong>思维</strong></p><h2 id="题意-3">题意</h2><p>给定一个数$x$，问$x$是否可以表示为$3$个斐波那契数之和。<br>其中，斐波那契数指的是斐波那契数列$0,1,1,2,3,5\cdots$ 中的数。</p><h2 id="解题思路-3">解题思路</h2><p>预处理$N$以内斐波那契数列，每次二分找到恰小于等于$x$的数，然后$x$减去这个数。<br>三次之后，如果$x$为$0$，则可以表示。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preFeb</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Feb.<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">    Feb.<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(Feb.<span class="built_in">back</span>()&lt;=<span class="number">1e10</span>)&#123;</span><br><span class="line">        Feb.<span class="built_in">pb</span>(Feb[Feb.<span class="built_in">size</span>()<span class="number">-1</span>]+Feb[Feb.<span class="built_in">size</span>()<span class="number">-2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x;cin &gt;&gt; x;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">ans</span><span class="params">(<span class="number">3</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = --<span class="built_in">upper_bound</span>(<span class="built_in">ALL</span>(Feb),x);</span><br><span class="line">        ans[i] = *it;</span><br><span class="line">        x -= *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; ans[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>D.友谊的套路</h1><p><strong>2签</strong></p><h2 id="题意-4">题意</h2><p>在五局三胜的游戏中，一方先胜$2$场，另一方再胜$3$场逆袭，这种情况叫做“让二追三”。<br>已知小红的胜率为$p$，求让二追三的概率。</p><h2 id="解题思路-4">解题思路</h2><p>分小红让二追三和小红被让二追三两种情况。</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ld p;cin &gt;&gt; p;</span><br><span class="line">    ld np=<span class="number">1</span>-p;</span><br><span class="line">    ld ans=p*p*np*np*np+np*np*p*p*p;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">10</span>) &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>E.未来的预言</h1><p><strong>思维</strong></p><h2 id="题意-5">题意</h2><p>给定一个形如“BOx”的字符串，表示进行$x$局的游戏（$x$为奇数），赢得更多场次的队伍获胜。<br>另给一个字符串，表示每局胜利的队伍。</p><p>问第几局已经确定了胜负，或是还未确定。</p><h2 id="解题思路-5">解题思路</h2><p>数数</p><h2 id="参考程序-5">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">getnum</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,s.<span class="built_in">length</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">        ret*=<span class="number">10</span>;</span><br><span class="line">        ret+=s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string ts;cin &gt;&gt; ts;</span><br><span class="line">    string s; cin &gt;&gt; s;</span><br><span class="line">    ll tn=<span class="built_in">getnum</span>(ts); tn/=<span class="number">2</span>;</span><br><span class="line">    ll cntR=<span class="number">0</span>,cntP=<span class="number">0</span>;</span><br><span class="line">    ll n=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> c=s[i];</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;R&#x27;</span>) cntR++;</span><br><span class="line">        <span class="keyword">else</span> cntP++;</span><br><span class="line">        <span class="keyword">if</span>(cntR&gt;tn)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;kou!&quot;</span> &lt;&lt; endl &lt;&lt; i+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cntP&gt;tn)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;yukari!&quot;</span> &lt;&lt; endl &lt;&lt; i+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;to be continued.&quot;</span> &lt;&lt; endl &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>F.命运的抉择</h1><p><strong>思维</strong></p><h2 id="题意-6">题意</h2><p>给定一个长度为$n$的数组，把它分成非空的两部分$a,b$，使得从$a,b$中分别任取一个元素$a_i,b_j$，它们互质$gcd(a_i,b_j)=1$</p><h2 id="解题思路-6">解题思路</h2><p>先在$a$中放置一个数，开一个set记录$a$中已存在的质数因子。</p><p>在剩余的数字中多次扫描，一旦某个数$x$能被$a$中的质数因子整除，就把它放入$a$中，直到某次扫描没有加入新的数字。<br>剩余的数字作为$b$。</p><p>时间复杂度比较抽象//</p><h2 id="参考程序-6">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">GetFac</span><span class="params">(ll x)</span></span>&#123;<span class="comment">//返回x的质因数集合</span></span><br><span class="line">    vector&lt;ll&gt; ret;</span><br><span class="line">    ll i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(check[x])&#123;<span class="comment">//check[i]==1表示i是合数</span></span><br><span class="line">            <span class="keyword">if</span>(x%prime[i]==<span class="number">0</span>)&#123;<span class="comment">//prime是质数表</span></span><br><span class="line">                ret.<span class="built_in">pb</span>(prime[i]);</span><br><span class="line">                <span class="keyword">while</span>(x%prime[i]==<span class="number">0</span>) x/=prime[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; ret.<span class="built_in">pb</span>(x); <span class="keyword">return</span> ret; &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; vFac;</span><br><span class="line">    vector&lt;ll&gt; v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        v.<span class="built_in">push_back</span>(t);</span><br><span class="line">        vFac.<span class="built_in">push_back</span>(<span class="built_in">GetFac</span>(t));</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;ll&gt; st;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sa</span><span class="params">(n,<span class="number">0</span>)</span></span>;<span class="comment">//放入集合a</span></span><br><span class="line">    sa[<span class="number">0</span>]=<span class="number">1</span>; t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:vFac[<span class="number">0</span>]) st.<span class="built_in">insert</span>(x);<span class="comment">//将第一个数的质因数放入集合</span></span><br><span class="line">    <span class="keyword">while</span>(t)&#123;</span><br><span class="line">        t=<span class="number">0</span>;<span class="comment">//t表示本轮是否有数放入集合a</span></span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(sa[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:vFac[i]) <span class="keyword">if</span>(st.<span class="built_in">count</span>(x))&#123;</span><br><span class="line">                sa[i]=<span class="number">1</span>; t++;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;y:vFac[i]) st.<span class="built_in">insert</span>(y);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;ll&gt; a,b;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(sa[i]) a.<span class="built_in">pb</span>(v[i]); <span class="keyword">else</span> b.<span class="built_in">pb</span>(v[i]);</span><br><span class="line">    <span class="keyword">if</span>(b.<span class="built_in">size</span>()==<span class="number">0</span>) &#123;cout &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    ll na=a.<span class="built_in">size</span>(),nb=b.<span class="built_in">size</span>();</span><br><span class="line">    cout &lt;&lt; na &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; nb &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,na<span class="number">-1</span>) cout &lt;&lt; a[i] &lt;&lt; <span class="built_in">Presentation</span>(i,na<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,nb<span class="number">-1</span>) cout &lt;&lt; b[i] &lt;&lt; <span class="built_in">Presentation</span>(i,nb<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>G.人生的起落</h1><p><strong>构造</strong></p><h2 id="题意-7">题意</h2><p>形如$(a,b,a),a\gt b$的三元组称为“v-三元组”。<br>构造一个长度为$n$，和为$S$，且恰好有$k$个“v-三元组”的正整数数组。</p><h2 id="解题思路-7">解题思路</h2><p>限定正整数，“v-三元组”至少为$(2,1,2)$。<br>依此开局特判：</p><ol><li>$n&lt;k*2+1$：k个“v-三元组”最少需要$2k+1$个数。</li><li>$S&lt;n+k+1$：k个“v-三元组”最少需要$k+1$个$2$，其余为$1$，和至少为$n+k+1$。</li></ol><p>构造方法是，先在最前的$k+1$个奇数位上放置尽可能大的数，然后在剩余的位置上放置$1$。若还有多余的数，放在第$k+1$个奇数位（$k*2+1$）上。</p><p>若$n$恰好等于$k*2+1$，则将多余的数放置在偶数位上，但偶数位上的数不能超过奇数位上的数。</p><h2 id="参考程序-7">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,S,k;cin &gt;&gt; n &gt;&gt; S &gt;&gt; k;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) cout &lt;&lt; S &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) cout &lt;&lt; S/<span class="number">2</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; S-S/<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>) cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; S-n+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>*k+<span class="number">1</span>) &#123;cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">if</span>(k&amp;&amp;S&lt;n+k+<span class="number">1</span>) &#123;cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    ll t=(S-(n-(k+<span class="number">1</span>)))/(k+<span class="number">1</span>);</span><br><span class="line">    vector&lt;ll&gt; ans;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,k)&#123;</span><br><span class="line">        ans.<span class="built_in">pb</span>(t);</span><br><span class="line">        ans.<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line">        S-=t+<span class="number">1</span>;</span><br><span class="line">    &#125;ans.<span class="built_in">pb</span>(t); S-=t;</span><br><span class="line">    <span class="keyword">if</span>(ans.<span class="built_in">size</span>()&gt;=n)&#123;</span><br><span class="line">        t=S/(n/<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n/<span class="number">2</span><span class="number">-1</span>)&#123;</span><br><span class="line">            ans[i*<span class="number">2</span>+<span class="number">1</span>]+=t;</span><br><span class="line">            S-=t;</span><br><span class="line">        &#125;</span><br><span class="line">        t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(S)&#123;</span><br><span class="line">            ans[t*<span class="number">2</span>+<span class="number">1</span>]++;</span><br><span class="line">            S--;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">1</span>&amp;&amp;ans[<span class="number">1</span>]&gt;=ans[<span class="number">0</span>]) &#123;cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        t=ans.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(ans.<span class="built_in">size</span>()&lt;n)&#123;</span><br><span class="line">            ans.<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line">            S--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[t]+=S;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i==n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>I.时空的交织</h1><p><strong>贪心</strong></p><h2 id="题意-8">题意</h2><p>给定$n$个数的数组$a$和$m$个数的数组$b$，表示一个$n\times m$的矩阵，矩阵中的元素$m_{i,j}=a_i*b_j$。<br>选择一个子矩阵，使得子矩阵中的元素之和最大，输出这个和。</p><h2 id="解题思路-8">解题思路</h2><p>假设选定的矩阵区间为$(r_i,r_j):(c_i,c_j)$，则子矩阵的和为$\sum_{i=r_i}^{r_j}\sum_{j=c_i}^{c_j}a_i<em>b_j=\sum_{i=r_i}^{r_j}a_i</em>\sum_{j=c_i}^{c_j}b_j$。</p><p>问题转化为求$a$数组的一个非空连续子数组和乘上$b$数组的一个非空连续子数组和的最大值。</p><p>可为空的数组区间和的最大值可以贪心的求解：</p><ol><li>用$cur$表示对当前区间和，$max$表示区间和的最大值。</li><li>将当前元素$a_i$加入区间，和当前最大值比较。</li><li>若当前区间和$cur&lt;0$，则舍弃之前的区间，重新开始计算（$cur:=0$）。</li></ol><p>本题中的区间要求非空，可以用最值修正。</p><p>此外，$a$数组和$b$数组的元素可以为负数，因此同时求出区间和的最大值和最小值，两两相乘取最大即可。</p><h2 id="参考程序-8">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">create_vec</span>(a,n);</span><br><span class="line">    <span class="built_in">create_vec</span>(b,m);</span><br><span class="line">    ll mxa,mxb,mna,mnb,curmn,curmx;</span><br><span class="line">    mxa=mxb=-INF; mna=mnb=INF;</span><br><span class="line">    curmn=curmx=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        curmn+=a[i];</span><br><span class="line">        curmx+=a[i];</span><br><span class="line">        <span class="keyword">if</span>(curmn&gt;<span class="number">0</span>) curmn=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(curmx&lt;<span class="number">0</span>) curmx=<span class="number">0</span>;</span><br><span class="line">        mna=<span class="built_in">min</span>(mna,curmn);</span><br><span class="line">        mxa=<span class="built_in">max</span>(mxa,curmx);</span><br><span class="line">    &#125;</span><br><span class="line">    curmn=curmx=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">        curmn+=b[i];</span><br><span class="line">        curmx+=b[i];</span><br><span class="line">        <span class="keyword">if</span>(curmn&gt;<span class="number">0</span>) curmn=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(curmx&lt;<span class="number">0</span>) curmx=<span class="number">0</span>;</span><br><span class="line">        mnb=<span class="built_in">min</span>(mnb,curmn);</span><br><span class="line">        mxb=<span class="built_in">max</span>(mxb,curmx);</span><br><span class="line">    &#125;</span><br><span class="line">    curmn=INF; curmx=-INF;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        curmn=<span class="built_in">min</span>(curmn,a[i]);</span><br><span class="line">        curmx=<span class="built_in">max</span>(curmx,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curmx&lt;=<span class="number">0</span>) mxa=<span class="built_in">min</span>(mxa,curmx);</span><br><span class="line">    <span class="keyword">if</span>(curmn&gt;=<span class="number">0</span>) mna=<span class="built_in">max</span>(mna,curmn);</span><br><span class="line">    curmn=INF; curmx=-INF;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">        curmn=<span class="built_in">min</span>(curmn,b[i]);</span><br><span class="line">        curmx=<span class="built_in">max</span>(curmx,b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curmx&lt;=<span class="number">0</span>) mxb=<span class="built_in">min</span>(mxb,curmx);</span><br><span class="line">    <span class="keyword">if</span>(curmn&gt;=<span class="number">0</span>) mnb=<span class="built_in">max</span>(mnb,curmn);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(&#123;mna*mnb,mna*mxb,mxa*mnb,mxa*mxb&#125;) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>J.时空的交织</h1><p><strong>贪心、构造</strong></p><h2 id="题意-9">题意</h2><p>给定一棵有根树，若干个节点为红色。<br>为每个节点赋值$1$或$2$，使得每个以红色节点为根的子树，其节点值之和为$3$的倍数。</p><h2 id="解题思路-9">解题思路</h2><p>对于每个红色节点，如果它没有白色子节点，则它的子树除它以外的和已经是$3$的倍数，它为$1$或$2$都不可能再使它的子树和为$3$的倍数。</p><p>如果它至少有1个白色子节点，则它和白色子节点可以配合使得它的子树和为$3$的倍数。</p><p>因此，按DFS逆序遍历，白色节点先赋值为$1$。若红色节点除其本身外，和不是$3$的倍数，则用它补上；否则将任一白色子节点改为$2$，它赋为$2$。</p><h2 id="参考程序-9">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;ll&gt;&gt; G;</span><br><span class="line">vector&lt;ll&gt; vDFS_rev;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;y:G[x]) <span class="built_in">DFS</span>(y);</span><br><span class="line">    vDFS_rev.<span class="built_in">pb</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n; G.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    string s;cin &gt;&gt; s;</span><br><span class="line">    bitset&lt;N&gt; red;<span class="comment">//red[i]表示第i个节点是否为红色</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) red[i+<span class="number">1</span>]=(s[i]==<span class="string">&#x27;R&#x27;</span>);</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">white</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;<span class="comment">//white[i]表示第i个节点下的某一白色节点，0表示没有</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t; G[t].<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(white[t]==<span class="number">0</span>&amp;&amp;!red[i]) white[t]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(white[i]==<span class="number">0</span>&amp;&amp;red[i]) &#123;cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;<span class="keyword">return</span> ;&#125;<span class="comment">//红色节点下必须有白色节点</span></span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">1</span>);<span class="comment">//获取逆DFS序列</span></span><br><span class="line">    ll S[N]=&#123;<span class="number">0</span>&#125;,ans[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:vDFS_rev)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;y:G[x]) S[x]+=S[y];</span><br><span class="line">        <span class="keyword">if</span>(red[x])&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[x]%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                ans[x]=<span class="number">2</span>; S[x]+=<span class="number">3</span>;</span><br><span class="line">                ans[white[x]]=<span class="number">2</span>; S[white[x]]+=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(S[x]%<span class="number">3</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                ans[x]=<span class="number">2</span>; S[x]+=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[x]=<span class="number">1</span>; S[x]+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans[x]=<span class="number">1</span>;</span><br><span class="line">            S[x]+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cout &lt;&lt; ans[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024牛客寒假 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024牛客寒假05</title>
      <link href="/posts/ACM_2024Winter_NCD05.html"/>
      <url>/posts/ACM_2024Winter_NCD05.html</url>
      
        <content type="html"><![CDATA[<h1>A.mutsumi的质数合数</h1><p><strong>1签</strong></p><h2 id="题意">题意</h2><p>给定一个正整数集合，问其中质数和合数的个数之和。</p><h2 id="解题思路">解题思路</h2><p>正整数中只有$1$既不是质数也不是合数，总数减去$1$的个数即为答案</p><p>(P.S.)：有人这题WA了4发。。。</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t,cnt=<span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>) cnt++;</span><br><span class="line">    &#125;cout &lt;&lt; n-cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C.anon的私货</h1><p><strong>贪心</strong></p><h2 id="题意-2">题意</h2><p>给定一个长度为$n$的正整数序列，可以在其中任意位置插入$0$。<br>在保证除全$0$外的任意子序列的平均值大于$1$的条件下最多可以插入多少个$0$。</p><h2 id="解题思路-2">解题思路</h2><p>题目可以转换为：对于每个数字，两边插入的$0$的个数之和不大于它。</p><p>贪心的，先从左往右扫描，对于每个数字，尽量往左插入$0$，<br>第$i$个数字$a_i$左边插入$0$的个数记为$pl_i$。</p><p>最左边的数字$a_1$可以往左插入$a_1-1$个$0$，<br>后面的数字$a_i$允许往左插入$0$的个数$pl_i$被限制为以下两个值的最小值：</p><ol><li>$a_i-1$：$a_i$左边插入的数量最多为$a_i-1$</li><li>$a_{i-1}-1-pl_{i-1}$：$a_{i-1}$两边插入的数量$pl_{i-1}+pl_i&lt;=a_{i-1}-1$</li></ol><p>接着，从右往左扫描，对于每个数字，尽量往右插入$0$，类比上面的过程。</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">pl</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>; <span class="comment">//pl[i]表示第i个位置左边的空当，pl[n]表示最右端</span></span><br><span class="line">    pl[<span class="number">0</span>]=v[<span class="number">0</span>]<span class="number">-1</span>;</span><br><span class="line">    pl[n]=v[n<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        pl[i]=<span class="built_in">min</span>(v[i<span class="number">-1</span>]<span class="number">-1</span>-pl[i<span class="number">-1</span>],v[i]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,n<span class="number">-1</span>,<span class="number">1</span>)&#123;</span><br><span class="line">        pl[i]=<span class="built_in">min</span>(&#123;v[i]<span class="number">-1</span>-pl[i+<span class="number">1</span>],v[i<span class="number">-1</span>]<span class="number">-1</span>,pl[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n) ans+=pl[i];</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) ans=v[<span class="number">0</span>]<span class="number">-1</span>;<span class="comment">//特判</span></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>E.soyorin的数组操作（easy）</h1><p><strong>贪心</strong></p><h2 id="题意-3">题意</h2><p>给定一个长度为$n$的数组，每次可以选定一个$n$以内的偶数$k$，使得$a_1$到$a_k$这$k$个数的值都增加它们的下标。<br>问任意次操作后能否使得数组不严格单调递增。</p><h2 id="解题思路-3">解题思路</h2><p>如果$n$为偶数，每次选中全数组都可以使相邻两个数之差（后一个减前一个）增加$1$，显然必定可以使得数组递增。</p><p>如果$n$为奇数。<br>从后往前遍历，对于每个偶数位置$i$，在满足$a_i&lt;=a_{i+1}$的前提下使其最大。<br>这样做可以保证，在合法的情况下，这个数减前面的数最大。</p><p>同时记录操作次数，同步到前面的元素。</p><p>最后判断数组是否有序。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)&#123; cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl; <span class="keyword">return</span>; &#125;<span class="comment">//偶数个数，直接YES</span></span><br><span class="line"></span><br><span class="line">    ll cur=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,n<span class="number">-2</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        v[i]+=cur*(i+<span class="number">1</span>);</span><br><span class="line">        v[i<span class="number">-1</span>]+=cur*i;<span class="comment">//同步更新左边的值</span></span><br><span class="line">        <span class="keyword">if</span>(v[i]&gt;v[i+<span class="number">1</span>])&#123; cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="comment">//v[i+1]已经是满足条件下最大的值了。如果还是小于v[i]，那么就不可能满足条件了</span></span><br><span class="line">        t=(v[i+<span class="number">1</span>]-v[i])/(i+<span class="number">1</span>);</span><br><span class="line">        v[i]+=t*(i+<span class="number">1</span>);</span><br><span class="line">        v[i<span class="number">-1</span>]+=t*i;</span><br><span class="line">        cur+=t; i--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-2</span>) <span class="keyword">if</span>(v[i]&gt;v[i+<span class="number">1</span>])&#123; cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl; <span class="keyword">return</span>; &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>GH.sakiko的排列构造（easy+hard）</h1><p><strong>构造</strong></p><h2 id="题意-4">题意</h2><p>给定一个正整数$n$，构造一个$n$的排列$p$，使得$p_i+i$全为质数</p><h2 id="解题思路-4">解题思路</h2><p>考虑一段连续的数字$[l,r]$，如果两端之和$l+r$是质数，那么把这段数字倒过来，与原来的数字序列对应相加，将得到$r-l+1$个质数$r+l$。</p><p>先确定右端点$r=n$，从后往前寻找一个左端点$l$，使得$l+r$为质数，再将这个区间的数字序列倒过来放入这个区间。</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">ans</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">Phi_and_Prime_Table</span>(<span class="number">2</span>*n+<span class="number">2</span>);<span class="comment">//预处理质数表，数据区间有限暴力判断也可</span></span><br><span class="line">    ll r=n;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,n,<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!check[i+r])&#123;<span class="comment">//check[i+r]==0表示i+r是质数</span></span><br><span class="line">            <span class="built_in">FORLL</span>(j,i,r) ans[j]=r+i-j;</span><br><span class="line">            r=i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cout &lt;&lt; ans[i] &lt;&lt; <span class="built_in">Presentation</span>(i,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>I.rikki的最短路</h1><p><strong>思维</strong></p><h2 id="题意-5">题意</h2><p>在一条数轴上，你在原点$O$，$A$在$a$处，$T$在$t$处，你的视线区间为$k$。<br>你先去找$T$。</p><p>如果路上看到$A$，先去找$A$，再去找$T$。<br>如果路上没看到$A$，先去去找$T$，再去找$A$，再去找$T$。</p><p>问最短路程。</p><h2 id="解题思路-5">解题思路</h2><p>分类讨论</p><ol><li>$t&gt;=0$：$T$在原点右边，去找$T$可以看到的区间为$[-k,t+k]$<ol><li>$A$在$[-k,0]$：先去找$A$，再去找$T$，最短路程为$t+2|a|=t-2a$</li><li>$A$在$[0,t]$：路上把$A$捡走，再去找$T$，最短路程为$t$</li><li>$A$在$[t,t+k]$：先去找$T$，再去找$A$，再去找$T$，合并到其他情况</li><li>其他：先去找$T$，再去找$A$，再去找$T$，最短路程为$t+2|a-t|$</li></ol></li><li>$t&lt;0$：$T$在原点左边，类比即可</li></ol><h2 id="参考程序-5">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll t,a,k;cin &gt;&gt; t &gt;&gt; a &gt;&gt; k;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=-k&amp;&amp;a&lt;=t)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a&lt;=<span class="number">0</span>) cout &lt;&lt; t-a*<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; t+<span class="built_in">abs</span>(t-a)*<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=t&amp;&amp;a&lt;=k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a&gt;=<span class="number">0</span>) cout &lt;&lt; a*<span class="number">2</span>-t &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; -t &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; -t+<span class="built_in">abs</span>(t-a)*<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>J.rikki的数组陡峭值</h1><p><strong>贪心</strong></p><h2 id="题意-6">题意</h2><p>长度为$n$的数组，每个元素$a_i$限定在一个区间$[l_i,r_i]$内。</p><p>定义陡峭值为每对相邻元素的差的绝对值之和$\sum\limits_{i=1}^{n-1}|a_{i+1}-a_i|$，求陡峭值的最小值。</p><h2 id="解题思路-6">解题思路</h2><p>从前往后遍历。</p><p>如果$[l_i,r_i]$和当前区间有交集，那么都取交集内的数字，陡峭值为$0$。<br>如果$[l_i,r_i]$和当前区间没有交集，那么取两个区间的边界，将当前区间退化成一点。<br>退化后，改为用前一点和区间作比。在区间外，取区间边界。</p><h2 id="参考程序-6">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll l=<span class="number">0</span>,r=<span class="number">1e9</span>+<span class="number">5</span>,pre=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">1</span>;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    ll tl,tr;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; tl &gt;&gt; tr;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;<span class="comment">//当前为一区间</span></span><br><span class="line">            <span class="keyword">if</span>(tr&lt;=l||tl&gt;=r)&#123;<span class="comment">//元素a_i区间与当前区间不相交</span></span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(tr&lt;=l)&#123;</span><br><span class="line">                    ans+=<span class="built_in">abs</span>(l-tr);</span><br><span class="line">                    pre=tr;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans+=<span class="built_in">abs</span>(tl-r);</span><br><span class="line">                    pre=tl;</span><br><span class="line">                &#125;<span class="comment">//区间退化</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(tl&gt;=l) l=tl;</span><br><span class="line">                <span class="keyword">if</span>(tr&lt;=r) r=tr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//当前为一点</span></span><br><span class="line">            <span class="keyword">if</span>(tl&lt;=pre&amp;&amp;tr&gt;=pre) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(tl&gt;=pre)&#123;</span><br><span class="line">                ans+=<span class="built_in">abs</span>(tl-pre);</span><br><span class="line">                pre=tl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tr&lt;=pre)&#123;</span><br><span class="line">                ans+=<span class="built_in">abs</span>(pre-tr);</span><br><span class="line">                pre=tr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>K.soyorin的通知</h1><p><strong>完全背包</strong></p><h2 id="题意-7">题意</h2><p>你要通知$n$个人。你通知1个人花费$p$，第$i$个人通知$a_i$个人花费$b_i$。问最少花费。</p><h2 id="解题思路-7">解题思路</h2><p>首先你至少需要通知$1$个人，才能使他们相互传递通知。<br>再让这个人去通知其他人，以此传递，直到其他$n-1$个人都被通知到。<br>把$a_i$看作容量，$b_i$看作价值，每个人可以选多次，问题转化为求最小价值完全背包问题。<br>DP前，也要把自己作为$a=1,b=q$的物品加入，因为自己也可以单独通知多个人。</p><h2 id="参考程序-7">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,p,t;cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">cost</span><span class="params">(n+<span class="number">1</span>)</span>,<span class="title">val</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; cost[i] &gt;&gt; val[i];</span><br><span class="line">    cost[<span class="number">0</span>]=p;val[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,INF)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n)</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,n<span class="number">-2</span>)&#123;</span><br><span class="line">            t=j+val[i]&gt;n<span class="number">-1</span>?n<span class="number">-1</span>:j+val[i];</span><br><span class="line">            dp[t]=<span class="built_in">min</span>(dp[t],dp[j]+cost[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[n<span class="number">-1</span>]+p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>L.rikki的星星</h1><p><strong>2签</strong></p><h2 id="题意-8">题意</h2><p>进行$n$局游戏，赢一局$+1$分，输一局$-1$分，没有平局。</p><p>游戏结束后分数为$x$，问赢多少局输多少局，或是无解。</p><h2 id="解题思路-8">解题思路</h2><p>赢一局和输一局的分差为$2$，因此最终得分和局数的奇偶性一定相同。</p><p>记赢了$a$局，则：$a+(n-a)=x$，解得$a=\dfrac{x+n}{2}$。</p><h2 id="参考程序-8">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,x;cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    <span class="keyword">if</span>((x+n)%<span class="number">2</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (x+n)/<span class="number">2</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; (n-x)/<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>M.rikki的排列连通</h1><p><strong>贪心</strong></p><h2 id="题意-9">题意</h2><p>给定$2$个$n$的排列，置入$2\times n$的矩阵。<br>每次操作可以消掉同一数字所在的方块。</p><p>问最少操作多少次可以把矩阵分为没有相邻边的两部分（及以上）。</p><h2 id="解题思路-9">解题思路</h2><p>以下是几种合法的情况：</p><ol><li>某个数字在两个排列中的位置相同，且两边都有数字，消除它即可，答案为$1$。</li><li>某个数字在两个排列中的位置相差$1$，交叉的部分一定有数字，消除它即可，答案为$1$。</li><li>每个数字在两个排列中的位置都至少相差$2$，选择同一位置的两个数字消除，答案为$2$。</li></ol><p>特判是<code>n=1,&#123;1&#125;,&#123;1&#125;</code>、<code>n=2,&#123;1,2&#125;,&#123;1,2&#125;</code>、<code>n=2,&#123;2,1&#125;,&#123;2,1&#125;</code>。<br>第一种情况中，某个数字在两个排列中都位于最左或都位于最右，这个数字不能计入答案。</p><h2 id="参考程序-9">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t; cin &gt;&gt; n;</span><br><span class="line">    ll mndif=INF;<span class="comment">//最小差值</span></span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">pos</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    pos.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        pos[t]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>&amp;&amp;pos[t]==<span class="number">1</span>) ;<span class="comment">//最左</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==n&amp;&amp;pos[t]==n) ;<span class="comment">//最右</span></span><br><span class="line">        <span class="keyword">else</span> mndif=<span class="built_in">min</span>(mndif,<span class="built_in">abs</span>(i-pos[t]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>&amp;&amp;mndif&gt;<span class="number">1</span>) &#123;cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//特判</span></span><br><span class="line">    <span class="keyword">if</span>(mndif&lt;<span class="number">2</span>) &#123;cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024牛客寒假 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024牛客寒假04</title>
      <link href="/posts/ACM_2024Winter_NCD04.html"/>
      <url>/posts/ACM_2024Winter_NCD04.html</url>
      
        <content type="html"><![CDATA[<h1>A.柠檬可乐</h1><p><strong>1签</strong></p><h2 id="题意">题意</h2><p>第一行输入三个整数$a,b,k$，判断是否$a\ge k\times b$</p><h2 id="解题思路">解题思路</h2><p>如题</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a,b,k;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; k;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;=b*k) cout &lt;&lt; <span class="string">&quot;good\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;bad\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.左右互博</h1><p><strong>思维</strong></p><h2 id="题意-2">题意</h2><p>有$n$堆石子，每堆石子有$a_i$个，两个人轮流取操作。<br>每次操作可以选择一堆至少有$2$个石子的石子堆，然后任意分成两堆，每堆至少有一个石子。<br>最先无法操作的人输。</p><h2 id="解题思路-2">解题思路</h2><p>对于有$x$个石子的石堆，它被分成$x$堆一个石子的石堆，需要操作$x-1$次。<br>因此，对所有石堆的操作次数求和 $sum = \sum\limits_{i=1}^{n}a_i-1$。<br>判断奇偶性</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        ans+=t<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans%<span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;gui&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;sweet&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C.冬眠</h1><p><strong>模拟</strong></p><h2 id="题意-3">题意</h2><p>给定$n\times m$的字符矩阵和一段有$q$次操作的操作序列，包含两种操作：</p><ol><li><code>1 t</code>表示将第$t$行向右移动$1$次，最右的一个字符移到最左的位置。</li><li><code>2 t</code>表示将第$t$列向下移动$1$次，最下的一个字符移到最上的位置。<br>问最后的字符矩阵第$x$行第$y$列的字符是什么</li></ol><h2 id="解题思路-3">解题思路</h2><p>数据范围不大，模拟操作</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,x,y;cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    x--;y--;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">mp</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cin &gt;&gt; mp[i];</span><br><span class="line">    ll p,q;cin &gt;&gt; p &gt;&gt; q;</span><br><span class="line">    <span class="function">vector&lt;pll&gt; <span class="title">op</span><span class="params">(q)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,q<span class="number">-1</span>) cin &gt;&gt; op[i].first &gt;&gt; op[i].second;</span><br><span class="line">    <span class="type">char</span> tc;</span><br><span class="line">    <span class="keyword">while</span>(p--)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">0</span>,q<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(op[i].first==<span class="number">1</span>)&#123;<span class="comment">//行向右循环移动一次</span></span><br><span class="line">                tc=mp[op[i].second<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">                <span class="built_in">FORLL_rev</span>(j,m<span class="number">-1</span>,<span class="number">1</span>) mp[op[i].second<span class="number">-1</span>][j]=mp[op[i].second<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                mp[op[i].second<span class="number">-1</span>][<span class="number">0</span>]=tc;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//列向下循环移动一次</span></span><br><span class="line">                tc=mp[n<span class="number">-1</span>][op[i].second<span class="number">-1</span>];</span><br><span class="line">                <span class="built_in">FORLL_rev</span>(j,n<span class="number">-1</span>,<span class="number">1</span>) mp[j][op[i].second<span class="number">-1</span>]=mp[j<span class="number">-1</span>][op[i].second<span class="number">-1</span>];</span><br><span class="line">                mp[<span class="number">0</span>][op[i].second<span class="number">-1</span>]=tc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; mp[x][y] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>D.守恒</h1><p><strong>数学</strong></p><h2 id="题意-4">题意</h2><p>给定$n$个正整数，可以将它们的和重新分配为$n$个正整数。<br>求所有分配方法中，这$n$个数的最大公约数有多少种可能性。</p><h2 id="解题思路-4">解题思路</h2><p>先对所有数求和，记为$sum$。<br>假设这$n$个数的最大公约数为$g$，则$g$一定是$sum$的因子。<br>且因为这$n$个数至少都为$g$，所以$sum/g\ge n$。</p><p>$O(\sqrt(n))$遍历$sum$的因子，判断是否满足条件</p><p>注意特判：当$n=1$时，答案为$1$</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    ll sum=<span class="number">0</span>,t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) &#123;cin &gt;&gt; t;sum+=t;&#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;<span class="comment">//特判</span></span><br><span class="line">    ll ub=<span class="built_in">sqrt</span>(sum)+<span class="number">1</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,ub)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i*i&gt;sum) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum%i==<span class="number">0</span>)&#123;</span><br><span class="line">            t=sum/i;</span><br><span class="line">            <span class="keyword">if</span>(t==i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t&gt;=n) ans++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(t&gt;=n) ans++;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=n) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>E.漂亮数组</h1><p><strong>思维</strong></p><h2 id="题意-5">题意</h2><p>给定一个长度为$n$的整数数组$a$和一个正整数$k$。<br>可以将$a$划分成任意个非空子串，如果子串和能被$k$整除，则称这个子串是漂亮的。<br>求 使得漂亮子串最多的方案 得到的漂亮子串的个数。</p><h2 id="解题思路-5">解题思路</h2><p>从前往后遍历，计算（从上个割点开始的）前缀和对$k$的余数$pre$。<br>如果当前位置的前缀和余数$pre_i$在上个割点之后的位置$j$有出现过，即$pre_i=pre_j$，则子串$[j+1,i]$区间和能被$k$整除。</p><p>因此，我们可以记录每个前缀和对$k$的余数在上个割点之后是否出现过，贪心的求出最多的漂亮子串个数。</p><p>时间复杂度：$O(n)$</p><h2 id="参考程序-5">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k,t;cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    map&lt;ll,<span class="type">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//余数为0即空</span></span><br><span class="line">    ll sum=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        sum+=t;</span><br><span class="line">        <span class="keyword">if</span>(mp[sum%k])&#123;<span class="comment">//如果当前 前缀和对k的余数在上个割点之后出现过</span></span><br><span class="line">            ans++;</span><br><span class="line">            sum=<span class="number">0</span>;</span><br><span class="line">            mp.<span class="built_in">clear</span>();<span class="comment">//清空map</span></span><br><span class="line">            mp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            mp[sum%k]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>G.数三角形（easy）</h1><p><strong>计数</strong></p><h2 id="题意-6">题意</h2><p>将<code>*</code>看作实体，<code>.</code>看作空白，等腰三角形具有类似以下的形状且不可旋转：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">一阶：</span><br><span class="line">.*.</span><br><span class="line">*** </span><br><span class="line"></span><br><span class="line">二阶：</span><br><span class="line"><span class="string">..</span>*<span class="string">..</span></span><br><span class="line">.*.*.</span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">三阶：</span><br><span class="line"><span class="string">...</span>*<span class="string">...</span></span><br><span class="line"><span class="string">..</span>*.*<span class="string">..</span></span><br><span class="line">.*<span class="string">...</span>*.</span><br><span class="line">*******</span><br></pre></td></tr></table></figure><p>以此类推，给定一个$n\times m$的字符矩阵，求有多少个等腰三角形</p><h2 id="解题思路-6">解题思路</h2><p>枚举三角形的顶点，然后向两边延展，判断是否满足条件。</p><p>对于底边，如果每次都从左往右扫描，则时间复杂度较高。<br>可以预处理每一个<code>*</code>在该行连续最左的<code>*</code>的位置，使用时直接查询$O(1)$判断。</p><h2 id="参考程序-6">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    <span class="type">char</span> mp[N][N]=&#123;<span class="number">0</span>&#125;;<span class="comment">//字符矩阵</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="built_in">FORLL</span>(j,<span class="number">1</span>,m) cin &gt;&gt; mp[i][j];</span><br><span class="line">    ll pre[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;<span class="comment">//预处理</span></span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[i][j]==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pre[i][j<span class="number">-1</span>]) pre[i][j]=pre[i][j<span class="number">-1</span>];<span class="comment">//如果当前位置是*，且左边有*，则pre[i][j]等于左边的*的位置</span></span><br><span class="line">                <span class="keyword">else</span> pre[i][j]=j;<span class="comment">//否则pre[i][j]等于当前位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> pre[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// FORLL(i,1,n) FORLL(j,1,m) cout &lt;&lt; pre[i][j] &lt;&lt; &quot; \n&quot;[j==m];//test</span></span><br><span class="line">    ll ans=<span class="number">0</span>,t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="built_in">FORLL</span>(j,<span class="number">1</span>,m) <span class="keyword">if</span>(mp[i][j]==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">        ll l=j<span class="number">-1</span>,r=j+<span class="number">1</span>,d=i+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//d表示当前底边所在的行，l和r表示底边的两个端点位置</span></span><br><span class="line">        <span class="keyword">while</span>(l&gt;=<span class="number">1</span>&amp;&amp;r&lt;=m&amp;&amp;d&lt;=n&amp;&amp;mp[d][l]==<span class="string">&#x27;*&#x27;</span>&amp;&amp;mp[d][r]==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            t=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(pre[d][r]&lt;=l) t=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(t) ans++;</span><br><span class="line">            l--;r++;d++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024牛客寒假 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024牛客寒假03</title>
      <link href="/posts/ACM_2024Winter_NCD03.html"/>
      <url>/posts/ACM_2024Winter_NCD03.html</url>
      
        <content type="html"><![CDATA[<h1>A.智乃与瞩目狸猫、幸运水母、月宫龙虾</h1><p><strong>1签</strong></p><h2 id="题意">题意</h2><p>题目分享了一个冷知识：<br>Ubuntu 发行版的每个代号都包含一个形容词和一个动物。例如：瞩目狸猫(Focal Fossa)、幸运水母(Jammy Jellyfish)、月宫龙虾(Lunar Lobster)，每个代号的两个单词首字母相同。<br>现在给定两个字符串，问首字母是否相同（忽略大小写）。</p><h2 id="解题思路">解题思路</h2><p>直接比较首字母即可。</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1,s2;cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="keyword">if</span>(s1[<span class="number">0</span>]==s2[<span class="number">0</span>]||s1[<span class="number">0</span>]<span class="number">-32</span>==s2[<span class="number">0</span>]||s1[<span class="number">0</span>]+<span class="number">32</span>==s2[<span class="number">0</span>]) cout &lt;&lt; YES;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.智乃的数字手串</h1><p><strong>博弈、猜结论</strong></p><h2 id="题意-2">题意</h2><p>有一串首尾相连的数字，两个玩家轮流操作。<br>当且仅当相邻$2$个数字之和为偶数时，可以消除其中一个，<br>然后<strong>可以</strong>交换剩下的数字中任意两个数字的位置（也可以不交换）。<br>特别的，如果只有$1$个数字，可以直接消除。<br>最先无法操作的玩家输。<br>问对于给定的数字串，qcjj（先手）和zn（后手）谁会赢。</p><h2 id="解题思路-2">解题思路</h2><p>考虑游戏结束时的状态：手串上的数字排布为<code>奇偶奇偶...奇偶</code>，特点是数量为偶数。<br>数量为奇数时，一定存在两个相邻的数，奇偶校验相同（和为偶数）。</p><p>判断原始数字串长度的奇偶性即可。</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    <span class="keyword">if</span>(n&amp;<span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;qcjj&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;zn&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>D.chino’s bubble sort and maximum subarray sum(easy version)</h1><p><strong>最大子段和</strong></p><h2 id="题意-3">题意</h2><p>给定一个长度为$n$的数组$a$，求恰好执行“交换任意相邻元素”操作$k$次后，数组$a$的最大非空子段和。</p><h2 id="解题思路-3">解题思路</h2><p>由于easy version的$k$范围极小（$k\in [0,1]$），暴力枚举所有情况求最大非空子段和即可。</p><p>对于最大非空字段和的求法，可以用贪心方法：<br>记$cur$为：包含当前位置元素的最大子段和。<br>从$a_2$开始遍历数组，记当前元素为$a_i$，则当前最大子段和有$2$种情况：</p><ol><li>将当前位置的元素加入当前最大子段和，值为$cur+a_i$；</li><li>以当前位置的元素为起点，重新开始计算最大子段和，值为$a_i$。</li></ol><p>每个位置的$cur$取这$2$种情况的较大值，每个位置$cur$的最大值即为最大非空子段和。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k;cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    ll ans=-INF,cur;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">        vector&lt;ll&gt; tv;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-2</span>)&#123;</span><br><span class="line">            tv=v;</span><br><span class="line">            <span class="built_in">swap</span>(tv[i],tv[i+<span class="number">1</span>]);</span><br><span class="line">            ll tans=tv[<span class="number">0</span>];</span><br><span class="line">            cur=tv[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">                cur=<span class="built_in">max</span>(tv[j],cur+tv[j]);</span><br><span class="line">                tans=<span class="built_in">max</span>(tans,cur);</span><br><span class="line">            &#125;ans=<span class="built_in">max</span>(ans,tans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//求原数组的最大子段和</span></span><br><span class="line">        ans=v[<span class="number">0</span>];</span><br><span class="line">        cur=v[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            cur=<span class="built_in">max</span>(v[i],cur+v[i]);</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>GH.智乃的比较函数(easy+normal)</h1><p><strong>偏序</strong></p><h2 id="题意-4">题意</h2><p>给定$3$个数字的$n$对关系<code>x y z</code>，$z=1$表示$x\lt y$；$z=0$表示$x\ge y$。<br>问这$n$对关系是否存在逻辑矛盾。</p><h2 id="解题思路-4">解题思路</h2><p>由于只有$3$个数字，可以直接暴力赋值，验证是否有情况可以满足所有关系。<br>时间复杂度：$O(3^3n)$</p><p>赛时本人直接对给定的关系集进行判断，会很麻烦，需要注意很多细节；<br>还有大佬用Floyd算法求偏序关系//%%%</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;array&lt;ll,3&gt;&gt; cmp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pending</span><span class="params">(array&lt;ll,<span class="number">4</span>&gt; a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [x,y,o]:cmp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(o==<span class="number">1</span>) &#123; <span class="keyword">if</span>(a[x]&gt;=a[y]) <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">if</span>(a[x]&lt;a[y]) <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="comment">//判断是否满足所有关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,x,y,o;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cmp.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; o;</span><br><span class="line">        cmp.<span class="built_in">pb</span>(&#123;x,y,o&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,<span class="number">3</span>) <span class="built_in">FORLL</span>(j,<span class="number">1</span>,<span class="number">3</span>) <span class="built_in">FORLL</span>(k,<span class="number">1</span>,<span class="number">3</span>) ans|=<span class="built_in">pending</span>(&#123;<span class="number">0</span>,i,j,k&#125;);</span><br><span class="line">    <span class="comment">//存在满足所有关系的情况即可</span></span><br><span class="line">    cout &lt;&lt; (ans?YES:NO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>J.智乃的相亲活动</h1><p><strong>建图、概率论</strong></p><h2 id="题意-5">题意</h2><p>有$n$名男嘉宾和$m$名女嘉宾，异性之间存在$k$对双向的好感关系。<br>每位男嘉宾和女嘉宾都会从ta喜欢的异性中均匀随机的选择一个，<br>被至少选中一次的嘉宾称为“心动嘉宾”。<br>求本次相亲活动中，心动男嘉宾和女嘉宾的期望数量。</p><h2 id="解题思路-5">解题思路</h2><p>建图：对每对好感关系，建立一条从男嘉宾到女嘉宾的无向边。<br>对于任一嘉宾$i$：<br>ta喜欢的每位嘉宾被ta选中的概率为$\frac{1}{deg_i}$；<br>ta成为心动嘉宾的概率为$1-\prod_{j\in like_i}(1-\frac{1}{deg_j})$，其中$like_i$为ta喜欢的嘉宾集合（因为好感关系为双向）。</p><p>分别求出每位嘉宾成为心动嘉宾的概率，再对男女嘉宾分别求和即可。</p><h2 id="参考程序-5">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">G</span>(n+m+<span class="number">1</span>);</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">deg</span><span class="params">(n+m+<span class="number">1</span>)</span></span>;</span><br><span class="line">    ll u,v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,k)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;  </span><br><span class="line">        G[u].<span class="built_in">pb</span>(n+v);</span><br><span class="line">        G[n+v].<span class="built_in">pb</span>(u);</span><br><span class="line">        deg[u]++;</span><br><span class="line">        deg[n+v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ansn,ansm,t;</span><br><span class="line">    ansn=ansm=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        t=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:G[i])&#123;</span><br><span class="line">            <span class="built_in">multo</span>(t,<span class="built_in">mdiv</span>(deg[x]<span class="number">-1</span>,deg[x]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">addto</span>(ansn,<span class="built_in">sub</span>(<span class="number">1</span>,t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,n+<span class="number">1</span>,n+m)&#123;</span><br><span class="line">        t=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:G[i])&#123;</span><br><span class="line">            <span class="built_in">multo</span>(t,<span class="built_in">mdiv</span>(deg[x]<span class="number">-1</span>,deg[x]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">addto</span>(ansm,<span class="built_in">sub</span>(<span class="number">1</span>,t));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;modint&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ansn &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ansm &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>K.智乃的“黑红树”</h1><p><strong>数据结构</strong></p><h2 id="题意-6">题意</h2><p>定义“黑红树”满足以下条件：</p><ol><li>一棵以黑色节点$1$为根的二叉树</li><li>每个节点只能有$0$或$2$个子节点。</li><li>黑色节点的子节点只能是红色；红色节点的子节点只能是黑色。</li></ol><p>给定黑红节点的数量$a,b$，构造一棵黑红树。</p><h2 id="解题思路-6">解题思路</h2><p>根据定义$1,2$，黑色节点的个数必须为奇数，红色节点的个数必须为偶数，因此$a$必须为奇数，$b$必须为偶数。<br>根据定义$3$，节点颜色将由节点的深度决定。</p><p>在满二叉树的情况下：</p><ol><li>如果最后一层是黑色节点，则节点数满足$a=2*b+1$</li><li>如果最后一层是红色节点，则节点数满足$b=2*a$</li></ol><p>利用这两个关系，可以再排除不合法的情况，剩余的情况都可以构造。</p><p>本人选用的构造方法为：按照层序遍历顺序铺设节点，直到节点数达到要求。</p><h2 id="参考程序-6">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a,b;cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    ll ub=a+b;</span><br><span class="line">    <span class="keyword">if</span>((a%<span class="number">2</span>==<span class="number">0</span>)||b%<span class="number">2</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;<span class="comment">//奇偶性不符合条件</span></span><br><span class="line">    <span class="keyword">if</span>(b&gt;<span class="number">2</span>*a||a<span class="number">-1</span>&gt;<span class="number">2</span>*b)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;<span class="comment">//节点数超出临界值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ll i=<span class="number">2</span>,st=<span class="number">1</span>,ed=<span class="number">1</span>;a--;</span><br><span class="line">    <span class="comment">//[st,ed]为上一层的节点范围，i为当前节点编号</span></span><br><span class="line">    <span class="function">vector&lt;pll&gt; <span class="title">son</span><span class="params">(ub+<span class="number">5</span>,pll(<span class="number">-1</span>,<span class="number">-1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(a||b)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,st,ed)&#123;<span class="comment">//铺设红色节点</span></span><br><span class="line">            <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            son[j]=<span class="built_in">pll</span>(i,i+<span class="number">1</span>);</span><br><span class="line">            i+=<span class="number">2</span>;b-=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        st=ed+<span class="number">1</span>;ed=i<span class="number">-1</span>;<span class="comment">//更新本层的节点范围</span></span><br><span class="line">        <span class="built_in">FORLL</span>(j,st,ed)&#123;<span class="comment">//铺设黑色节点</span></span><br><span class="line">            <span class="keyword">if</span>(a==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(son[j].first==<span class="number">-1</span>)&#123;</span><br><span class="line">                son[j]=<span class="built_in">pll</span>(i,i+<span class="number">1</span>);</span><br><span class="line">                i+=<span class="number">2</span>;a-=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        st=ed+<span class="number">1</span>;ed=i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,ub) cout &lt;&lt; son[i].first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; son[i].second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>LM.智乃的36倍数(easy+normal)</h1><p><strong>模数</strong></p><h2 id="题意-7">题意</h2><p>给定$n$个$10^{18}$范围内的非负整数。<br>求在其中取不同的$2$个元素，拼接起来后能被$36$整除的方案数。</p><h2 id="解题思路-7">解题思路</h2><p>假设$a$和$b$拼接，拼接后的数记为$c=a\times10^k+b$，其中$k$为$b$的位数。<br>可以发现：</p><p>$$c\%36=(a\times10^k+b)\%36 =(a\times10^k)\%36+b\%36 =(a\%36)\times(10^k\%36)+b\%36$$</p><p>因此，预处理$10^k\%36$的值，记录每个数对$36$的余数及其位数。<br>计算时，枚举每个数作为右半部分$b$，此时$k$也被确定为$b$的位数，<br>只需枚举左半部分$a$的余数，对满足条件的部分求和即可。</p><h2 id="参考程序-7">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ll&gt; DM;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;<span class="comment">//预处理10^k%36</span></span><br><span class="line">    ll t=<span class="number">1</span>;</span><br><span class="line">    DM.<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,<span class="number">19</span>)&#123;</span><br><span class="line">        t*=<span class="number">10</span>;</span><br><span class="line">        DM.<span class="built_in">pb</span>(t%<span class="number">36</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dig</span><span class="params">(ll x)</span></span>&#123;<span class="comment">//求位数</span></span><br><span class="line">    <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123; x/=<span class="number">10</span>; ret++; &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pre</span>();</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    ll t;pll tp;</span><br><span class="line">    map&lt;ll,<span class="type">int</span>&gt; mp;</span><br><span class="line">    vector&lt;pll&gt; v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        tp=<span class="built_in">make_pair</span>(t%<span class="number">36</span>,<span class="built_in">dig</span>(t));</span><br><span class="line">        v.<span class="built_in">pb</span>(tp);</span><br><span class="line">        mp[t%<span class="number">36</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:v)&#123;</span><br><span class="line">        t=x.second;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">0</span>,<span class="number">35</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i*DM[t]+x.first)%<span class="number">36</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                ans+=mp[i];</span><br><span class="line">                <span class="keyword">if</span>(i==x.first) ans--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024牛客寒假 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024牛客寒假02</title>
      <link href="/posts/ACM_2024Winter_NCD02.html"/>
      <url>/posts/ACM_2024Winter_NCD02.html</url>
      
        <content type="html"><![CDATA[<h1>A.Tokitsukaze and Bracelet</h1><p><strong>1签</strong></p><h2 id="题意">题意</h2><p>装备有$a,b,c$三个值，每个值分别对应一个强化等级，求装备的总强化等级。</p><h2 id="解题思路">解题思路</h2><p>根据每项数值判断强化等级，然后求和即可。</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a,b,c;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">150</span>) ans+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">200</span>) ans+=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(b&gt;<span class="number">32</span>&amp;&amp;b&lt;<span class="number">41</span>) ans+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b&gt;<span class="number">42</span>) ans+=<span class="number">2</span>; </span><br><span class="line">    <span class="keyword">if</span>(c&gt;<span class="number">32</span>&amp;&amp;c&lt;<span class="number">41</span>) ans+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;<span class="number">42</span>) ans+=<span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.Tokitsukaze and Cats</h1><p><strong>模拟</strong></p><h2 id="题意-2">题意</h2><p>上场关鸡，这场关猫//<br>有$n$只猫，在$(n,m)$大小的矩阵中，每只猫占据一个格子，坐标给定。<br>每只猫的四面需要围上围栏，求需要多少根围栏。</p><h2 id="解题思路-2">解题思路</h2><p>模拟，一只一只放入，根据已经放入的猫的位置，判断需要增加多少根围栏。</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n,k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> v[<span class="number">305</span>][<span class="number">305</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ll x,y,cnt;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,k)&#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        v[x<span class="number">-1</span>][y<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">1</span>&amp;&amp;v[x<span class="number">-2</span>][y<span class="number">-1</span>]) cnt++;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;n&amp;&amp;v[x][y<span class="number">-1</span>]) cnt++;</span><br><span class="line">        <span class="keyword">if</span>(y&gt;<span class="number">1</span>&amp;&amp;v[x<span class="number">-1</span>][y<span class="number">-2</span>]) cnt++;</span><br><span class="line">        <span class="keyword">if</span>(y&lt;m&amp;&amp;v[x<span class="number">-1</span>][y]) cnt++;</span><br><span class="line">        <span class="keyword">switch</span>(cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: ans+=<span class="number">4</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: ans+=<span class="number">3</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: ans+=<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: ans+=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>D.Tokitsukaze and Slash Draw</h1><p><strong>图论</strong></p><h2 id="题意-3">题意</h2><p>有一堆$n$张卡牌的牌堆。<br>有$m$种操作，第$i$种操作可以将牌堆顶的前$a_i$张卡牌按原本的顺序放置在牌堆底，代价为$b_i$.<br>求将牌堆<strong>从下往上数</strong>第$k$张卡牌放到牌堆顶的最小代价。</p><h2 id="解题思路-3">解题思路</h2><p>将牌堆看作一个有向图，$n$个位置代表$n$个节点。<br>第$i$种操作可以看作从每个顶点引出一条指向向后$a_i$个节点的边，边权为$b_i$。<br>求从第$n-k$个节点（从上往下数）到第$0$个节点的最短路即可。<br>由于总边数来到了$mn=5\times10^6$，最短路算法可以用$O(m\log n)$的Dijkstra。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">  ll v, w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  ll dis, u;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> node&amp; a) <span class="type">const</span> &#123; <span class="keyword">return</span> dis &gt; a.dis; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt; e[N];</span><br><span class="line">ll dis[N], vis[N];</span><br><span class="line">priority_queue&lt;node, vector&lt;node&gt;, greater&lt;node&gt;&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(ll n, ll s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">        dis[i] = INF;</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        ll u = q.<span class="built_in">top</span>().u;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ed : e[u]) &#123;</span><br><span class="line">            ll v = ed.v, w = ed.w;</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;dis[v], v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    ll a,b,t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n) e[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) e[i].<span class="built_in">push_back</span>((edge)&#123;(i+a)%n,b&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>(n,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(dis[n-k]==INF) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; dis[n-k] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>E.F.Tokitsukaze and Eliminate(easy+hard)</h1><p><strong>贪心</strong></p><h2 id="题意-4">题意</h2><p>$n$个宝石排成一排，第$i$个宝石的颜色为$col_i$<br>每次操作可以任选一种颜色，消除这种颜色的最右端的宝石和它右边的所有宝石。<br>问最少需要多少次操作才能消除所有宝石。</p><h2 id="解题思路-4">解题思路</h2><p>贪心，从右往左扫描，直到从当前位置到最右端。<br>这一区间内的宝石，包含了当前剩余的所有颜色，操作消除。<br>当前剩余颜色可在读入时处理前缀和</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    vector&lt;ll&gt; v,sc;<span class="comment">//sc[i]记录位置i之前出现过的颜色数量</span></span><br><span class="line">    v.<span class="built_in">pb</span>(<span class="number">0</span>);sc.<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">    map&lt;ll,<span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        v.<span class="built_in">pb</span>(t);</span><br><span class="line">        <span class="keyword">if</span>(mp[t]==<span class="number">0</span>) &#123;sc.<span class="built_in">pb</span>(sc[i<span class="number">-1</span>]+<span class="number">1</span>);mp[t]++;&#125;</span><br><span class="line">        <span class="keyword">else</span> sc.<span class="built_in">pb</span>(sc[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    mp.<span class="built_in">clear</span>();</span><br><span class="line">    t=<span class="number">0</span>;<span class="comment">//t记录当前的颜色数量</span></span><br><span class="line">    ll r=n,ans=<span class="number">0</span>;<span class="comment">//r记录当前剩余宝石数量</span></span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,n,<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[v[i]]==<span class="number">0</span>)&#123;</span><br><span class="line">            t++;</span><br><span class="line">            mp[v[i]]=<span class="number">1</span>;      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t==sc[r])&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            t=<span class="number">0</span>;mp.<span class="built_in">clear</span>();</span><br><span class="line">            r=i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>G.Tokitsukaze and Power Battle (esay)</h1><p><strong>数据结构</strong></p><h2 id="题意-esay-version">题意 (esay version)</h2><p>有一个长度为$n$的<strong>非负</strong>整数数组，有$q$次操作：</p><ol><li><code>1 i x</code>：将第$i$个数改为$x$</li><li><code>2 l r</code>：查询区间$[l,r]$内，每个长度不小于$2$的<strong>子区间</strong>，任意分成连续两段后，<code>左段之和减去右段之和</code>的最大值。</li></ol><h2 id="解题思路-5">解题思路</h2><p>实现单点修改、区间查询的数据结构，可以选用线段树或树状数组（本人采用树状数组）。<br>根据贪心的思想，由于数组非负，要最大化<code>左段之和减去右段之和</code>，子区间的左端点选定查询区间的左端点。<br>从右往左枚举右端点，并在分段时，右段只需留下一个数即可。</p><h2 id="参考程序-5">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))<span class="comment">//取最后一个1所在位置的权值</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BITree</span>&#123;<span class="comment">//树状数组，下标i从1开始</span></span><br><span class="line">    vector&lt;ll&gt; Data;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BITree</span><span class="params">(ll n)</span>:Data(n*<span class="number">2</span>+<span class="number">5</span>,<span class="number">0</span>) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll i,ll dif)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//给予i增量dif,维护树状数组，O(logn)</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;Data.<span class="built_in">size</span>())&#123;</span><br><span class="line">            Data[i]+=dif;</span><br><span class="line">            i+=<span class="built_in">lowbit</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">presum</span><span class="params">(ll i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//查询前缀和sum[i]，O(logn)</span></span><br><span class="line">        ll sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i)&#123;</span><br><span class="line">            sum+=Data[i];</span><br><span class="line">            i-=<span class="built_in">lowbit</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(ll l,ll r)</span></span>&#123;<span class="comment">//查询区间和</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">presum</span>(r)-<span class="built_in">presum</span>(l<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,Q,t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; Q;</span><br><span class="line">    <span class="function">BITree <span class="title">bt</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        bt.<span class="built_in">update</span>(i,t);<span class="comment">//维护原数组，实现单点修改，区间查询</span></span><br><span class="line">    &#125;<span class="comment">//建树</span></span><br><span class="line">    ll ans;</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        ll l,r;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            r=r-bt.<span class="built_in">query</span>(l,l);</span><br><span class="line">            bt.<span class="built_in">update</span>(l,r);</span><br><span class="line">            t=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans=-INF;</span><br><span class="line">            <span class="built_in">FORLL_rev</span>(i,r,l+<span class="number">1</span>)&#123;<span class="comment">//枚举右端点</span></span><br><span class="line">                <span class="keyword">if</span>(ans&gt;=bt.<span class="built_in">query</span>(l,i)) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//优化：如果当前答案已经大于接下来的区间前缀和，则不必再继续枚举</span></span><br><span class="line">                ans=<span class="built_in">max</span>(ans,bt.<span class="built_in">query</span>(l,i<span class="number">-1</span>)-bt.<span class="built_in">query</span>(i,i));</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">            t=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>I.Tokitsukaze and Short Path (plus)</h1><p><strong>思维</strong></p><h2 id="题意-5">题意</h2><p>给定一个有$n$个点的完全图（每两点之间有一条边），每个点$i$具有点权$a_i$。<br>每两个点之间的边权为这两点点权<strong>较大</strong>的值的2倍。<br>求每两个点之间的最短路之和：$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}dist(i,j)$</p><h2 id="解题思路-6">解题思路</h2><p>$n\le 2e5$ 的数据范围，首先排除建图暴算</p><p>对于任意两点$u,v$：<br>假设$u&gt;v$，那么$e(u,v)$（$u,v$之间的直接边）的权值为$2a_u$。<br>除$u$之外的任意点$w$，$e(u,w)$的权值为$2max{a_u,a_w}\ge a_u$，因此经过任意点$w$再到$u$的路径都不会比$e(u,v)$更短。<br>因此，对于任意两点$u,v$，$e(u,v)$是$u$到$v$的最短路。</p><p>对所有点权升序排序，点权的位次也是这个点权对答案贡献的次数。<br>时间复杂度：$O(n)$</p><h2 id="参考程序-6">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) ans+=v[i]*i;</span><br><span class="line">    cout &lt;&lt; ans*<span class="number">4</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//*4的含义：边权有系数2；每两个点互相到达要计算2次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>J.Tokitsukaze and Short Path (minus)</h1><p><strong>思维</strong></p><h2 id="题意-6">题意</h2><p>给定一个有$n$个点的完全图（每两点之间有一条边），每个点$i$具有点权$a_i$。<br>每两个点之间的边权为这两点点权<strong>较小</strong>的值的2倍。<br>求每两个点之间的最短路之和：$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}</p><h2 id="解题思路-7">解题思路</h2><p>对于任意两点$u,v$：<br>假设$u&lt;v$，那么$e(u,v)$（$u,v$之间的直接边）的权值为$2a_v$。<br>又假设$u,v$都不是点权最小的点，对于图中点权最小的点$w$，$u\rightarrow v\rightarrow w$的路径长度为$4a_w$（两条边）。<br>那么$dist(u,v)=min{4a_w,2a_v}$<br>因此，每个点为$min{2a_w,a_v}$在对答案做贡献</p><p>对所有点权降序排序，点权的位次也是这个点（$min{2a_w,a_v}$）对答案贡献的次数</p><h2 id="参考程序-7">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    vector&lt;ll&gt; v;</span><br><span class="line">    ll mn=INF;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        mn=<span class="built_in">min</span>(mn,t);</span><br><span class="line">        v.<span class="built_in">pb</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) ans+=<span class="built_in">min</span>(mn*<span class="number">2</span>,v[i])*(n-i<span class="number">-1</span>);</span><br><span class="line">    cout &lt;&lt; ans*<span class="number">4</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//*4的含义：边权有系数2；每两个点互相到达要计算2次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>K.Tokitsukaze and Password (easy)</h1><p><strong>暴力</strong></p><h2 id="题意-7">题意</h2><p>给定一个长度为$n$的字符串$x$，其中包含数字、小写字母和下划线‘_’，用来表示一个纯数字密码。<br>密码满足以下条件：</p><ol><li>密码没有前导$0$</li><li>密码可以被$8$整除</li><li>给定另一个长度为$n$的数字$y$，保证$x\lt y$</li><li>每种字母表示$[0,9]$中的一个，且不同字母表示的数字必定不同</li><li>每一位下划线‘_’都可以表示$[0,9]$中的任意一个数字，下划线上的数字不必相同</li></ol><p>求可能成为密码的数量</p><h2 id="解题思路-8">解题思路</h2><p>由于easy version的数据范围极小，暴力枚举判断是否满足条件即可<br>(srd有点考验耐心细心qwq)</p><h2 id="参考程序-8">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">ll n,y;</span><br><span class="line">string sx;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ub;<span class="comment">//记录待定字符的取值上界</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pending</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vk)</span></span>&#123;</span><br><span class="line">    ll x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(sx[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isalpha</span>(sx[<span class="number">0</span>])&amp;&amp;vk[sx[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sx[<span class="number">0</span>]==<span class="string">&#x27;_&#x27;</span>&amp;&amp;vk[<span class="number">4</span>]==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//不含前导0</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,<span class="number">3</span>) <span class="keyword">if</span>(ub[i])</span><br><span class="line">        <span class="built_in">FORLL</span>(j,i+<span class="number">1</span>,<span class="number">3</span>) <span class="keyword">if</span>(ub[j]&amp;&amp;vk[i]==vk[j]) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//不同字母取值不同</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:sx)&#123;</span><br><span class="line">        x*=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c)) x+=c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isalpha</span>(c)) x+=vk[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span> x+=vk[<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x%<span class="number">8</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//不是8的倍数</span></span><br><span class="line">    <span class="keyword">if</span>(x&gt;y) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//大于y</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string sy;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; sx &gt;&gt; sy;</span><br><span class="line">    y=<span class="built_in">stoll</span>(sy);</span><br><span class="line">    ub.<span class="built_in">clear</span>();</span><br><span class="line">    ub.<span class="built_in">resize</span>(<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:sx) <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:ub[<span class="number">0</span>]=<span class="number">9</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:ub[<span class="number">1</span>]=<span class="number">9</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:ub[<span class="number">2</span>]=<span class="number">9</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:ub[<span class="number">3</span>]=<span class="number">9</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;_&#x27;</span>:ub[<span class="number">4</span>]=<span class="number">9</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vk;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(a,<span class="number">0</span>,ub[<span class="number">0</span>]) <span class="built_in">FORLL</span>(b,<span class="number">0</span>,ub[<span class="number">1</span>]) <span class="built_in">FORLL</span>(c,<span class="number">0</span>,ub[<span class="number">2</span>]) <span class="built_in">FORLL</span>(d,<span class="number">0</span>,ub[<span class="number">3</span>]) <span class="built_in">FORLL</span>(e,<span class="number">0</span>,ub[<span class="number">4</span>])&#123;</span><br><span class="line">        vk.<span class="built_in">clear</span>();</span><br><span class="line">        vk.<span class="built_in">pb</span>(a);vk.<span class="built_in">pb</span>(b);vk.<span class="built_in">pb</span>(c);vk.<span class="built_in">pb</span>(d);vk.<span class="built_in">pb</span>(e);</span><br><span class="line">        ans+=<span class="built_in">pending</span>(vk);</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024牛客寒假 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024牛客寒假01</title>
      <link href="/posts/ACM_2024Winter_NCD01.html"/>
      <url>/posts/ACM_2024Winter_NCD01.html</url>
      
        <content type="html"><![CDATA[<h1>A.DFS搜索</h1><p><strong>1签</strong></p><h2 id="题意">题意</h2><p>题目字面意思，问能不能在长度为 $n$ 的字符串 $s$ 中找到子序列&quot;DFS&quot;和&quot;dfs&quot;；</p><h2 id="解题思路">解题思路</h2><p>直接暴力搜索<br>时间复杂度 $O(n)$</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s,s1,s2;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    s1=<span class="string">&quot;DFS&quot;</span>;s2=<span class="string">&quot;dfs&quot;</span>;</span><br><span class="line">    <span class="type">int</span> cnt1,cnt2;cnt1=cnt2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt1&lt;<span class="number">3</span>&amp;&amp;c==s1[cnt1]) cnt1++;</span><br><span class="line">        <span class="keyword">if</span>(cnt2&lt;<span class="number">3</span>&amp;&amp;c==s2[cnt2]) cnt2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt1&gt;=<span class="number">3</span>) cout &lt;&lt; <span class="number">1</span>; <span class="keyword">else</span> cout &lt;&lt; <span class="number">0</span>; cout &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(cnt2&gt;=<span class="number">3</span>) cout &lt;&lt; <span class="number">1</span>; <span class="keyword">else</span> cout &lt;&lt; <span class="number">0</span>; cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.关鸡</h1><p><strong>模拟</strong></p><h2 id="题意-2">题意</h2><p>有一条宽为$2$，长为$2*10^9+1$的管道，每个格子的坐标标记为$(x,y)$，$x\in[-10^9,10^9],y\in [1,2]$<br>管道内有$n$个障碍，给定障碍的坐标<br>鸡哥在$(0,1)$处，可以上下左右移动，但不能穿过障碍<br>求最少还需多少个障碍物才能使鸡哥被困在管道内无法到达管道两端</p><h2 id="解题思路-2">解题思路</h2><p>将管道两排看作两侧，如果某处有障碍（下图红），只要它的另一侧相邻的位置中有一个有障碍（下图黄）即可堵住管道：<br><img src="/images/ACM/2024Winter_NCD01_B.png" alt="alt text"><br>换个角度，从管道左端到右端，对于每个障碍，check它对面且与它的$x$距离不大于$1$的位置是否有障碍，即可确定是否堵住管道。</p><p>要把鸡哥困在管道内，需要把鸡哥两侧管道全都堵住。</p><p>对于鸡哥的一侧管道，如果：<br>没有堵住，没有障碍，则需放置$2$个障碍；<br>没有堵住，至少有$1$个障碍，则需放置$1$个障碍；<br>已经堵住，则不需要放置障碍。</p><p>特别的，和鸡哥直接相邻的3个位置如果都有障碍，鸡哥就直接被困住了。</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;pll&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">int</span> f,fl,fr; f=fl=fr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:v)&#123;</span><br><span class="line">        cin &gt;&gt; x.second &gt;&gt; x.first; <span class="comment">// 为了方便排序，将x轴坐标放在前面</span></span><br><span class="line">        <span class="keyword">if</span>(x.first==<span class="number">-1</span>&amp;&amp;x.second==<span class="number">1</span>) f++;</span><br><span class="line">        <span class="keyword">if</span>(x.first==<span class="number">0</span>&amp;&amp;x.second==<span class="number">2</span>) f++;</span><br><span class="line">        <span class="keyword">if</span>(x.first==<span class="number">1</span>&amp;&amp;x.second==<span class="number">1</span>) f++;<span class="comment">//和鸡哥直接相邻的障碍数</span></span><br><span class="line">        <span class="keyword">if</span>(x.first&lt;=<span class="number">0</span>) fl=<span class="number">1</span>;<span class="comment">//鸡哥左侧有障碍</span></span><br><span class="line">        <span class="keyword">if</span>(x.first&gt;=<span class="number">0</span>) fr=<span class="number">1</span>;<span class="comment">//鸡哥右侧有障碍</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    <span class="type">int</span> ffl,ffr;ffl=ffr=<span class="number">0</span>;<span class="comment">//记录左右两侧是否被堵住</span></span><br><span class="line">    deque&lt;pll&gt; dq;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(dq.<span class="built_in">size</span>()&amp;&amp;v[i].first-dq.<span class="built_in">front</span>().first&gt;<span class="number">1</span>) dq.<span class="built_in">pop_front</span>();<span class="comment">//dq只保存[x-1,x]内的障碍</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:dq)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x.second!=v[i].second)&#123;<span class="comment">//如果有不同侧的障碍即堵住管道</span></span><br><span class="line">                <span class="keyword">if</span>(v[i].first&lt;=<span class="number">0</span>) ffl=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> ffr=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;dq.<span class="built_in">push_back</span>(v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">3</span>-f;<span class="comment">//直接围堵鸡哥</span></span><br><span class="line">    <span class="keyword">if</span>(ffl&amp;&amp;ffr) ans=<span class="built_in">min</span>(ans,<span class="number">0ll</span>);<span class="comment">//左右两侧都被堵住，无需添加</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ffl&amp;&amp;fr||fl&amp;ffr) ans=<span class="built_in">min</span>(ans,<span class="number">1ll</span>);<span class="comment">//一侧被堵住，另一侧有障碍，需要添加1个</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ffl||ffr) ans=<span class="built_in">min</span>(ans,<span class="number">2ll</span>);<span class="comment">//一侧被堵住，另一侧无障碍，需要添加2个</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(fl&amp;&amp;fr) ans=<span class="built_in">min</span>(ans,<span class="number">2ll</span>);<span class="comment">//两侧没被堵住，但有障碍，需要添加2个</span></span><br><span class="line">    <span class="comment">//其余情况不如直接围堵鸡哥</span></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C.按闹分配</h1><p><strong>贪心</strong></p><h2 id="题意-3">题意</h2><p>$n$个人在$1$个窗口前排队办事，第$i$个人办事需要时间$t_i$<br>开始为$0$时刻，每个人的不满意度$D_i$为其办完事的时刻$D_i$<br>工作人员安排队伍顺序使得所有人的不满意度之和 $S=\sum D_i$ 最小</p><p>你也来办事，需要时间$t_c$。你可以插队，但是因此增加的不满意度之和不能超过$M$<br>问你最早什么时候能办完事</p><h2 id="解题思路-3">解题思路</h2><p>根据贪心的思想，初始使得不满意度之和最小的排序是按照$t_i$从小到大排序<br>你插队导致的不满意度之和的增量为：你插队的位置之后的人数*你的办事时间<br>因此你后面的人数不得超过 $M/t_c$ 个<br>在这个约束下计算前缀和即可</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,Q,tc,M;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; Q &gt;&gt; tc;</span><br><span class="line">    <span class="built_in">create_vec</span>(t,n);</span><br><span class="line">    <span class="built_in">SORT</span>(t);</span><br><span class="line">    vector&lt;ll&gt; St;</span><br><span class="line">    St.<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) St.<span class="built_in">pb</span>(St.<span class="built_in">back</span>()+t[i]);</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        cin &gt;&gt; M;</span><br><span class="line">        ll x=M/tc;</span><br><span class="line">        ll pl=<span class="built_in">max</span>(<span class="number">0ll</span>,n-x);</span><br><span class="line">        cout &lt;&lt; St[pl]+tc &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>D.数组成鸡</h1><p><strong>思维</strong></p><h2 id="题意-4">题意</h2><p>给定一个长度为$n$的整数数组，每次操作可以使所有元素都$+1$或都$-1$。<br>$Q$次询问，问任意次操作后能否使数组所有元素的乘积等于给定的数$M$（$-1e9\le M \le 1e9$）。</p><h2 id="解题思路-4">解题思路</h2><p>询问的$M$范围不大，所以数组稍微长一点儿，就很可能溢出$1e9$的范围。</p><p>由于元素都是整数，若数组中绝对值大于$1$的元素的个数超过$20$个，那么乘积的绝对值最小为$2^20$，超过$1e9$。</p><p>枚举出现过的数字$x_i$，再向$x_i$两边枚举它附近的数字$t$，使全数组$-t$，然后直接计算数组的乘积进行$check$。<br>当乘积的绝对值已经超过$1e9$，即出现最多$20$个绝对值大于$1$的元素时，直接判不合法，$check$枚举的元素个数是比较少的。<br>若最终乘积的绝对值不大于$1e9$，则加入答案集合。</p><p>询问时在答案中二分查找即可。</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,Q,t;cin &gt;&gt; n &gt;&gt; Q;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    set&lt;ll&gt; ans; ans.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">    set&lt;ll&gt; exi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a)&#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        exi.<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](ll x) -&gt; <span class="type">bool</span>&#123;</span><br><span class="line">        ll tt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;y:a)&#123;</span><br><span class="line">            tt*=y+x;</span><br><span class="line">            <span class="keyword">if</span>(tt==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(tt)&gt;<span class="number">1e9</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;ans.<span class="built_in">insert</span>(tt);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:exi)&#123;</span><br><span class="line">        t=-x<span class="number">-1</span>; <span class="keyword">while</span>(<span class="built_in">check</span>(t)) t--;</span><br><span class="line">        t=-x+<span class="number">1</span>; <span class="keyword">while</span>(<span class="built_in">check</span>(t)) t++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span>(ans.<span class="built_in">count</span>(t)) cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>E.本题又主要考察了贪心</h1><p><strong>DFS、诈骗</strong></p><h2 id="题意-5">题意</h2><p>$n$个人参加比赛，当前第$i$个人已经得到了$a_i$分，接下来还有$m$轮比赛<br>每轮两个人PK,赢的人$+3$分；平局则每人$+1$分<br>给定$m$轮比赛的名单，问$1$号选手能取得的最高名次</p><h2 id="解题思路-5">解题思路</h2><p>直接贪心很难贪（反正我是贪不出来）<br>由于人数和局数很少，直接DFS到每种结局，找到最优解即可<br>时间复杂度：$O(3^m)$</p><h2 id="参考程序-5">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pll&gt; q; <span class="comment">//记录每轮比赛的参赛选手</span></span><br><span class="line">ll n,m,ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(vector&lt;ll&gt; a,ll i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==m)&#123;</span><br><span class="line">        ll cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:a) <span class="keyword">if</span>(x&gt;a[<span class="number">0</span>]) cnt++;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,cnt);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;ll&gt; aa=a,ab=a,ac=a;</span><br><span class="line">    aa[q[i].first<span class="number">-1</span>]+=<span class="number">3</span>;<span class="comment">//a赢</span></span><br><span class="line">    <span class="built_in">DFS</span>(aa,i+<span class="number">1</span>);</span><br><span class="line">    ab[q[i].second<span class="number">-1</span>]+=<span class="number">3</span>;<span class="comment">//b赢</span></span><br><span class="line">    <span class="built_in">DFS</span>(ab,i+<span class="number">1</span>);</span><br><span class="line">    ac[q[i].first<span class="number">-1</span>]+=<span class="number">1</span>;<span class="comment">//平局</span></span><br><span class="line">    ac[q[i].second<span class="number">-1</span>]+=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">DFS</span>(ac,i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ans=INF;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a) cin &gt;&gt; x;</span><br><span class="line">    q.<span class="built_in">clear</span>();</span><br><span class="line">    ll u,v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;v) <span class="built_in">swap</span>(u,v);</span><br><span class="line">        q.<span class="built_in">pb</span>(&#123;u,v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DFS</span>(a,<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>F.鸡数题！</h1><p><strong>概率论-排列组合</strong></p><h2 id="题意-6">题意</h2><p>将$n$位的最大二进制数$111\cdots 1$（n个1）的每一位$1$分配给$m$个数，且每个数都不为$0$，问有多少种分配方案</p><h2 id="解题思路-6">解题思路</h2><p>$n$个不同的球放入$m$个不同的盒子，每个盒子至少一个球，有多少种放法<br>答案为第二类斯特林数$S(n,m)$<br>通项公式：$S(n,m)=\sum\limits_{i=0}^m\dfrac{(-1)^{m-i}\times i^n}{i!\times (m-i)!}$</p><h2 id="参考程序-6">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ll pown[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;m) &#123;cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">        pown[i]=<span class="built_in">qcpow</span>(i,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Prepare_Factorium</span>(m);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">        ll t=<span class="built_in">mul</span>(pown[i],<span class="built_in">mul</span>(Fac_inv[i],Fac_inv[m-i]));</span><br><span class="line">        <span class="keyword">if</span>((m-i)&amp;<span class="number">1</span>) t=MOD-t;</span><br><span class="line">        <span class="built_in">addto</span>(ans,t);</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>G.why买外卖</h1><p><strong>贪心</strong></p><h2 id="题意-7">题意</h2><p>有$n$张外卖券，第$i$张满$a_i$减$b_i$，$a_i$为餐品原价。<br>所有券可以叠加使用，你手上有$m$元，问你最多可以购买到原价为多少的餐品</p><h2 id="解题思路-7">解题思路</h2><p>假设餐品原价为$x$，则所有$a_i&lt;x$的券都可以使用。<br>根据使用门槛$a_i$对券排序，对减免部分做前缀和。<br>在每个门槛处计算：该门槛需支付的价格$x$（或溢出的优惠）=当前门槛-减免金额<br>如果$x$小于$m$，则更新答案，当前门槛下最高餐品价格为$m+减免金额$</p><h2 id="参考程序-7">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;pll&gt; <span class="title">vp</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:vp) cin &gt;&gt; x.first &gt;&gt; x.second;</span><br><span class="line">    <span class="built_in">SORT</span>(vp);</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">S</span><span class="params">(n+<span class="number">1</span>)</span></span>;S[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) S[i]=S[i<span class="number">-1</span>]+vp[i<span class="number">-1</span>].second;</span><br><span class="line">    ll ans=m;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vp[i<span class="number">-1</span>].first-S[i]&lt;=m)&#123;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,S[i]+m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>H.01背包，但是bit</h1><p><strong>位运算</strong></p><h2 id="题意-8">题意</h2><p>有$n$个物品，第$i$个物品的价值为$v_i$，重量为$w_i$，每个物品只有一个。<br>选定物品的重量之和定义为这些物品各自重量的“或”和，即$w=w_1|w_2|w_3|\cdots|w_c$；价值之和定义为这些物品各自重量的初等代数和：$v=\sum v_i$<br>问选定物品的重量之和不超过$m$的情况下，价值之和的最大值</p><h2 id="解题思路-8">解题思路</h2><p>或运算的性质：有$1$出$1$，全$0$出$0$。</p><p>把所有“重量”看作二进制。</p><p>假设选定物品后结果为$x$，那么$x$的每个$1bit$的位置，一定有某个被选中的物品的重量在该位上是$1bit$。</p><p>枚举所有允许出现$1$的位置的所有情况。<br>将$m$的某一$1bit$置$0$，则该位的低位可以任意取值，高位不变。<br>如$m=1010000B$，将第二个$1bit$置$0$，则$1bit$的合法位置变为$1001111$。<br>确定了$1bit$的合法位置，那每个物品只能是选或不选。<br>遍历$m$的所有$1bit$，计算将其置$0$的情况：遍历所有物品，应选尽选。<br>取所有情况的最大值。</p><h2 id="参考程序-8">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ll&gt; v,w;</span><br><span class="line">ll n,m,ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    ll t=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span>((w[i]&amp;x)==w[i])</span><br><span class="line">            t+=v[i];</span><br><span class="line">    ans=<span class="built_in">max</span>(ans,t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; ans=<span class="number">0</span>;</span><br><span class="line">    v.<span class="built_in">resize</span>(n); w.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,<span class="number">29</span>) <span class="keyword">if</span>(m&amp;(<span class="number">1</span>&lt;&lt;i))&#123;</span><br><span class="line">        <span class="built_in">Update</span>((m^(<span class="number">1</span>&lt;&lt;i))|((<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>));</span><br><span class="line">        <span class="comment">//m^(1&lt;&lt;i)：m的第i位置0</span></span><br><span class="line">        <span class="comment">//(1&lt;&lt;i)-1：低i位全1</span></span><br><span class="line">    &#125;<span class="built_in">Update</span>(m);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><a href="http://I.It">I.It</a>’s bertrand paradox. Again!</h1><p><strong>概率论</strong></p><h2 id="题意-9">题意</h2><p>现在有两种在$x\in [-100,100],y\in [-100,100]$平面范围内生成（圆心在整点上且半径为整数的）圆形的算法（仅第3步不同）：</p><ol><li>均匀随机生成一个 $(-100,100)$ 内的整点 $(x,y)$</li><li>均匀随机生成一个 $[1,100]$ 内的整数半径 $r$</li></ol><p>bit的检验：不满足在范围内，返回第2步，即仅重新生成$r$<br>buaa的检验：不满足在范围内，返回第1步，即重新生成一个圆</p><p>现在给出其中某个算法的生成 $10^5$ 个圆的结果，问是由哪个算法生成的</p><h2 id="解题思路-9">解题思路</h2><p>两种算法下，生成结果的圆心和半径的分布是不同的。<br>明显bit的方法圆心是均匀分布在平面内的，而buaa的方法不是。</p><p>根据抽样分布原理，大量独立同分布随机变量和的极限分布是正态分布。<br>因此对样本建立统计量，使得两种算法下，该统计量有显著不同即可。<br>此处建立的统计量$U$为：圆心到原点的距离的均值$A(\sqrt{x^2+y^2})$。<br>用两种算法生成样本，暴算得到$U_{buaa}\approx56，U_{bit}\approx 75$。</p><h2 id="参考程序-9">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="type">double</span> sum=<span class="number">0</span>;</span><br><span class="line">    ll x,y;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        sum+=<span class="built_in">sqrt</span>(x*x+y*y);</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">    &#125;sum/=n;</span><br><span class="line">    <span class="keyword">if</span>(sum&lt;<span class="number">65</span>) cout &lt;&lt; <span class="string">&quot;buaa-noob&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;bit-noob&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>J.又鸟之亦心</h1><p><strong>思维</strong></p><h2 id="题意-10">题意</h2><p>两个人分别在数轴的$x,y$位置。<br>接下来$n$天，第$i$天必须从两人中选择一人到$a_i$的位置。<br>记这$n$天内两人最远的距离为$D$，决策使得$D$最小，求这个最小的$D$</p><h2 id="解题思路-10">解题思路</h2><p>二分答案$D$，判断是否存在一种决策使得两人最远距离不超过$D$。</p><p>忽略两人的身份，第$i$天一定有一个人的位置在$a_i$，记录另一个人可能的位置集合$s$。<br>对于二分点，遍历每个$a_i$，更新$s$，使得$s$中的点与$a_i$的距离不超过$D$。<br>如果$s$为空，说明不存在一种决策使得两人最远距离不超过$D$。</p><h2 id="参考程序-10">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> ll N = <span class="number">200005</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,x,y;cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="built_in">create_vec</span>(a,n);</span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](ll d) -&gt; <span class="type">bool</span>&#123;</span><br><span class="line">        set&lt;ll&gt; s;</span><br><span class="line">        ll lst=y;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(x-y)&gt;d) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        s.<span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t:a)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(t-lst)&lt;=d) s.<span class="built_in">insert</span>(lst);</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;*s.<span class="built_in">begin</span>()&lt;t-d) s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;*s.<span class="built_in">rbegin</span>()&gt;t+d) s.<span class="built_in">erase</span>(*s.<span class="built_in">rbegin</span>());</span><br><span class="line">            lst=t;</span><br><span class="line">        &#125;<span class="keyword">return</span> !s.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    ll l=<span class="number">0</span>,r=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        ll mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>K.牛镇公务员考试</h1><p><strong>图论</strong></p><h2 id="题意-11">题意</h2><p>有$n$道题，每道题的题目为：“第$a_i$题的答案是（）？”<br>每题有<code>A B C D E</code>五个选项，选项的内容是字符串<code>ABCDE</code>的一个排列，记为字符串$s_i$<br>例如第$i$题的题目为：</p><p>第$a_i$题的答案是（）？<br>A. $s_i[0]$ B. $s_i[1]$ C. $s_i[2]$ D. $s_i[3]$ E. $s_i[4]$</p><p>求答对所有题目的方案数</p><h2 id="解题思路-11">解题思路</h2><p>将题目看作节点。<br>第$i$道题决定了第$a_i$道题的答案，视为一条从$i$到$a_i$的有向边。<br>同时，每个节点的出度为$1$，这意味着每个连通分量都是一个内向基环树。<br>（内向基环树：每个节点的出度为$1$的弱连通图）</p><p>反过来看，一旦确定了第$a_i$道题的答案，第$i$道题的答案也就确定了。<br>因此对于一条链，只要确定了一个节点的答案，整条链的答案也就唯一确定了。<br>显然在内向基环树中，链一定是挂在某个环上，链的答案随环的选择而唯一确定，因此可以忽略链。</p><p>对于环，先确定一个节点的答案（5种），然后递推确定整个环的答案，判断是否合法。<br>每个环的方案数在$0-4$之间</p><p>最终答案为每个连通分量方案数的乘积</p><h2 id="参考程序-11">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n ;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; a[i] &gt;&gt; s[i];</span><br><span class="line">        a[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        ll j=i;</span><br><span class="line">        <span class="keyword">while</span>(vis[j]==<span class="number">-1</span>)&#123;</span><br><span class="line">            vis[j]=i;</span><br><span class="line">            j=a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(vis[j]!=i) <span class="keyword">continue</span>;</span><br><span class="line">        vector&lt;ll&gt; cycle;<span class="comment">//环</span></span><br><span class="line">        ll k=j;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            cycle.<span class="built_in">push_back</span>(k);</span><br><span class="line">            k=a[k];</span><br><span class="line">        &#125;<span class="keyword">while</span>(k!=j);</span><br><span class="line">        ll res=<span class="number">0</span>,t;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line">            t=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x:cycle) t=s[x][t]-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(t==i) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">multo</span>(ans,res);</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>L.要有光</h1><p><strong>诈骗题</strong></p><h2 id="题意-12">题意</h2><p>给了一些几何形状的方程，求在<strong>地面</strong>（$z=0$）上的最大阴影面积</p><h2 id="解题思路-12">解题思路</h2><p>题目拐弯抹角吓唬人///<br>保证符合题意的状态是光源处于$xOy$平面上($z=0$)。<br>目的是求一个$xOy$平面上的梯形阴影的面积。<br>上底长$2w$，下底长$4w$，高为$c$，面积为$3wc$。</p><h2 id="参考程序-12">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll c,d,h,w;</span><br><span class="line">    cin &gt;&gt; c &gt;&gt; d &gt;&gt; h &gt;&gt; w;</span><br><span class="line">    cout &lt;&lt; w*<span class="number">3</span>*c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>M.牛客老粉才知道的秘密</h1><p><strong>2签</strong></p><h2 id="题意-13">题意</h2><p>某场比赛一共有$n$道题目，但每面只能显示$6$道。<br>点击<code>下一页</code>时，如果后面的题目足够$6$题，则显示下面的$6$题，否则显示最后6题。<br>点击<code>上一页</code>时，如果前面的题目足够$6$题，则显示上面的$6$题，否则显示最前6题。<br>求比赛中可能出现在第一题位置的题目数量。</p><h2 id="解题思路-13">解题思路</h2><p>如果题目数量是$6$的倍数，那页面可能的题目排布为$n/6$。<br>如果题目数量不是$6$的倍数，<br>从第一页到最后一页，可能的题目排布为$n/6+1$；<br>从最后一页到第一页，可能的题目排布为$n/6+1$。<br>去除首页尾页，可能的题目排布为$(n/6)*2$。</p><h2 id="参考程序-13">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 200005</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">6</span>==<span class="number">0</span>) cout &lt;&lt; n/<span class="number">6</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; n/<span class="number">6</span>*<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024牛客寒假 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数据库原理》笔记</title>
      <link href="/posts/Note_Database_System.html"/>
      <url>/posts/Note_Database_System.html</url>
      
        <content type="html"><![CDATA[<h1>一、概述（理解、记忆）</h1><h2 id="1-2-基本知识">1.2. 基本知识</h2><h3 id="1-数据、数据库">1. 数据、数据库</h3><ul><li>数据：表示客观事物的符号。</li><li>数据类型：文本、图形、图像、声音等。</li><li>数据库：<strong>长期存储</strong>在计算机内、<strong>有组织</strong>的、<strong>可共享</strong>的大量数据的集合。</li></ul><h3 id="2-数据的特征">2. 数据的特征</h3><ul><li>静态特征：数据结构、数据联系、数据约束</li><li>动态特征：数据操作</li></ul><h3 id="2-数据库的特点">2. 数据库的特点</h3><p>1.长期存储 2.有组织 3.可共享</p><h3 id="3-数据库管理系统（DBMS）">3. 数据库管理系统（DBMS）</h3><ul><li>定义：提供给用户，并帮助用户建立、使用和管理数据库的软件系统。</li><li><strong>是数据库系统（DBS）的核心</strong>。</li><li>建立在操作系统之上，位于操作系统与用户之间。</li></ul><h3 id="4-数据库的主要功能（和SQL语言相对应）">4. 数据库的主要功能（和SQL语言相对应）</h3><ul><li>数据定义：数据定义语言（DDL），定义数据库的数据对象及其关系</li><li>数据操纵：数据操纵语言（DML），增删改查</li><li>事务和运行管理：数据控制语言（DCL），对数据库的安全性、完整性、并发性和恢复性进行保护控制</li><li>组织、存储和管理数据</li><li>数据库的建立和维护</li></ul><h3 id="5-数据库系统（DBS）的结构">5. 数据库系统（DBS）的结构</h3><ul><li>硬件：计算机硬件和数据库专用硬件</li><li>软件：操作系统（OS）、数据库管理系统（DBMS）（核心）、开发工具（数据库专用工具、程序设计语言）和应用系统</li><li>人员：数据库管理员（DBA）、数据库设计人员、应用程序员和最终用户</li></ul><h3 id="6-数据库管理员（DBA）的主要职责">6. 数据库管理员（DBA）的主要职责</h3><ul><li>决定数据库的信息内容和结构</li><li>决定数据库的存储结构和存取策略</li><li>定义数据库的安全性要求和完整性约束</li></ul><h3 id="7-数据管理技术的3个阶段">7. 数据管理技术的3个阶段</h3><ul><li>人工管理阶段<br>数据不保存、没有结构化、不独立、不共享、冗余度高</li><li>文件管理阶段<br>文件系统：数据<strong>可长期保存</strong>但没有结构化、独立性低、共享性低、冗余度高</li><li><strong>数据库系统阶段</strong><br>数据库系统：<strong>数据结构化、独立性高、共享性高、冗余度低</strong></li></ul><h2 id="1-3-数据模型">1.3. 数据模型</h2><h3 id="1-数据模型的组成">1. 数据模型的组成</h3><p>1.数据结构 2.数据操作（增删改查） 3.数据的完整性约束</p><h3 id="2-数据模型">2. 数据模型</h3><p>（实际问题） $\Rightarrow$ 概念模型（高层） $\Rightarrow$ 逻辑模型 $\Rightarrow$ 物理模型（底层）</p><h3 id="3-概念模型">3. 概念模型</h3><ol><li>概念模型：数据及其关系的图形表示。如：实体-联系图（<strong>E-R图</strong>）</li><li>要求：简单、清晰、易于理解，<strong>独立于DBMS</strong></li><li>名词解释</li></ol><ul><li>表（实体集、关系）：同一类实体的集合</li><li>元组（行、记录、实体）：客观存在且相互区别的事物</li><li>属性（列、字段、数据项）：实体所具有的特性</li><li>域（值域）：属性的取值范围</li><li>码/键：唯一标识实体的属性或属性组</li><li>候选键：唯一标识实体的最小属性组</li><li>主属性：包含在任一候选键中的属性</li><li>主键：用户选定的候选键</li><li>外键：一个实体集的属性集，它是另一个实体集的主键</li><li>超键：在键中删除一个或多个属性后，仍然能唯一标识实体的属性或属性组</li><li>全键：包含所有属性的候选键</li><li>联系：实体集之间或内部的关联。类型：一对一、一对多、多对多</li><li>元/度：表中属性的个数</li></ul><h3 id="4-逻辑模型">4. 逻辑模型</h3><ul><li>定义：概念模型的DBMS表示</li><li>分类：层次模型、网状模型、<strong>关系模型</strong>、面向对象模型等</li><li>关系模型</li></ul><ol><li>关系（表）</li><li>关系模式（表头）：关系的结构描述</li><li>关系模型的特点：满足1NF、属性和元组不重复且无序。</li><li>关系数据库：支持关系模型的数据库</li><li>关系模式的数学表达：<br>$R(U,F),U={A_1,A_2,\cdots,A_n},F={A_i\rightarrow A_j,\cdots}$</li></ol><h2 id="1-4-数据库系统结构">1.4. 数据库系统结构</h2><h3 id="1-数据库系统的模式结构">1. 数据库系统的模式结构</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数据库系统</span><br><span class="line">|<span class="string">---应用（一个外模式可以有多个应用）</span></span><br><span class="line"><span class="string"></span>|<span class="string">---DBMS</span></span><br><span class="line"><span class="string"></span>|<span class="string">   </span>|<span class="string">---外模式（一个DBMS可以有多个外模式）</span></span><br><span class="line"><span class="string"></span>|<span class="string">   </span>|<span class="string">---模式（一个）</span></span><br><span class="line"><span class="string"></span>|<span class="string">   </span>|<span class="string">---内模式（一个）</span></span><br><span class="line"><span class="string"></span>|<span class="string">---数据库</span></span><br></pre></td></tr></table></figure><h3 id="2-数据库系统的三级模式结构">2. 数据库系统的三级模式结构</h3><ol><li>外模式（子模式、用户模式）：面向用户的局部数据的逻辑结构和特征的描述，数据库用户的数据视图</li></ol><ul><li>一个数据库可以有多个外模式</li><li>一个外模式可以对应多个应用，一个应用只能对应一个外模式</li></ul><ol start="2"><li>模式（结构模式、逻辑模式）：数据库中全体数据的逻辑结构和特征的描述</li></ol><ul><li>一个数据库只有一个模式</li><li>DBMS的核心</li></ul><ol start="3"><li>内模式（存储模式、物理模式）：数据库在计算机内部的表示方式和数据存储方式</li></ol><h3 id="3-数据库系统的二级映像">3. 数据库系统的二级映像</h3><ol><li>外模式/模式映像：保证了数据库的逻辑独立性</li><li>模式/内模式映像：保证了数据库的物理独立性</li><li>逻辑独立性和物理独立性合称数据独立性</li></ol><h2 id="1-5-数据库系统的体系结构">1.5. 数据库系统的体系结构</h2><ol><li>C/S结构：客户/服务器结构</li><li>B/S结构：浏览器/服务器结构</li></ol><p>外部网络（表示层）$\Leftrightarrow$ 应用服务器（处理层）$\Leftrightarrow$ 内部网络（数据层）</p><h1>二、关系运算</h1><h2 id="2-1-关系数据语言">2.1. 关系数据语言</h2><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">关系数据语言</span><br><span class="line">|<span class="string">---关系演算语言</span></span><br><span class="line"><span class="string"></span>|<span class="string">   </span>|<span class="string">---关系代数语言（如ISBL）</span></span><br><span class="line"><span class="string"></span>|<span class="string">   </span>|<span class="string">---元组关系演算语言（如ALPHA）</span></span><br><span class="line"><span class="string"></span>|<span class="string">   </span>|<span class="string">---域关系演算语言（如QBE）</span></span><br><span class="line"><span class="string"></span>|<span class="string">---关系代数/演算双重语言：结构化查询语言（SQL）</span></span><br></pre></td></tr></table></figure><h2 id="2-2-关系代数语言">2.2. 关系代数语言</h2><h3 id="基本运算">基本运算</h3><p>并$\cup$、差$-$、积$\times$、选择$\sigma$、投影$\pi$（注意：投影需要去重，即运算后记录数量可能变少）</p><h3 id="导出运算">导出运算</h3><p>交$\cap$、除$\div$、连接$\Join$</p><h3 id="核心运算">核心运算</h3><p>选择$\sigma$、投影$\pi$、连接$\Join$</p><h2 id="2-3-基于关系代数语言的更新运算">2.3. 基于关系代数语言的更新运算</h2><h3 id="1-插入运算">1. 插入运算</h3><p>建立一个与原表$R$具有相同属性的临时关系$T$，计算$R\cup T$</p><h3 id="2-删除运算">2. 删除运算</h3><p>建立一个与原表$R$具有相同属性的临时关系$T$，计算$R-T$</p><h3 id="3-修改运算">3. 修改运算</h3><p>先删除，再插入</p><h2 id="2-4-查询优化">2.4. 查询优化</h2><p>在做笛卡尔积前先尽可能地进行选择和投影，以减少计算量。</p><h2 id="寄巧">*寄巧</h2><p>查询不满足某条件的元组（如不能提供A的供应商）：$\pi_{SNO}(S)-\pi_{SNO}(S\Join\sigma_{PNAME=A} (P))$</p><p>查询满足多重条件的元组（如同时提供A和B的供应商）：<br>$\pi_{SNO}(S\Join\sigma_{PNAME=A} (P))\cap\pi_{SNO}(S\Join\sigma_{PNAME=B} (P))$</p><h1>三、数据完整性</h1><p>数据完整性是指：数据的正确性、相容性和一致性</p><h3 id="1-实体完整性">1. 实体完整性</h3><ul><li>定义：主属性A的值不能为空值（Not Null）</li><li>关键词：主键（Primary Key）</li></ul><h3 id="2-参照完整性">2. 参照完整性</h3><ul><li>定义：外键列的值必须是其参照表的主键列的值或空值</li><li>关键词：外键（Foreign Key）</li></ul><h3 id="3-用户自定义完整性">3. 用户自定义完整性</h3><ul><li>定义：用户根据应用的需要定义的完整性约束</li><li>关键词：默认值（Default）、检查（Check）、非空（Not Null）、唯一（Unique）</li></ul><h2 id="3-4-完整性控制机制">3.4. 完整性控制机制</h2><h3 id="1-完整性控制3个层面">1. 完整性控制3个层面</h3><ul><li>属性级（列级）：对特定属性（列）的条件约束</li><li>元组级（行级）：元组各个属性之间的约束（如售价必须大于进价）</li><li>关系级（表级）：不同元组、不同表之间的约束（如外键）</li></ul><h3 id="2-完整性控制机制具备的功能">2. 完整性控制机制具备的功能</h3><p>定义功能、检查功能、违约处理</p><h3 id="3-定义功能">3. 定义功能</h3><p>提供完善的定义完整性约束的功能</p><h3 id="4-检查功能">4. 检查功能</h3><p>对于增删改的更新操作，提供检查完整性约束违约的功能</p><p>两种检查方式：立即检查（单语句）、延迟检查（多语句）</p><h3 id="5-违约处理">5. 违约处理</h3><p>对于破坏完整性约束的更新操作，提供相应的违约处理功能</p><ol><li>拒绝更新：主键、非空、外键</li><li>置空：非主属性、外键</li><li>级联更新：把违约的更新转化为非违约更新，然后接受更新</li></ol><h1>四、SQL Server</h1><h2 id="结构化查询语言（SQL-Structured-Query-Language）">结构化查询语言（SQL, Structured Query Language）</h2><h2 id="1-数据定义语言（DDL-Data-Definition-Language）">1. 数据定义语言（DDL, Data Definition Language）</h2><ul><li>相关功能：定义数据的关系及完整性约束</li><li>关键词：Create、Alter、Drop</li></ul><h2 id="2-数据操纵语言（DML-Data-Manipulation-Language）">2. 数据操纵语言（DML, Data Manipulation Language）</h2><ul><li>相关功能：操纵数据（增删改查）</li><li>关键词：Insert、Delete、Update、Select（对应增删改查）</li></ul><h2 id="3-数据控制语言（DCL-Data-Control-Language）">3. 数据控制语言（DCL, Data Control Language）</h2><ul><li>相关功能：控制数据库的安全性、完整性、并发性和恢复性</li><li>关键词：Grant、Revoke、Deny、Check</li></ul><h1>四（一）、数据定义语言（DDL）与完整性约束实现</h1><h2 id="3-1-数据定义语言（DDL）">3.1. 数据定义语言（DDL）</h2><ul><li>操作：创建Create、修改ALTER、删除DROP</li><li>对象：数据库Database、表Table、视图View、索引Index、登录Login、数据库用户User、数据库角色Role、触发器Trigger、断言Assertion、过程Procedure</li><li>数据库（存储文件）属于内模式，表属于模式，视图属于外模式，索引隶属于表。</li><li>数据库和断言没有修改操作</li></ul><h2 id="3-2-数据库和表的定义">3.2. 数据库和表的定义</h2><h3 id="1-创建数据库">1. 创建数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> Database EBook<span class="operator">&lt;</span>数据库名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">On</span>(Name <span class="operator">=</span> <span class="string">&#x27;EBook&#x27;</span><span class="operator">&lt;</span>数据库逻辑名称<span class="operator">&gt;</span>,</span><br><span class="line">    FileName <span class="operator">=</span> <span class="string">&#x27;D:\DataBases\EBook.mdf&#x27;</span><span class="operator">&lt;</span>数据库物理名称<span class="operator">&gt;</span>,</span><br><span class="line">    <span class="comment">-- 创建前需要先创建文件夹</span></span><br><span class="line">    Size <span class="operator">=</span> <span class="number">5</span>MB<span class="operator">&lt;</span>初始大小<span class="operator">&gt;</span>,</span><br><span class="line">    FileGrowth <span class="operator">=</span> <span class="number">1</span>MB<span class="operator">&lt;</span>增长大小<span class="operator">&gt;</span>,</span><br><span class="line">    MaxSize <span class="operator">=</span> <span class="number">100</span>MB<span class="operator">&lt;</span>最大大小<span class="operator">&gt;</span>)]</span><br><span class="line">[Log <span class="keyword">On</span>(Name <span class="operator">=</span> <span class="string">&#x27;EBook_log&#x27;</span><span class="operator">&lt;</span>日志逻辑名称<span class="operator">&gt;</span>,</span><br><span class="line">    FileName <span class="operator">=</span> <span class="string">&#x27;D:\DataBases\EBook_log.ldf&#x27;</span><span class="operator">&lt;</span>日志物理名称<span class="operator">&gt;</span>,</span><br><span class="line">    Size <span class="operator">=</span> <span class="number">1</span>MB<span class="operator">&lt;</span>初始大小<span class="operator">&gt;</span>,</span><br><span class="line">    FileGrowth <span class="operator">=</span> <span class="number">5</span><span class="operator">%</span><span class="operator">&lt;</span>增长大小(可以是百分比)<span class="operator">&gt;</span>,</span><br><span class="line">    MaxSize <span class="operator">=</span> Unlimited<span class="operator">&lt;</span>最大大小(可以是无限)<span class="operator">&gt;</span>)]</span><br></pre></td></tr></table></figure><h3 id="2-删除数据库">2. 删除数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Drop</span> Database EBook</span><br></pre></td></tr></table></figure><h3 id="3-创建表">3. 创建表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Use EBook</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Table</span> SyT<span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">(</span><br><span class="line">    <span class="comment">-- 格式：&lt;列名&gt; &lt;数据类型&gt; [属性级完整性约束条件],</span></span><br><span class="line">    <span class="keyword">No</span> <span class="type">int</span>,</span><br><span class="line">    Name <span class="type">char</span>(<span class="number">8</span>) <span class="keyword">Unique</span>,</span><br><span class="line">    Code <span class="type">char</span>(<span class="number">6</span>) <span class="keyword">Check</span>(Code <span class="keyword">like</span> <span class="string">&#x27;Sy[0-9][0-9][0-9][0-9]&#x27;</span>),</span><br><span class="line">    <span class="comment">-- [表级完整性约束条件]</span></span><br><span class="line">    <span class="keyword">Constraint</span> PK_SyT <span class="keyword">Primary</span> Key(<span class="keyword">No</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="4-修改表（修改表的结构，属于DDL）">4. 修改表（修改表的结构，属于DDL）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Use EBook</span><br><span class="line"><span class="comment">-- 添加属性：Add &lt;列名&gt; &lt;数据类型&gt; [属性级完整性约束条件]</span></span><br><span class="line"><span class="keyword">Alter</span> <span class="keyword">Table</span> SyT</span><br><span class="line">    <span class="keyword">Add</span> Age <span class="type">int</span> <span class="keyword">Not</span> <span class="keyword">Null</span></span><br><span class="line"><span class="comment">-- 修改属性：Alter Column &lt;列名&gt; &lt;新数据类型&gt;</span></span><br><span class="line"><span class="keyword">Alter</span> <span class="keyword">Table</span> SyT</span><br><span class="line">    <span class="keyword">Alter</span> <span class="keyword">Column</span> Name <span class="type">char</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment">-- 删除属性：Drop Column &lt;列名&gt;</span></span><br><span class="line"><span class="keyword">Alter</span> <span class="keyword">Table</span> SyT</span><br><span class="line">    <span class="keyword">Drop</span> <span class="keyword">Column</span> Age</span><br></pre></td></tr></table></figure><h3 id="5-删除表">5. 删除表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Use EBook</span><br><span class="line"><span class="keyword">Drop</span> <span class="keyword">Table</span> SyT</span><br></pre></td></tr></table></figure><h3 id="6-数据类型">6. 数据类型</h3><ul><li>数值型：int、float</li><li>字符型：char(n)</li><li>日期型：date</li><li>图片型：image</li></ul><h2 id="3-3-完整性约束实现">3.3. 完整性约束实现</h2><h3 id="1-实体完整性（主键）">1. 实体完整性（主键）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--建表时，属性级</span></span><br><span class="line"><span class="keyword">No</span> <span class="type">int</span> [<span class="keyword">Constraint</span> PK_No] <span class="keyword">Primary</span> Key</span><br><span class="line"><span class="comment">--建表时，关系级,可以是属性组</span></span><br><span class="line">[<span class="keyword">Constraint</span> PK_No] <span class="keyword">Primary</span> Key(<span class="keyword">No</span>,Name)</span><br><span class="line"><span class="comment">--修改表时，关系级（Primary Key要求属性已为NOT NULL）</span></span><br><span class="line"><span class="keyword">Alter</span> <span class="keyword">Table</span> SyT</span><br><span class="line">    <span class="keyword">Add</span> [<span class="keyword">Constraint</span> PK_No] <span class="keyword">Primary</span> Key(<span class="keyword">No</span>,Name)</span><br></pre></td></tr></table></figure><h3 id="2-参照完整性（外键）">2. 参照完整性（外键）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--建表时，关系级</span></span><br><span class="line"><span class="keyword">No</span> <span class="type">int</span> [<span class="keyword">Constraint</span> FK_No] <span class="keyword">References</span> CCT(<span class="keyword">No</span>)</span><br><span class="line"><span class="comment">--建表时，关系级</span></span><br><span class="line">[<span class="keyword">Constraint</span> FK_No] <span class="keyword">Foreign</span> Key(<span class="keyword">No</span>) <span class="keyword">References</span> CCT(<span class="keyword">No</span>)</span><br><span class="line"><span class="comment">--修改表时，关系级，级联更新</span></span><br><span class="line"><span class="keyword">Alter</span> <span class="keyword">Table</span> SyT</span><br><span class="line">    <span class="keyword">Add</span> [<span class="keyword">Constraint</span> FK_No] <span class="keyword">Foreign</span> Key(<span class="keyword">No</span>) <span class="keyword">References</span> CCT(<span class="keyword">No</span>)</span><br><span class="line">    <span class="keyword">On</span> <span class="keyword">Update</span> Cascade <span class="keyword">On</span> <span class="keyword">Delete</span> Cascade</span><br></pre></td></tr></table></figure><h3 id="3-用户自定义完整性（默认值、检查、非空、唯一）">3. 用户自定义完整性（默认值、检查、非空、唯一）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--建表时，属性级（NOT NULL只能在建表时定义）</span></span><br><span class="line"><span class="keyword">No</span> <span class="type">int</span> [<span class="keyword">Constraint</span> NN_No] <span class="keyword">Not</span> <span class="keyword">Null</span></span><br><span class="line">Name <span class="type">char</span>(<span class="number">8</span>) [<span class="keyword">Constraint</span> UQ_Name] <span class="keyword">Unique</span></span><br><span class="line"><span class="comment">--建表时，元组级</span></span><br><span class="line">[<span class="keyword">Constraint</span> SP] <span class="keyword">Check</span>(SPrice<span class="operator">&gt;</span>PPrice)</span><br><span class="line"><span class="comment">--修改表时，属性级</span></span><br><span class="line"><span class="keyword">Alter</span> <span class="keyword">Table</span> SyT</span><br><span class="line">    <span class="keyword">Add</span> [<span class="keyword">Constraint</span> CK_Code] <span class="keyword">Check</span>(Code <span class="keyword">like</span> <span class="string">&#x27;Sy[0-9][0-9][0-9][0-9]&#x27;</span>)</span><br><span class="line"><span class="comment">--修改表时，属性级，默认值</span></span><br><span class="line"><span class="keyword">Alter</span> <span class="keyword">Table</span> SyT</span><br><span class="line">    <span class="keyword">Add</span> [<span class="keyword">Constraint</span> DF_No] <span class="keyword">Default</span> <span class="number">0</span> <span class="keyword">For</span> Age</span><br></pre></td></tr></table></figure><p>like：模糊查询，%表示任意多个字符，_表示一个字符，[]表示一个字符集合，[a-z]表示a到z的任意一个字符，[^a-z]表示非a到z的任意一个字符</p><h3 id="4-删除完整性约束">4. 删除完整性约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Alter</span> <span class="keyword">Table</span> SyT</span><br><span class="line">    <span class="keyword">Drop</span> <span class="keyword">Constraint</span> DF_No</span><br></pre></td></tr></table></figure><h1>四（二）、数据操纵语言（DML）与数据查询</h1><h2 id="4-1-数据操纵语言（DML）">4.1. 数据操纵语言（DML）</h2><ul><li>操作：增Insert、删Delete、改Update、查Select</li><li>对象：表Table、视图View</li></ul><h2 id="4-2-添加记录">4.2. 添加记录</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Use EBook</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT[(<span class="keyword">No</span>,Name,Code)] <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;Sy0001&#x27;</span>)</span><br><span class="line"><span class="comment">-- 一句只能添加一条记录</span></span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;Sy0002&#x27;</span>)</span><br><span class="line"><span class="comment">-- 不指定列名，列名和值一一对应</span></span><br></pre></td></tr></table></figure><h2 id="4-3-删除记录">4.3. 删除记录</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Use EBook</span><br><span class="line"><span class="keyword">Delete</span> <span class="keyword">From</span> SyT [<span class="keyword">Where</span> <span class="keyword">No</span><span class="operator">=</span><span class="number">1</span><span class="operator">&lt;</span>条件<span class="operator">&gt;</span>]</span><br><span class="line"><span class="comment">-- 不加条件，删除所有记录</span></span><br></pre></td></tr></table></figure><h2 id="4-4-修改记录">4.4. 修改记录</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Use EBook</span><br><span class="line"><span class="keyword">Update</span> SyT <span class="keyword">Set</span> Name<span class="operator">=</span><span class="string">&#x27;王五&#x27;</span> [<span class="keyword">Where</span> <span class="keyword">No</span><span class="operator">=</span><span class="number">2</span><span class="operator">&lt;</span>条件<span class="operator">&gt;</span>]</span><br><span class="line"><span class="comment">-- 不加条件，修改所有记录</span></span><br></pre></td></tr></table></figure><h2 id="4-5-查询记录">4.5. 查询记录</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Use EBook</span><br><span class="line"><span class="keyword">Select</span> [<span class="operator">&lt;</span>行：<span class="keyword">All</span><span class="operator">/</span><span class="keyword">Distinct</span><span class="operator">/</span>Top n<span class="operator">&gt;</span>] <span class="operator">&lt;</span>列：<span class="operator">*</span><span class="operator">/</span><span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span> <span class="operator">&lt;</span>显示名<span class="number">1</span><span class="operator">&gt;</span>,<span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span> <span class="operator">&lt;</span>显示名<span class="number">2</span><span class="operator">&gt;</span>,...<span class="operator">&gt;</span> <span class="comment">--行：选择/列：投影</span></span><br><span class="line"><span class="keyword">From</span> SyT [<span class="keyword">Join</span> CCT <span class="keyword">On</span>(SyT.A<span class="operator">=</span>CCT.B)] <span class="comment">--连接</span></span><br><span class="line">[<span class="keyword">Where</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>] <span class="comment">--选择</span></span><br><span class="line">[<span class="keyword">Group</span> <span class="keyword">By</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [<span class="keyword">Having</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>]] <span class="comment">--分组、筛选分组</span></span><br><span class="line">[<span class="keyword">Order</span> <span class="keyword">By</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [<span class="keyword">Asc</span><span class="operator">/</span><span class="keyword">Desc</span>]] <span class="comment">--排序</span></span><br></pre></td></tr></table></figure><ol><li>笛卡尔积：<code>Select * From SyT,CCT</code></li><li>并集：<code>Select * From SyT Union Select * From CCT</code></li><li>交集：<code>Select * From SyT Intersect Select * From CCT</code></li><li>差集：<code>Select * From SyT Except Select * From CCT</code></li><li>条件表达式：<ul><li>区间：<code>Where No Between 1 And 3</code></li><li>列表：<code>Where No In(1,3)</code></li><li>匹配：<code>Where Name Like '张%'</code></li><li>空值：<code>Where Name Is Null</code></li><li>取反：<code>Where Not No=1</code></li></ul></li><li>统计（需要分组，除被统计量外，其他列必须在Group By中）：<ul><li>Count：<code>Select Count(*) From SyT</code></li><li>Sum：<code>Select Sum(No) From SyT</code></li><li>Avg：<code>Select Avg(No) From SyT</code></li><li>Max：<code>Select Max(No) From SyT</code></li><li>Min：<code>Select Min(No) From SyT</code></li></ul></li><li>嵌套查询：<code>Select … From SyT Where No In(Select No From CCT Where …)</code></li><li>Having子句：<code>Select … From SyT Group By HNo Having Count(*)&gt;1</code>，筛选满足特定条件的分组</li></ol><h1>专：SQL例题</h1><h2 id="1-创建数据库-2">1. 创建数据库</h2><p>创建一个名为<code>EBook</code>的数据库，数据库文件存放在<code>D:\DataBases</code>文件夹下，数据库文件名为<code>EBook.mdf</code>，日志文件名为<code>EBook_log.ldf</code>，数据库文件初始大小为<code>5MB</code>，增长大小为<code>1MB</code>，最大大小为<code>100MB</code>，日志文件初始大小为<code>1MB</code>，增长大小为<code>5%</code>，最大大小为<code>无限</code>。</p><h2 id="2-创建表">2. 创建表</h2><p>创建一个名为<code>SyT</code>的表，表中包含<code>No</code>、<code>Name</code>、<code>Code</code>三个属性，其中<code>No</code>为整型，<code>Name</code>为长度为<code>8</code>的字符型，<code>Code</code>为长度为<code>6</code>的字符型，<code>No</code>和<code>Name</code>不能为空，<code>Code</code>以<code>Sy</code>开头，后面跟着<code>4</code>位数字。</p><h2 id="3-添加记录">3. 添加记录</h2><p>向<code>SyT</code>表中添加一条记录，<code>No</code>为<code>1</code>，<code>Name</code>为<code>张三</code>，<code>Code</code>为<code>Sy0001</code>。</p><h2 id="4-删除记录">4. 删除记录</h2><p>删除<code>SyT</code>表中<code>No</code>为<code>1</code>的记录。</p><h2 id="5-添加属性">5. 添加属性</h2><p>向<code>SyT</code>表中添加一个名为<code>Age</code>的属性，属性类型为整型，属性值不能为空。</p><h2 id="6-修改属性">6. 修改属性</h2><p>将<code>SyT</code>表中<code>Name</code>属性的长度改为<code>10</code>。</p><h2 id="7-准备数据">7*. 准备数据</h2><p>利用以下语句创建名为<code>CCT</code>的表，并向其中添加记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">Table</span> CCT</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">No</span> <span class="type">int</span> <span class="keyword">Not</span> <span class="keyword">Null</span>,</span><br><span class="line">    Name <span class="type">char</span>(<span class="number">8</span>) <span class="keyword">Unique</span>,</span><br><span class="line">    Code <span class="type">char</span>(<span class="number">6</span>) <span class="keyword">Primary</span> Key</span><br><span class="line">)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> CCT <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;Sy0001&#x27;</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> CCT <span class="keyword">Values</span>(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;Sy0002&#x27;</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> CCT <span class="keyword">Values</span>(<span class="number">3</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;Sy0003&#x27;</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> CCT <span class="keyword">Values</span>(<span class="number">4</span>,<span class="string">&#x27;赵六&#x27;</span>,<span class="string">&#x27;Sy0004&#x27;</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> CCT <span class="keyword">Values</span>(<span class="number">5</span>,<span class="string">&#x27;孙七&#x27;</span>,<span class="string">&#x27;Sy0005&#x27;</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> CCT <span class="keyword">Values</span>(<span class="number">6</span>,<span class="string">&#x27;周八&#x27;</span>,<span class="string">&#x27;Sy0006&#x27;</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> CCT <span class="keyword">Values</span>(<span class="number">7</span>,<span class="string">&#x27;吴九&#x27;</span>,<span class="string">&#x27;Sy0007&#x27;</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> CCT <span class="keyword">Values</span>(<span class="number">8</span>,<span class="string">&#x27;郑十&#x27;</span>,<span class="string">&#x27;Sy0008&#x27;</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;Sy0001&#x27;</span>,<span class="number">20</span>)</span><br></pre></td></tr></table></figure><h2 id="7-实体完整性">7. 实体完整性</h2><p>将<code>SyT</code>表中<code>No</code>、<code>Name</code>属性组设为主键。</p><h2 id="8-参照完整性">8. 参照完整性</h2><p>将<code>SyT</code>表中<code>Code</code>属性修改为外键，参照<code>CCT</code>表中<code>Code</code>属性，级联更新。</p><h2 id="9-用户自定义完整性">9. 用户自定义完整性</h2><p>将<code>SyT</code>表中<code>Age</code>属性的默认值设为<code>0</code>。</p><h2 id="10-准备数据">10*.准备数据</h2><p>利用以下语句在<code>SyT</code>表中添加记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;Sy0002&#x27;</span>,<span class="number">21</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;Sy0003&#x27;</span>,<span class="number">22</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;赵六&#x27;</span>,<span class="string">&#x27;Sy0004&#x27;</span>,<span class="number">23</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;孙七&#x27;</span>,<span class="string">&#x27;Sy0005&#x27;</span>,<span class="number">24</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;周八&#x27;</span>,<span class="string">&#x27;Sy0006&#x27;</span>,<span class="number">25</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;吴九&#x27;</span>,<span class="string">&#x27;Sy0007&#x27;</span>,<span class="number">26</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;郑十&#x27;</span>,<span class="string">&#x27;Sy0008&#x27;</span>,<span class="number">27</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">2</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;Sy0001&#x27;</span>,<span class="number">21</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;Sy0002&#x27;</span>,<span class="number">22</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">2</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;Sy0003&#x27;</span>,<span class="number">23</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">2</span>,<span class="string">&#x27;赵六&#x27;</span>,<span class="string">&#x27;Sy0004&#x27;</span>,<span class="number">24</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">2</span>,<span class="string">&#x27;孙七&#x27;</span>,<span class="string">&#x27;Sy0005&#x27;</span>,<span class="number">25</span>)</span><br></pre></td></tr></table></figure><h2 id="10-查询记录">10. 查询记录</h2><ol><li>查询<code>SyT</code>表中年龄前5名的学生的序号、姓名、年龄。</li><li>统计<code>SyT</code>表中名为<code>张三</code>的学生的人数。</li><li>查询名字在<code>CCT</code>表中出现且在<code>SyT</code>表中未出现的学生的序号、姓名、编码。</li></ol><h1>五、概念模型和逻辑模型</h1><h2 id="5-1-概念模型（E-R图）">5.1. 概念模型（E-R图）</h2><p>1.实体：方框<br>2.属性：椭圆（主键用下划线标注）<br>3.关系：菱形</p><p>4.联系：线（实体与属性、实体与关系（标注1对1/1对n））<br><img src="ER.png" alt=""></p><h2 id="5-2-逻辑模型（关系模型）">5.2. 逻辑模型（关系模型）</h2><p>主键用下划线标注，外键用波浪线标注</p><p>上图的逻辑模型：</p><p>实体：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">供应商（商号（主键）、商名、城市、电话）</span><br><span class="line">项目（项目号（主键）、项目名、单位、负责人）</span><br><span class="line">零件（零件号（主键）、名称、规格、单价）</span><br><span class="line">仓库（仓库号（主键）、面积、电话）</span><br><span class="line">职工（工号（主键）、姓名、性别、职称）</span><br></pre></td></tr></table></figure><p>关系：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">供应（商号（主键、外键）、项目号（主键、外键）、供应量）</span><br><span class="line">库存（零件号（主键、外键）、仓库号（主键、外键）、库存量）</span><br><span class="line">工作（工号（主键、外键）、仓库号（主键、外键）、合同）</span><br><span class="line">领导（工号（主键、外键）、工号（主键、外键）、职补）</span><br></pre></td></tr></table></figure><h1>六、关系规范化</h1><h2 id="6-1-函数依赖">6.1. 函数依赖</h2><ul><li>函数依赖：$X\rightarrow Y$，$X$决定$Y$，$Y$依赖于$X$</li><li>非平凡函数依赖：$X\rightarrow Y$，Y不是X的子集</li><li>完全函数依赖：$X\rightarrow Y$，$Y$不依赖于$X$的任何真子集，只依赖于$X$，记作$X -F\rightarrow Y$</li><li>部分函数依赖：$X\rightarrow Y$，$Y$依赖于$X$的某个真子集，记作$X -P\rightarrow Y$</li><li>传递函数依赖：$X\rightarrow Y$，$Y\rightarrow Z$，$Z$依赖于$X$，且$Y$不依赖于$X$，记作$X -T\rightarrow Z$</li></ul><h2 id="6-2-范式与关系规范化">6.2. 范式与关系规范化</h2><h3 id="1-第一范式（1NF）">1. 第一范式（1NF）</h3><ul><li>定义：所有属性都是不可分的基本数据项</li></ul><h3 id="2-第二范式（2NF）">2. 第二范式（2NF）</h3><ul><li>定义：满足1NF，且每个非主属性完全函数依赖于候选键（消除部分函数依赖）</li></ul><h3 id="3-第三范式（3NF）">3. 第三范式（3NF）</h3><ul><li>定义：满足2NF，且每个非主属性不传递函数依赖于候选键</li></ul><h3 id="4-BC范式（BCNF）">4. BC范式（BCNF）</h3><ul><li>定义：满足3NF，且任意函数依赖，$X\rightarrow Y$，$X$必包含候选键</li></ul><h3 id="5-第四范式（4NF）：不存在多值依赖">5. *第四范式（4NF）：不存在多值依赖</h3><h3 id="6-第五范式（5NF）：消除连接依赖">6. *第五范式（5NF）：消除连接依赖</h3><h2 id="6-3-关系规范化">6.3. 关系规范化</h2><h3 id="1-Amstrong公理">1. Amstrong公理</h3><ul><li>自反律：$Y\subseteq X\Rightarrow X\rightarrow Y$</li><li>增广律：$X\rightarrow Y\Rightarrow XZ\rightarrow YZ$</li><li>传递律：$X\rightarrow Y,Y\rightarrow Z\Rightarrow X\rightarrow Z$</li><li>合成律：$X\rightarrow Y,Y\rightarrow Z\Rightarrow X\rightarrow YZ$</li><li>分解律：$X\rightarrow YZ\Rightarrow X\rightarrow Y,X\rightarrow Z$</li><li>伪传递律：$X\rightarrow Y,YW\rightarrow Z\Rightarrow XW\rightarrow YZ$</li></ul><h3 id="2-函数依赖集闭包-F">2. *函数依赖集闭包$F^+$</h3><h3 id="3-属性集闭包-X-F">3. 属性集闭包$X^+_F$</h3><ul><li>已知$X$，利用函数依赖集可以计算出的最大属性集</li></ul><h3 id="4-最小函数依赖集-F-min">4. 最小函数依赖集$F_{min}$</h3><ul><li>从函数依赖集中删除冗余的函数依赖</li></ul><h3 id="5-求所有候选键">5. 求所有候选键</h3><ul><li>只在左边出现：一定属于每个候选键</li><li>只在右边出现：一定不属于任何候选键</li><li>左右都出现：可能属于候选键，闭包计算</li><li>左右都不出现：一定属于每个候选键（否则无法得到它本身）</li></ul><h1>七、数据安全</h1><h2 id="7-1-数据保护">7.1. 数据保护</h2><p>主要包括：数据安全、数据完整、数据并发和数据恢复</p><h2 id="7-2-安全标准">7.2. 安全标准</h2><p>4组7个等级：$D,C_1,C_2,B_1,B_2,B_3,A_1$</p><h2 id="7-3-数据安全">7.3. 数据安全</h2><p>包括：用户鉴别、数据存取控制、视图、审计与数据加密</p><h3 id="1-用户鉴别">1. 用户鉴别</h3><p>鉴别方式：静态鉴别（用户名和密码）和动态鉴别（验证码）等</p><h3 id="2-数据存取控制（SQL的DCL）">2. 数据存取控制（SQL的DCL）</h3><ul><li>Grant：授权</li><li>Revoke：撤销</li><li>Deny：拒绝</li></ul><h3 id="3-视图">3. 视图</h3><ul><li>定义：从一个或多个基本表中导出的虚表，局部数据的临时体现</li><li>作用<br>（1）简化用户操作<br>（2）清晰表达查询<br>（3）同一数据可以以不同形式提供给不同用户<br>（4）在一定程度上确保了数据安全<br>（5）在一定程度上提供了逻辑独立性</li><li>数据操纵与表一致，关键词由<code>Table</code>改为<code>View</code></li><li>更新视图：（表内数据同步更新）</li></ul><h3 id="4-审计">4. 审计</h3><h3 id="5-数据加密">5. 数据加密</h3><p>常用的加密方法：替换方法、置换方法和混合方法等。</p><h1>八、并发控制</h1><h2 id="8-1-事务">8.1. 事务</h2><ul><li>用户定义的一个数据操作序列，这些操作可作为一个完整的工作单元，要么全部执行，要么全部不执行，是一个不可分割的工作单位。</li><li>事务中的操作一般是对数据的更新操作，包括增、删、改。</li><li>以<code>BEGIN TRANSACTION</code>语句开始，以<code>COMMIT</code>语句（正常）或<code>ROLLBACK</code>语句（异常）结束</li><li>特征：原子性、一致性、隔离性、持久性</li></ul><h2 id="8-2-并发控制错误">8.2. 并发控制错误</h2><h3 id="1-丢失修改">1. 丢失修改</h3><p>事务T1,T2同时读入同一数据并加以修改，T2的提交结果会破坏T1提交的结果</p><h3 id="2-读脏数据">2. 读脏数据</h3><p>事务T1修改数据后撤销，使得T2读取的数据与数据库中不一致</p><h3 id="3-不可重复读">3. 不可重复读</h3><p>事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果</p><h2 id="8-3-封锁：最常用的并发控制方法">8.3. 封锁：最常用的并发控制方法</h2><ol><li>排他锁（X锁），用于写操作，其他事务不允许读写，也不允许加锁</li><li>共享锁（S锁），用于读操作，其他事务允许读，不允许写，允许加S锁，不允许加X锁</li></ol><h2 id="8-4-封锁协议">8.4. 封锁协议</h2><h3 id="1-一级封锁协议">1. 一级封锁协议</h3><p>T1,T2都加X锁（解决丢失修改）</p><h3 id="2-二级封锁协议">2. 二级封锁协议</h3><p>T1加X锁，T2加S锁（解决丢失修改和不可重复读）</p><h3 id="3-三级封锁协议">3. 三级封锁协议</h3><p>T1加S锁，T2加X锁（解决丢失修改、不可重复读和读脏数据）</p><h2 id="8-5-两段锁协议和可串行化">8.5. 两段锁协议和可串行化</h2><p>满足两段锁协议一定可串行化，不满足两段锁协议也可能可串行化。</p><h2 id="8-6-封锁粒度">8.6. 封锁粒度</h2><p>粒度越细，软件复杂性和系统开销也就越小</p><h2 id="8-7-活锁">8.7. 活锁</h2><ul><li>由于授权封锁的随机性，导致事务T的封锁请求一直处于等待状态的封锁。即：T封锁一个数据对象时，T始终处于等待状态。</li><li>解决方法：采用先来先服务的授权策略。并发事务请求封锁数据对象时，按照请求封锁的先后次序依次进行授权。</li></ul><h2 id="8-8-死锁">8.8. 死锁</h2><ul><li>两个或两个以上事务在执行过程中，因争夺资源而造成的一种互相等待的现象。</li><li>预防：一次封锁、顺序封锁</li><li>诊断：超时法、等待图法</li></ul><h1>九、数据库恢复</h1><h2 id="9-1-故障管理">9.1.  故障管理</h2><ul><li>事务故障：运行的事务T遭到强行终止，使T非正常结束。破坏了原子性。</li><li>系统故障：导致系统停止运转的任何事件。系统故障需要重新启动系统。</li><li>介质故障：导致外存储设备故障的任何事件。</li><li>病毒故障</li></ul><h2 id="9-2-建立冗余数据">9.2. 建立冗余数据</h2><ul><li>数据恢复的核心技术：建立冗余数据和利用冗余数据实施数据库恢复。</li><li>建立冗余数据的技术：数据转储和登记日志文件等。</li><li>数据转储分类：静态海量转储、静态增量转储、动态海量转储和动态增量转储，各自的含义。</li></ul><h1>十、数据库设计</h1><p>数据库设计方法：手工经验法，新奥尔良法，ER图法，3NF法等</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《概率论与数理统计》笔记</title>
      <link href="/posts/Note_Probability_Theory.html"/>
      <url>/posts/Note_Probability_Theory.html</url>
      
        <content type="html"><![CDATA[<h1>一、随机事件与概率</h1><h2 id="1-公式：">1.公式：</h2><ol><li>条件概率：$P(A|B)=\frac{P(AB)}{P(B)}$</li><li>乘法公式：$P(AB)=P(A|B)P(B)=P(B|A)P(A)$</li><li>全概率公式：$P(A)=\sum_{i=1}^nP(A|B_i)P(B_i)$</li><li>贝叶斯公式：$P(B_i|A)=\frac{P(A|B_i)P(B_i)}{\sum_{i=1}^nP(A|B_i)P(B_i)}$</li><li>抽签问题：$P(A)=\frac{m}{n}$</li></ol><h2 id="2-事件独立性">2.事件独立性</h2><p>事件A,B,C相互独立 $\Leftrightarrow $ $P(ABC)=P(A)P(B)P(C),$ $P(AB)=P(A)P(B),$ $P(AC)=P(A)P(C),$ $P(BC)=P(B)P(C)$</p><h3 id="例题">例题</h3><p>$A,B,C$独立，$ABC=\varnothing,$ $P(A)=P(B)=P(C)\lt\frac{1}{2},$ $P(A\cup B\cup C)=\frac{9}{16}$,求$P(A)$</p><p>$P(A\cup B\cup C)$ $=P(A)+P(B)+P(C)-P(AB)-P(AC)-P(BC)+P(ABC)$ $=3P(A)-3P(A)^2+0=\frac{9}{16}$ $\Rightarrow$ $P(A)=\frac{1}{4}$或$P(A)=\frac{3}{4}$(舍)</p><h2 id="3-超几何分布">3.超几何分布</h2><ol><li>概述：$n+m$件产品中有$m$件次品，从中抽取$k$件，求其中有$i$件次品的概率</li><li>分布律：$P(X=i)=\frac{C_m^iC_{n}^{k-i}}{C_{m+n}^k}$</li></ol><h1>二、随机变量及其分布+数字特征</h1><h2 id="1-X-B-n-p">1. $X$ ~ $B(n,p)$</h2><ol><li>分布名称：二项分布</li><li>概述：$n$次独立重复试验中，事件A发生的次数$X$（伯努利试验）</li><li>分布律：$P(X=k)=C_n^kp^k(1-p)^{n-k}$</li><li>期望：$E(X)=np$</li><li>方差：$D(X)=np(1-p)$</li></ol><h2 id="2-X-P-lambda">2. $X$ ~ $P(\lambda)$</h2><ol><li>分布名称：泊松分布</li><li>概述：多次试验中小概率事件A发生的次数$X$</li><li>分布律：$P(X=k)=\frac{\lambda^k}{k!}e^{-\lambda}$</li><li>期望：$E(X)=\lambda$</li><li>方差：$D(X)=\lambda$</li><li>泊松定理：对于$X$ ~ $B(n,p)$，当$n\rightarrow\infty,p\rightarrow0,np=\lambda$时，可近似认为$X$ ~ $P(\lambda)$</li></ol><h2 id="3-X-g-p">3. $X$ ~ $g(p)$</h2><ol><li>分布名称：几何分布</li><li>概述：多次试验中事件A第一次成功的次数$X$</li><li>分布律：$P(X=k)=p(1-p)^{k-1}$</li><li>期望：$E(X)=\frac{1}{p}$</li><li>方差：$D(X)=\frac{1-p}{p^2}$</li><li>无记忆性：$P(X&gt;s+t|X&gt;s)=P(X&gt;t)$</li></ol><h2 id="4-X-U-a-b">4. $X$ ~ $U(a,b)$</h2><ol><li>分布名称：均匀分布</li><li>分布函数：$F(x)=\begin{cases}0&amp;,x&lt;a \\ \frac{x-a}{b-a}&amp;,a\leq x\leq b \\ 1&amp;,x&gt;b\end{cases}$</li><li>概率密度函数：$f(x)=\begin{cases}\frac{1}{b-a}&amp;,a\leq x\leq b \\ 0&amp;,\text{其他}\end{cases}$</li><li>期望：$E(X)=\frac{a+b}{2}$</li><li>方差：$D(X)=\frac{(b-a)^2}{12}$</li></ol><h2 id="5-X-E-lambda">5. $X$ ~ $E(\lambda)$</h2><ol><li>分布名称：指数分布</li><li>分布函数：$F(x)=\begin{cases}1-e^{-\lambda x}&amp;,x\geq 0 \\ 0&amp;,x&lt;0\end{cases}$</li><li>概率密度函数：$f(x)=\begin{cases}\lambda e^{-\lambda x}&amp;,x\geq 0 \\ 0&amp;,x&lt;0\end{cases}$</li><li>期望：$E(X)=\frac{1}{\lambda}$</li><li>方差：$D(X)=\frac{1}{\lambda^2}$</li><li>$P(X&gt;t)=e^{-\lambda t}$</li><li>无记忆性：$P(X&gt;s+t|X&gt;s)=P(X&gt;t)$</li><li>与泊松分布的关系：服从$E(\lambda)$的事件，$t$时间内发生的次数$X$ ~ $P(\lambda t)$</li><li>事件下次发生的时间：$X$ ~ $E(\lambda)$，$P(X&gt;t)=e^{-\lambda t}$</li></ol><h2 id="6-X-N-mu-sigma-2">6. $X$ ~ $N(\mu,\sigma^2)$</h2><ol><li>分布名称：正态分布</li><li>分布函数：$F(x)=\frac{1}{\sqrt{2\pi}\sigma}\int_{-\infty}^xe^{-\frac{(t-\mu)^2}{2\sigma^2}}dt$</li><li>概率密度函数：$f(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}$</li><li>期望：$E(X)=\mu$</li><li>方差：$D(X)=\sigma^2$</li><li>对称轴：$x=\mu$</li><li>拐点：$x=\mu \pm \sigma$</li><li>分布函数最大值：$f(x)_{max}=f(\mu)=\frac{1}{\sqrt{2\pi}\sigma}$</li><li>$\sigma\uparrow$：扁平 ； $\sigma\downarrow$：尖锐</li><li>$\mu\uparrow\downarrow$：左右平移，形状不变</li></ol><h2 id="7-X-N-0-1">7. $X$ ~ $N(0,1)$</h2><ol><li>分布名称：标准正态分布</li><li>分布函数：$\varPhi(x)=\frac{1}{\sqrt{2\pi}}\int_{-\infty}^xe^{-\frac{t^2}{2}}dt$</li><li>概率密度函数：$\varphi(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}$</li><li>期望：$E(X)=0$</li><li>方差：$D(X)=1$</li><li>$\varPhi(-x)=1-\varPhi(x)$</li><li>$P(a&lt;X&lt;b)=\varPhi(b)-\varPhi(a)$</li><li>$P(|X|&lt;a)=2\varPhi(a)-1$</li><li>$3\mu$原则：$P(|X-\mu|&lt;k\sigma),k=1,2,3$分别对应$0.683,0.954,0.997$</li><li>正态分布标准化：$X$ ~ $N(\mu,\sigma^2)$，$Z=\frac{X-\mu}{\sigma}$ ~ $N(0,1)$</li></ol><h1>三、多维随机变量及其分布</h1><h2 id="1-二维随机分布函数的充要条件-3">1. 二维随机分布函数的充要条件(3)</h2><ol><li>右连续：$F(x+0,y)=F(x,y)$</li><li>规范性：$P(+\infty,+\infty)=1,P(-\infty,-\infty)=0$</li><li>容斥：$P(x_1\leq x\leq x_2,y_1\leq y\leq y_2)$ $=F(x_2,y_2)-F(x_1,y_2)-F(x_2,y_1)+F(x_1,y_1)$</li></ol><h2 id="2-边缘分布函数">2. 边缘分布函数</h2><ol><li>$F_X(x)=F(x,+\infty)$</li><li>$F_Y(y)=F(+\infty,y)$</li></ol><h2 id="3-联合密度函数、边缘密度函数定义">3. 联合密度函数、边缘密度函数定义</h2><ol><li>联合密度函数：$F(x,y)=\int_{-\infty}^x\int_{-\infty}^yf(x,y)dxdy$</li><li>边缘密度函数：$f_X(x)=\int_{-\infty}^{+\infty}f(x,y)dy,f_Y(y)$ $=\int_{-\infty}^{+\infty}f(x,y)dx$</li></ol><h2 id="4-二维正态分布">4. 二维正态分布</h2><ol><li>$(X,Y)$ ~ $N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$</li><li>二维正态分布的边缘分布仍是正态分布：$X$ ~ $N(\mu_1,\sigma_1^2),Y$ ~ $N(\mu_2,\sigma_2^2)$</li><li>$X,Y$ 独立 $\Leftrightarrow$ $X,Y$ 无关 $\Leftrightarrow$ $\rho=0$</li></ol><h2 id="5-可加性">5. 可加性</h2><ol><li>前提：$X_i$ 独立</li><li>泊松分布：$X_i$ ~ $P(\lambda _i)$ $\Rightarrow$ $\sum X_i$ ~ $P(\sum \lambda _i)$</li><li>二项分布：$X_i$ ~ $B(n_i,p)$ $\Rightarrow$ $\sum X_i$ ~ $B(\sum n_i,p)$</li><li>正态分布：$X_i$ ~ $N(\mu _i,\sigma _i^2)$ $\Rightarrow$ $\sum k_iX_i$ ~ $N(\sum k_i\mu _i,\sum k_i^2\sigma _i^2)$</li></ol><h2 id="6-最值分布函数">6. 最值分布函数</h2><ol><li>$F_{max}(x)=P(X_1\leq x,X_2\leq x,\cdots,X_n\leq x)$ $=\prod F(x_i)$</li><li>$F_{min}(x)=P(X_1\leq x,X_2\leq x,\cdots,X_n\leq x)$ $=1-\prod (1-F(x_i))$</li></ol><h3 id="例题：已知-mathbb-X-X-1-X-2-cdots-X-n-独立同分布，且服从于-U-0-theta-，求-max-mathbb-X-、-min-mathbb-X-的密度函数-f-M-x-、-f-N-x-。">例题：已知$\mathbb{X}=(X_1,X_2,\cdots,X_n)$独立同分布，且服从于$U(0,\theta)$，求$\max(\mathbb{X})$、$\min(\mathbb{X})$的密度函数$f_M(x)$、$f_N(x)$。</h3><p>$X_i$ ~ $U(0,\theta)$ $\Rightarrow$ $F(x)=\begin{cases}0&amp;,x&lt;0 \\ \frac{x}{\theta}&amp;,0\leq x\leq \theta \\ 1&amp;,x&gt;\theta\end{cases}$</p><p>$F_M(x)=\prod F(x_i)=(F(x))^n$ $=\begin{cases}0&amp;,x&lt;0 \\ \left(\frac{x}{\theta}\right)^n&amp;,0\leq x\leq \theta \\ 1&amp;,x&gt;\theta\end{cases}$</p><p>$\Rightarrow$ $f_M(x)=\frac{dF_M(x)}{dx}=\begin{cases}\frac{nx^{n-1}}{\theta^n}&amp;,0\leq x\leq \theta \\ 0&amp;,Otherwise\end{cases}$</p><p>$F_N(x)=1-F_M(x)=\begin{cases}1&amp;,x&lt;0 \\ 1-\left(\frac{x}{\theta}\right)^n&amp;,0\leq x\leq \theta \\ 0&amp;,x&gt;\theta\end{cases}$</p><p>$\Rightarrow$ $f_N(x)=\frac{dF_N(x)}{dx}=\begin{cases}\frac{nx^{n-1}}{\theta^n}&amp;,0\leq x\leq \theta \\ 0&amp;,Otherwise\end{cases}$</p><h1>专：随机变量函数的分布</h1><h2 id="1-离散型随机变量">1. 离散型随机变量</h2><ol><li>一维：$P(X=x_i)=p_i$，$Y=h(X)$ $\Rightarrow$ $P(Y=y_j)=\sum\limits_{h(x_i)=y_j}p_i$</li><li>二维：$P(X=x_i,Y=y_j)=p_{ij}$，$Z=h(X,Y)$ $\Rightarrow$ $P(Z=z_k)=\sum\limits_{h(x_i,y_j)=z_k}p_{ij}$</li></ol><h2 id="2-连续型随机变量">2. 连续型随机变量</h2><h3 id="一维例题：-X-N-0-1-Y-X-2-，求-f-Y-y">一维例题：$X$ ~ $N(0,1)$ , $Y=X^2$，求$f_Y(y)$</h3><p>第1步：写$X$的取值范围，确认$f_Y(y)$的定义域，定义域外$f_Y(y)=0$</p><p>$X\in R$ $\Rightarrow$ $Y=X^2\geq 0$</p><p>第2步：写出$X$的分布函数$F_X(x)$</p><p>$F_X(x)=\varPhi(x)$</p><p>第3步：求$Y$的分布函数$F_Y(y)$</p><p>$y\geq 0$ 时， $F_Y(y)=P(Y\leq y)=P(X^2\leq y)$ $=P(|X| \leq \sqrt{y})=2\varPhi(\sqrt{y})-1$</p><p>$\Rightarrow$ $F_Y(y)=\begin{cases}0&amp;,y&lt;0 \\ 2\varPhi(\sqrt{y})-1&amp;,y\geq 0\end{cases}$</p><p>第4步：对$F_Y(y)$求导，得$f_Y(y)$</p><p>$f_Y(y)=\frac{dF_Y(y)}{dy}=\begin{cases}0&amp;,y&lt;0 \\ y^{-\frac{1}{2}}\varphi(\sqrt{y})&amp;,y\geq 0\end{cases}$</p><h3 id="二维例题：-X-E-1-Y-U-0-1-X-Y-独立-Z-X-2Y-，求-f-Z-z">二维例题：$X$ ~ $E(1)$ , $Y$ ~ $U(0,1)$ , $X,Y$独立 , $Z=X+2Y$，求$f_Z(z)$</h3><p>第1步：写$X,Y$的取值范围，确认$f_Z(z)$的定义域，定义域外$f_Z(z)=0$</p><p>$X \geq 0$ , $Y\in [0,1]$ $\Rightarrow$ $Z=X+2Y\geq 0$</p><p>第2步：写出$X,Y$的密度函数$f_X(x)$、$f_Y(y)$</p><p>$f_X(x)=\begin{cases}e^{-x}&amp;,x\geq 0 \\ 0&amp;,Otherwise\end{cases}$</p><p>$f_Y(y)=\begin{cases}1&amp;,y\in[0,1] \\ 0&amp;,Otherwise\end{cases}$</p><p>第3步：写出$X,Y$的联合密度函数$f_{XY}(x,y)$</p><p>$f_{XY}(x,y)=f_X(x)f_Y(y)=\begin{cases}e^{-x}&amp;,x\geq 0,y\in[0,1] \\ 0&amp;,Otherwise\end{cases}$</p><p>第4步：确定积分区域（作图）</p><p>第5步：求$Z$的分布函数$F_Z(z)$</p><p>$F_Z(z)=P(Z\leq z)=P(X+2Y\leq z)=P(Y\leq \frac{z-X}{2})$</p><p>$$\begin{align}<br>\Rightarrow F_Z(z)&amp;=\begin{cases}<br>\int_0^ze^{-x}dx\int_0^{\frac{z-x}{2}}dy &amp;, z\in[0,2]   \\<br>\int_0^{z-2}e^{-x}dx\int_0^1dy+\int_{z-2}^ze^{-x}dx\int_0^{\frac{z-x}{2}}dy &amp;, z\geq 2  \\<br>0 &amp;, Otherwise<br>\end{cases}<br>\\<br>&amp;=\begin{cases}<br>\frac{1}{2}(e^{-z}+z-1) &amp;, z\in[0,2]  \\<br>1-\frac{1}{2}e^{2-z}+\frac{1}{2}e^{-z} &amp;, z\geq 2  \\<br>0 &amp;, Otherwise<br>\end{cases}<br>\end{align}<br>$$</p><p>第6步：对$F_Z(z)$求导，得$f_Z(z)$</p><p>$$<br>f_Z(z)=\frac{dF_Z(z)}{dz}=<br>\begin{cases}<br>-\frac{1}{2}e^{-z}+\frac{1}{2} &amp;, z\in[0,2]  \\<br>\frac{1}{2}e^{2-z}-\frac{1}{2}e^{-z} &amp;, z\geq 2  \\<br>0 &amp;, Otherwise<br>\end{cases}<br>$$</p><h1>四、随机变量的数字特征</h1><h2 id="1-数学期望">1. 数学期望</h2><p>离散型：$E(X)=\sum x_ip_i$</p><p>连续型：$E(X)=\int_{-\infty}^{+\infty}xf(x)dx$</p><p>随机变量函数：$E(Y)=E(h(X))$</p><p>性质：</p><ol><li>$E(C)=C$</li><li>$E(CX)=CE(X)$</li><li>$E(X\pm Y)=E(X)\pm E(Y)$</li><li>$X,Y$ 独立 $\Rightarrow$ $E(XY)=E(X)E(Y)$</li></ol><h2 id="2-方差">2. 方差</h2><p>$D(X)=E(X-E(X))^2=E(X^2)-[E(X)]^2$</p><p>标准差：$\sqrt{D(X)}$</p><p>性质：</p><ol><li>$D(C)=0$</li><li>$D(X+C)=D(X)$</li><li>$D(CX)=C^2D(X)$</li><li>$D(X\pm Y)=D(X)+D(Y)\pm 2Cov(X,Y)$</li><li>$X,Y$ 独立 $\Rightarrow$ $D(X\pm Y)=D(X)+D(Y)$</li><li>$D(X)=0 \Leftrightarrow P(X=E(X))=1$</li></ol><h2 id="3-协方差">3. 协方差</h2><p>$Cov(X,Y)=E(XY)-E(X)E(Y)$</p><p>性质：</p><ol><li>$Cov(X,X)=D(X)$</li><li>$Cov(X,Y)=Cov(Y,X)$</li><li>$Cov(aX,bY)=abCov(X,Y)$</li><li>$Cov(X_1+X_2,Y)=Cov(X_1,Y)+Cov(X_2,Y)$</li><li>$Cov(X,C)=0$</li><li>$X,Y$ 独立 $\Rightarrow$ $Cov(X,Y)=0$</li></ol><h2 id="4-相关系数">4. 相关系数</h2><p>随机变量$X$的标准化：$X^*=\frac{X-E(X)}{\sqrt{D(X)}}$</p><p>相关系数：$\rho_{XY}=Cov(X^*,Y^*)=\frac{Cov(X,Y)}{\sqrt{D(X)}\sqrt{D(Y)}}$</p><p>性质：</p><ol><li>$|\rho_{XY}|\leq 1$</li><li>$|\rho_{XY}|=1 \Leftrightarrow$ $X,Y$ 成线性关系，$\exists a,b\ s.t.\ P(Y=aX+b)=1$, $a\rho_{XY}&gt;0$</li></ol><h1>五、大数定律与中心极限定理</h1><h2 id="1-大量独立同分布随机变量和的极限分布是正态分布（基础）">1. 大量独立同分布随机变量和的极限分布是正态分布（基础）</h2><p>$E(X_i)=\mu,D(X_i)=\sigma^2,Y=\sum X_i$</p><p>$\Rightarrow$ $E(Y)=n\mu,D(Y)=n\sigma^2$</p><p>$\Rightarrow$ $Y$ ~ $N(n\mu,n\sigma^2)$</p><p>$\Rightarrow$ 标准化： $\frac{Y-n\mu}{\sigma\sqrt{n}}$ ~ $N(0,1)$</p><h2 id="2-切比雪夫不等式（重点）">2. 切比雪夫不等式（重点）</h2><p>若$E(X)=\mu,D(X)=\sigma^2$，则对任意$\epsilon&gt;0$，有$P(|X-\mu|\geq \epsilon)\leq \frac{\sigma^2}{\epsilon^2}$</p><p>落在$\mu\pm\epsilon$外的概率不超过$\frac{\sigma^2}{\epsilon^2}$</p><h2 id="3-中心极限定理">3. 中心极限定理</h2><p>$\mathbb{X}=(X_1,X_2,\cdots,X_n)$独立同分布，$E(X_i)=\mu,0\lt D(X_i)=\sigma^2\lt\infty$，则$\forall x,\lim\limits_{n\rightarrow\infty}P\left(\frac{\sum X_i-n\mu}{\sigma\sqrt{n}}\leq x\right)=\varPhi(x)$</p><h3 id="例题：每台车床有-70-的时间在工作">例题：每台车床有$70%$的时间在工作</h3><h3 id="1-100台车床，求任意时刻有70至80台车床在工作的概率">1. 100台车床，求任意时刻有70至80台车床在工作的概率</h3><p>第1步：写出单个样本$X$的期望和方差</p><p>单个车床$X$ ~ $B(1,0.7)$ $\Rightarrow$ $E(X)=0.7,D(X)=0.21$</p><p>第2步：写出样本总体$Y$的期望和方差</p><p>记任意时刻工作的车床数为$Y$，<br>$E(Y)=100E(X)=70,D(Y)=100D(X)=21$</p><p>第3步：写出所求概率，对$Y$进行标准化，并用标准正态分布分布函数表示</p><p>$P(70\leq Y\leq 80)=P\left(\frac{70-70}{\sqrt{21}}\leq \frac{Y-70}{\sqrt{21}}\leq \frac{80-70}{\sqrt{21}}\right)$ $=\varPhi\left(\frac{10}{\sqrt{21}}\right)-\varPhi(0)=\varPhi\left(2.18\right)-\varPhi(0)$</p><p>第4步：查表代入</p><h3 id="2-求以0-997的概率保证-任意时刻至少有80台车床在工作-所需的车床数">2. 求以0.997的概率保证 任意时刻至少有80台车床在工作 所需的车床数</h3><p>设所需车床数为$N$，任意某时刻工作的车床数为$X$，则$E(X)=0.7N,D(X)=0.21N$</p><p>$P(X\geq 80)=1-P(X\lt 80)$ $=1-P\left(\frac{X-0.7N}{\sqrt{0.21N}}\lt \frac{80-0.7N}{\sqrt{0.21N}}\right)$ $=1-\varPhi\left(\frac{80-0.7N}{\sqrt{0.21N}}\right)\geq 0.997$</p><p>$\Rightarrow$ $\varPhi\left(\frac{80-0.7N}{\sqrt{0.21N}}\right)\leq 0.003$ $\Rightarrow$ $\frac{80-0.7N}{\sqrt{0.21N}}\leq -2.75$</p><h2 id="4-伯努利大数定律">4*. 伯努利大数定律</h2><p>$n$次独立重复试验中，事件A发生的次数$m$，$P(A)=p$，则对任意$\epsilon&gt;0$，有$\lim\limits_{n\rightarrow\infty}P\left(\left|\frac{m}{n}-p\right|\leq \epsilon\right)=1$</p><h2 id="5-辛钦大数定律">5*. 辛钦大数定律</h2><p>$\mathbb{X}=(X_1,X_2,\cdots,X_n)$独立同分布，记$X_i=\begin{cases}1&amp;,A发生 \\ 0&amp;,A不发生\end{cases}$，则对任意$\epsilon&gt;0$，有$\lim\limits_{n\rightarrow\infty}P\left(\left|\frac{\sum X_i}{n}-p\right|\leq \epsilon\right)=1$</p><h2 id="6-切比雪夫大数定律">6*. 切比雪夫大数定律</h2><p>$\mathbb{X}=(X_1,X_2,\cdots,X_n)$不相关，$\exists E(X_i),D(X_i)&lt;\infty$，则对任意$\epsilon&gt;0$，有$\lim\limits_{n\rightarrow\infty}P\left(\left|\frac{\sum X_i}{n}-\frac{\sum E(X_i)}{n}\right|\leq \epsilon\right)=1$</p><h1>六、抽样分布</h1><h2 id="1-统计量">1. 统计量</h2><ol><li>样本均值：$\overline{X}=\frac{1}{n}\sum X_i$</li><li>样本方差：$S^2=\frac{1}{n-1}\sum(X_i-\overline{X})^2$</li><li>样本标准差：$S=\sqrt{S^2}$</li><li>样本$k$阶原点矩：$A_k=\frac{1}{n}\sum X_i^k$</li><li>样本$k$阶中心矩：$B_k=\frac{1}{n}\sum(X_i-\overline{X})^k$</li></ol><p>$\overline{X}=A_1$，$S^2=\frac{n-1}{n}B_2$，$B_1=0$</p><h2 id="2-X-N-mu-sigma-2">2. $X$~$N(\mu,\sigma^2)$</h2><ol><li>分布名称：正态分布</li><li>上$\alpha$分位数：$u_\alpha$</li></ol><h2 id="3-X-chi-2-n">3. $X$~$\chi^2(n)$</h2><ol><li>分布名称：卡方分布</li><li>概述：$X_1,X_2,\cdots,X_n$独立同分布，且$X_i$ ~ $N(0,1)$，则$X=\sum X_i^2$ ~ $\chi^2(n)$</li><li>上$\alpha$分位数：$\chi_\alpha^2(n)$</li><li>期望：$E(X)=n$</li><li>方差：$D(X)=2n$</li><li>$n\rightarrow\infty$时，$\chi^2(n)$近似于$N(n,2n)$</li><li>可加性：$X_i$ ~ $\chi^2(n_i)$ $\Rightarrow$ $\sum X_i$ ~ $\chi^2(\sum n_i)$</li></ol><h2 id="4-X-t-n">4. $X$~$t(n)$</h2><ol><li>分布名称：t分布</li><li>概述：$X$ ~ $N(0,1)$，$Y$ ~ $\chi^2(n)$，$X,Y$独立，$\frac{X}{\sqrt{\frac{Y}{n}}}$ ~ $t(n)$</li><li>上$\alpha$分位数：$t_\alpha(n)$</li><li>期望：$E(X)=0$ 对称性：$t_{1-\alpha}(n)=-t_\alpha(n)$</li><li>$n\rightarrow\infty$时，$t(n)$近似于$N(0,1)$</li></ol><h2 id="5-X-F-n-1-n-2">5. $X$~$F(n_1,n_2)$</h2><ol><li>分布名称：F分布</li><li>概述：$X_1$ ~ $\chi^2(n_1)$，$X_2$ ~ $\chi^2(n_2)$，$X_1,X_2$独立，$\frac{X_1/n_1}{X_2/n_2}$ ~ $F(n_1,n_2)$</li><li>上$\alpha$分位数：$F_\alpha(n_1,n_2)$</li><li>性质1：$F_{1-\alpha}(n_1,n_2)=\frac{1}{F_\alpha(n_2,n_1)}$</li><li>性质2：$P(F\leq F_\alpha(n_1,n_2))=1-\alpha$</li></ol><h2 id="6-单正态总体下的抽样分布">6.单正态总体下的抽样分布</h2><ol><li>$\overline{X}$ ~ $N(\mu,\frac{\sigma^2}{n})$</li><li>$U=\frac{\overline{X}-\mu}{\sigma}{\sqrt{n}}$ ~ $N(0,1)$</li><li>$T=\frac{\overline{X}-\mu}{S}{\sqrt{n}}$ ~ $t(n-1)$</li><li>$C=\frac{(n-1)S^2}{\sigma^2}=\frac{1}{\sigma^2}\sum(X_i-\overline{X})^2$ ~ $\chi^2(n-1)$</li></ol><h2 id="7-两正态总体下的抽样分布">7.两正态总体下的抽样分布</h2><ol><li>$\overline{X}-\overline{Y}$ ~ $N(\mu_1-\mu_2,\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2})$ $\Rightarrow$ $U=\frac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{\sqrt{\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2}}}$ ~ $N(0,1)$</li><li>$\frac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{S_w\sqrt{\frac{1}{n_1}+\frac{1}{n_2}}}$ ~ $t(n_1+n_2-2)$ $\Rightarrow$ $T=\frac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{S_w\sqrt{\frac{1}{n_1}+\frac{1}{n_2}}}$ ~ $t(n_1+n_2-2)$</li><li>$\frac{S_1^2/\sigma_1^2}{S_2^2/\sigma_2^2}$ ~ $F(n_1-1,n_2-1)$ $\Rightarrow$ $F=\frac{S_1^2/\sigma_1^2}{S_2^2/\sigma_2^2}$ ~ $F(n_1-1,n_2-1)$</li></ol><p>注：$S_w^2=\frac{(n_1-1)S_1^2+(n_2-1)S_2^2}{n_1+n_2-2}$</p><h1>七、参数估计（点估计）</h1><h2 id="1-矩估计">1. 矩估计</h2><p>利用样本矩去估计总体矩，建立样本矩与总体矩的关系，解出参数</p><p>$A_1=\overline{X}=E(X)$，$A_2=\frac{1}{n}\sum X_i^2=E(X^2)$，$B_2=A_2-\overline{X}^2$</p><p>$\Rightarrow$ $\mu=A_1$，$\sigma^2=B_2$</p><h2 id="2-极大似然估计">2. 极大似然估计</h2><ol><li>写出总体的密度函数$f(x;\theta)$</li><li>写出样本的似然函数$L(\theta)=\prod f(x_i;\theta)$</li><li>对$L(\theta)$取对数，得到对数似然函数$\ln L(\theta)$</li><li>对$\ln L(\theta)$求导，令其等于0，解出$\theta$的值</li><li>多个参数时，对每个参数分别求偏导，令其等于0，得到方程组，解出每个参数的值</li></ol><h2 id="3-点估计的优良性">3. 点估计的优良性</h2><ol><li>无偏性：$E(\hat{\theta})=\theta$</li><li>有效性：$D(\hat{\theta})\leq D(\tilde{\theta})$，$\hat{\theta}=\overline{X}$时最有效</li></ol><h3 id="例题：设-X-1-X-2-cdots-X-n-是来自总体-X-的样本，-X-的密度函数为-f-x-sigma-frac-1-2-sigma-e-frac-x-sigma-，其中-sigma-0-为未知参数，求-sigma-的矩估计和极大似然估计。">例题：设$X_1,X_2,\cdots,X_n$是来自总体$X$的样本，$X$的密度函数为$f(x;\sigma)=\frac{1}{2\sigma}e^{-\frac{|x|}{\sigma}}$，其中$\sigma&gt;0$为未知参数，求$\sigma$的矩估计和极大似然估计。</h3><p>矩估计</p><p>$E(X)=\int_{-\infty}^{+\infty}xf(x;\sigma)dx=\frac{1}{2\sigma}\int_{-\infty}^{+\infty}xe^{-\frac{|x|}{\sigma}}dx=0$，无法求出$\sigma$，故用二阶矩求解</p><p>$E(X^2)=\int_{-\infty}^{+\infty}x^2f(x;\sigma)dx=\frac{1}{2\sigma}\int_{-\infty}^{+\infty}x^2e^{-\frac{|x|}{\sigma}}dx=2\sigma^2$</p><p>$A_2=2\hat\sigma^2$，解得$\hat\sigma=\sqrt{\frac{A_2}{2}}$</p><p>极大似然估计</p><p>$L(\hat\sigma)=\prod f(x_i;\hat\sigma)=\prod\frac{1}{2\hat\sigma}e^{-\frac{|x_i|}{\hat\sigma}}=\frac{1}{2^n\hat\sigma^n}e^{-\frac{\sum|x_i|}{\hat\sigma}}$</p><p>$\ln L(\hat\sigma)=-n\ln(2\hat\sigma)-\frac{\sum|x_i|}{\hat\sigma}$</p><p>$\frac{d\ln L(\hat\sigma)}{d\hat\sigma}=-\frac{n}{\hat\sigma}+\frac{\sum|x_i|}{\hat\sigma^2}=0$，解得$\hat\sigma=\frac{\sum|x_i|}{n}$</p><h1>八、假设检验</h1><h2 id="1-基本步骤">1. 基本步骤</h2><ol><li>建立原假设$H_0$和备择假设$H_1$，确定显著性水平$\alpha$</li><li>选取检验统计量$U$，此时拒绝域$C={|U| \ge u_\frac{\alpha}{2}}$</li><li>计算检验统计量的值$u$，若$u\in C$，则拒绝$H_0$，否则接受$H_0$</li></ol><h2 id="2-单个正态总体的假设检验">2. 单个正态总体的假设检验</h2><h3 id="H-0-mu-mu-0-，-H-1-mu-neq-mu-0">$H_0:\mu=\mu_0$，$H_1:\mu\neq\mu_0$</h3><ol><li>$\sigma^2$已知，$U=\frac{\overline{X}-\mu_0}{\sigma/\sqrt{n}}$ ~ $N(0,1)$</li><li>$\sigma^2$未知，$T=\frac{\overline{X}-\mu_0}{S/\sqrt{n}}$ ~ $t(n-1)$</li></ol><h3 id="H-0-sigma-2-sigma-0-2-，-H-1-sigma-2-neq-sigma-0-2">$H_0:\sigma^2=\sigma_0^2$，$H_1:\sigma^2\neq\sigma_0^2$</h3><p>$\chi^2=\frac{(n-1)S^2}{\sigma_0^2}$ ~ $\chi^2(n-1)$</p><h2 id="3-两个正态总体的假设检验">3. 两个正态总体的假设检验</h2><h3 id="H-0-mu-1-mu-2-，-H-1-mu-1-neq-mu-2">$H_0:\mu_1=\mu_2$，$H_1:\mu_1\neq\mu_2$</h3><ol><li>$\sigma_1^2,\sigma_2^2$已知，$U=\frac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{\sqrt{\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2}}}$ ~ $N(0,1)$</li><li>$\sigma_1^2,\sigma_2^2$未知，$T=\frac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{S_w\sqrt{\frac{1}{n_1}+\frac{1}{n_2}}}$ ~ $t(n_1+n_2-2)$</li></ol><h3 id="H-0-sigma-1-2-sigma-2-2-，-H-1-sigma-1-2-neq-sigma-2-2">$H_0:\sigma_1^2=\sigma_2^2$，$H_1:\sigma_1^2\neq\sigma_2^2$</h3><p>$F=\frac{S_1^2}{S_2^2}$ ~ $F(n_1-1,n_2-1)$</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>教程|本地化部署一个QQ机器人</title>
      <link href="/posts/Tutor_BOT_Deployment.html"/>
      <url>/posts/Tutor_BOT_Deployment.html</url>
      
        <content type="html"><![CDATA[<h1>-1.望粥汁</h1><p>由于go-cqhttp已不再维护，nonebot_plugin_gocqhttp插件已于2024年2月下线noneBot商店，本教程第<code>5.2</code>步之后的方法已不再适用。<br>具体替代方案请参考：<a href="https://github.com/Mrs4s/go-cqhttp/issues/2471">https://github.com/Mrs4s/go-cqhttp/issues/2471</a></p><h1>0.序言</h1><ol><li>本教程主要面向<strong>Windows系统</strong>用户</li><li>教程从0开始全程详细指导，0基础萌新请放心食用🍕</li><li>如果你遇到了问题，在提问前，请仔细检查是否哪一步有遗漏。</li><li>如果你确定自己的操作没问题，可以在评论区里提问。注意留言时请填写正确的邮箱以确保能收到站长的回复。</li></ol><h1>1.搭建前的准备工作：</h1><h2 id="1-1-需要用到的工具">1.1.需要用到的工具</h2><ul><li>一台24小时开机联网的服务器/计算机</li><li>操作系统：Windows10</li><li>文本编辑器（强烈推荐使用VSCode）</li><li>Python3.11.5</li><li>一个闲置的QQ账号</li></ul><h2 id="1-2-Python安装指南">1.2.Python安装指南</h2><p>参考我的这篇文章：<a href="/posts/Tutor_Python_Install.html">Python安装指南</a></p><p>10月2日发布了Python3.12.0版本，站长在10月5日安装机器人框架依赖时会报以下错误：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ERROR: </span>Could not build wheels for yarl, httptools, multidict, which is required to install pyproject.toml-based projects</span><br><span class="line">安装依赖失败! 请手动安装依赖.</span><br></pre></td></tr></table></figure><p>尝试了几种方法没有解决，故使用之前成功过的Python3.11.5版本。</p><p>Python 3.11.5官方下载链接：<a href="https://www.python.org/downloads/release/python-3115/">Python 3.11.5</a><br>国内下载速度可能会有点慢，有条件的可以通过国际网络访问。<br>站长这里提供Windows64位版本的下载：<a href="https://source.cclmsy.cc/Tools/python-3.11.5-amd64.exe">python-3.11.5-amd64</a></p><h2 id="1-3-VSCode安装指南">1.3.VSCode安装指南</h2><p>VSCode是一款轻量化的IDE，支持市面上绝大多数编程语言，具有良好的扩展性，且具有非常友好的代码补全功能。<s>是CC站长的最爱</s><br>下载完成后直接一路确定傻瓜式安装即可//部分自定义配置说明如下：<br><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_12.png" alt="VSCode"></p><p>VSCode官网：<a href="https://code.visualstudio.com/">Visual Studio Code</a><br>同样国内下载比较慢，站长这里提供Windows64位1.82.2版本的下载，VSCode支持软件内更新到最新版本：<a href="https://source.cclmsy.cc/Tools/VSCodeUserSetup-x64-1.82.2.exe">VSCodeUserSetup-x64-1.82.2</a></p><h1>2.安装Nonebot框架</h1><h2 id="2-1-创建文件夹">2.1.创建文件夹</h2><p>创建一个文件夹用于存放项目，然后用VSCode打开这个文件夹。<br><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_13.png" alt="InstallNonebot1"></p><h2 id="2-2-安装pipx">2.2.安装pipx</h2><p>点击“终端-新建终端”（或直接按住Ctrl+Shift+`）创建一个终端，在终端中输入以下命令：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install --<span class="keyword">user</span> <span class="title">pipx</span></span><br><span class="line">python -m pipx ensurepath</span><br></pre></td></tr></table></figure><p>如果出现以下提示，请调整你的账户环境变量：<br><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_14.png" alt="InstallNonebot2"><br>调整账户的环境变量参考：<a href="/posts/Tutor_Python_Install.html">教程|Python安装指南</a></p><p><strong>安装完成后，关闭当前VSCode窗口，重启VSCode后才会生效。</strong></p><h2 id="2-3-安装Nonebot脚手架">2.3.安装Nonebot脚手架</h2><p>创建一个终端，在终端中输入以下命令：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipx install nb-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure><p><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_15.png" alt="InstallNonebot3"><br>如果出现无法找到<code>pipx</code>命令的情况（例如出现“Command not found”字样），请确认你在上一步中账户环境变量设置正确，且<strong>完全重启</strong>VSCode。<br>如果你确信自己的所有配置完全正确，请尝试重启你的计算机。</p><h1>3.创建项目</h1><p>在终端中输入以下命令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nb create</span></span><br></pre></td></tr></table></figure><p>选择“bootstrap (初学者或用户)”，回车。<br><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_16.png" alt="Create1"></p><p>等待资源加载，加载完成后进行如下配置：<br>(键盘上下键移动光标，空格选中，回车确认)</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">[?]</span> 项目名称: <span class="comment">[为你的项目取个名字吧！]</span> (项目名称建议由英文字母和数字构成，因为部分插件可能不支持包含中文的路径)</span><br><span class="line"><span class="comment">[?]</span> 要使用哪些驱动器? FastAPI (FastAPI 驱动器) </span><br><span class="line"><span class="comment">[?]</span> 要使用哪些适配器? OneBot V11 (OneBot V11 协议) </span><br><span class="line"><span class="comment">[?]</span> 立即安装依赖? y</span><br><span class="line"><span class="comment">[?]</span> 创建虚拟环境? y</span><br></pre></td></tr></table></figure><p><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_17.png" alt="Create2"><br>脚手架会自动创建并引入所需的依赖包。</p><p>最后选择安装内置插件<code>echo</code>，这是一个简单的复读回显插件，可以用于测试你的机器人是否正常运行：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[?]</span> 要使用哪些内置插件? echo</span><br></pre></td></tr></table></figure><p>请注意，如果你这一步没有安装<code>echo</code>，<strong>后续将无法进行补装</strong>。<br>如果你操作失误没有安装，请删除当前项目文件夹并返回第<code>3</code>节开头。</p><p>出现以下提示则项目创建成功<br><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_18.png" alt="Create3"></p><p>在终端中输入以下命令进入项目文件夹：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cd</span><span class="meta"> [你的项目的名字]</span></span><br></pre></td></tr></table></figure><p><strong>请注意：后续的操作均需要你的终端处于项目文件夹中。</strong><br>如果你使用的是VSCode，方便起见，你可以直接选择打开项目文件夹作为VSCode工作文件夹：<br><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_22.png" alt="Create4"><br>这样后续VSCode新建终端就会默认处于项目文件夹中。</p><h1>4.编辑配置文件</h1><p>脚手架会在项目文件夹中自动创建一个配置文件<code>.env.prod</code>，但你仍然需要进行一些自定义配置。</p><p>打开项目文件夹下的<code>.env.prod</code>文件，编辑内容如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DRIVER</span>=~fastapi  <span class="comment"># 脚手架自动生成的配置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">HOST</span>=<span class="number">127.0</span>.<span class="number">0.1</span>  <span class="comment"># 配置 NoneBot 监听的 IP / 主机名</span></span><br><span class="line"><span class="attr">PORT</span>=<span class="number">23333</span>  <span class="comment"># 配置 NoneBot 监听的端口</span></span><br></pre></td></tr></table></figure><p>其中<code>HOST</code><strong>必须</strong>设为<code>127.0.0.1</code>（即localhost）<br><code>PORT</code>可以选择你喜欢的数字，范围在0-65535之间。不设置默认为8080，但尽量在15000-50000之间选择，避免和已有的端口发生冲突。</p><p>此外，你可以选择设置超级用户<code>SUPERUSERS</code>、命令起始字符<code>COMMAND_START</code>和命令分割字符<code>COMMAND_SEP</code>，你可以在有需要使用这些设置的时候再行配置。<br>部分插件可能会区分普通用户和超级用户（管理员），可以在<code>SUPERUSERS</code>中设置超级用户<br>设置命令起始字符后，机器人只响应以起始字符开头的命令。<br>设置命令分割字符后，你可以用一个语句包含多个命令，机器人会先按分割字符将命令分开，再按顺序处理。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SUPERUSERS</span>=[<span class="string">&quot;1234567890&quot;</span>,<span class="string">&quot;2333333333&quot;</span>]  <span class="comment"># 配置 NoneBot 的超级用户，可以是多个（你的QQ号）（可选）</span></span><br><span class="line"><span class="attr">COMMAND_START</span>=[<span class="string">&quot;/&quot;</span>]  <span class="comment"># 配置命令起始字符（可选）</span></span><br><span class="line"><span class="attr">COMMAND_SEP</span>=[<span class="string">&quot;.&quot;</span>]  <span class="comment"># 配置命令分割字符（可选）</span></span><br></pre></td></tr></table></figure><h1>5.安装插件</h1><h2 id="5-1-管理插件的方法">5.1.管理插件的方法</h2><blockquote><p>本节旨在让读者了解操作管理插件的流程，选择自己喜欢的管理插件的方式。<br>你也可以选择先跳过本节，在后面的教程中会默认提供方法一的命令。</p></blockquote><p>Nonebot提供了三种管理插件的方法，请确保你的终端当前处于项目文件夹中。<br>其中使用<code>pip</code>安装（方法三）需要手动激活Python虚拟环境，方法一、二管理插件时会自动使用虚拟环境。</p><h3 id="5-1-1-方法一：命令行管理">5.1.1.方法一：命令行管理</h3><p>在终端输入以下命令：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nb plugin install <span class="variable">&lt;插件名称&gt;</span>  <span class="comment"># 安装插件</span></span><br><span class="line">nb plugin uninstall <span class="variable">&lt;插件名称&gt;</span>  <span class="comment"># 卸载插件</span></span><br><span class="line">nb plugin update <span class="variable">&lt;插件名称&gt;</span>  <span class="comment"># 升级插件</span></span><br><span class="line">nb plugin list  <span class="comment"># 列出商店所有插件</span></span><br><span class="line">nb plugin search [关键词]  <span class="comment"># 搜索商店插件</span></span><br></pre></td></tr></table></figure><h3 id="5-1-2-方法二：交互式管理">5.1.2.方法二：交互式管理</h3><p>在终端输入以下命令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nb plugin</span></span><br></pre></td></tr></table></figure><p>将进入控制台交互模式，键盘上下键移动光标，空格选中，回车确认。<br><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_21.png" alt="Plugin1"><br>按照提示输入插件名称即可。</p><h3 id="5-1-3-方法三：使用pip安装">5.1.3.方法三：使用pip安装</h3><p>如果你在第3节中正确创建了项目，那么你的项目文件夹中会有一个<code>.venv</code>文件夹，这是项目的Python虚拟环境文件夹。</p><p>值得一提的是，虚拟环境是Python提供的一个非常实用的功能，它可以将项目环境和全局环境隔离。<br>你可以在虚拟环境中安装和管理项目特定的Python库和依赖项，而不会与全局Python环境相互影响。</p><p>在终端输入以下命令以激活虚拟环境：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\.venv\Scripts\<span class="built_in">activate</span></span><br></pre></td></tr></table></figure><p>如果遇到“禁止运行脚本”的报错，可以参考我的这篇文章来解决：<a href="/posts/28dedfa6.html">教程|Windows系统无法激活Python虚拟环境的解决方案</a><br>如果命令行开头出现一个括号，内容为你的项目名称，则代表Python虚拟环境已经成功激活。</p><p>接下来你可以使用pip命令来管理你的插件：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install <span class="variable">&lt;插件名称&gt;</span>  <span class="comment"># 安装插件</span></span><br><span class="line">pip uninstall <span class="variable">&lt;插件名称&gt;</span>  <span class="comment"># 卸载插件</span></span><br><span class="line">pip install --upgrade <span class="variable">&lt;插件名称&gt;</span>  <span class="comment"># 升级插件</span></span><br><span class="line">pip list  <span class="comment"># 列出当前已经安装的插件（包含Nonebot依赖包）</span></span><br></pre></td></tr></table></figure><p><code>pip</code>相比前两种方法，缺少了列出和搜索商店插件的功能，多了可以查询当前已经安装了的插件的功能。<br>在忘记已经安装的插件或插件名情况下查询比较方便（当然你也可以自己在<code>.\.venv\Lib\site-packages</code>里查看）。</p><h2 id="5-2-安装go-cqhttp">5.2.安装go-cqhttp</h2><p><code>go-cqhttp</code>框架提供了接收QQ事件与调用QQ的API的能力，是QQ机器人的核心组件。<br>NoneBot插件商店中提供了这个框架的插件，插件名称为：<code>nonebot-plugin-gocqhttp</code><br>在终端中输入以下命令安装插件：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nb <span class="keyword">plugin</span> install nonebot-<span class="keyword">plugin</span>-gocqhttp</span><br></pre></td></tr></table></figure><p>安装完成后，在终端中输入以下命令运行机器人：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nb <span class="built_in">run</span></span><br></pre></td></tr></table></figure><p>出现以下提示则安装和运行成功：<br><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_23.png" alt="gocq1"><br>按住Ctrl单击链接进入<code>go-cqhttp</code>的WebUI界面<br><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_24.png" alt="gocq2"></p><h1>6.登录QQ机器人与检查</h1><h2 id="6-1-登录QQ机器人">6.1.登录QQ机器人</h2><p>点击左上角“添加账号”，输入要部署的QQ账号，密码留空，设备类型选择“Android Watch”：<br>（注：也可以选择账号密码登录，但可能出现账号被风控无法登录的情况，手表协议登录相对比较稳定。）<br><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_25.png" alt="QQLogin1"><br>添加完成后点击启动，待加载出二维码后点击“显示登录二维码”。<br>用你的手机登录要部署的QQ账号，扫描二维码登录。<br><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_26.png" alt="QQLogin2"><br>登陆完成后会有消息提示如下：<br><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_27.png" alt="QQLogin3"></p><h2 id="6-2-检查QQ机器人是否正常运行">6.2.检查QQ机器人是否正常运行</h2><p>登录你自己的QQ账号，添加机器人为QQ好友，然后按以下格式发送给机器人消息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\<span class="built_in">echo</span> [自定义消息]</span><br></pre></td></tr></table></figure><p>请注意，不论你有没有配置命令起始字符，在这里echo的开头<strong>必须包含&quot;\&quot;字符</strong>。<br>如果机器人回复了和自定义消息相同的内容，那么恭喜你，你已经成功地完成了QQ机器人的部署。</p><div class="hide-block"><button type="button" class="hide-button" style="background-color:  --theme-color;">点我预览示例    </button><div class="hide-content"><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_28.png" alt="image" style="zoom:67%;" /></div></div><p>这一步完成后，建议将项目文件夹复制一份作为备份。<br>这样后续重置机器人时，只需要将备份复制一份回来即可。</p><h1>7.为你的QQ机器人赋能</h1><p>完成了QQ机器人部署后，你就可以为你的机器人添加插件以实现各种各样的功能。插件的管理方式见<code>5.1</code>节。<br>你可以在官方插件商店找到你需要的插件，根据插件开发者提供的的文档进行安装与配置：<a href="https://nonebot.dev/store/plugins">插件商店</a>。<br>如果你有足够的能力和精力，可以学习NoneBot文档，编写开发自己的插件：<a href="https://nonebot.dev/docs/">NoneBot文档</a>。</p><h1>8.注意事项</h1><ol><li>机器人的运行进程由终端调起，在你运行机器人的过程中，请务必保证你原来的终端窗口一直保持开启状态。如果你使用的是VSCode之类的IDE，请不要关闭你终端所在的窗口。</li><li>机器人以你的计算机作为服务器端，BOT使用期间请务必保证你的服务器/计算机处于开机联网状态。</li><li>Windows系统时常会进行自动更新，必要时可以关闭自动更新。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 机器人 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>教程|Windows系统无法激活Python虚拟环境的解决方案</title>
      <link href="/posts/Tutor_Python_venv_activate.html"/>
      <url>/posts/Tutor_Python_venv_activate.html</url>
      
        <content type="html"><![CDATA[<h1>情况描述</h1><p>在Windows系统终端激活Python虚拟环境时可能出现以下报错（假设你的虚拟环境名为“.venv”）：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS (yourpath<span class="string">\yourProj)&gt;</span> .<span class="string">\.venv\Scripts\activate</span></span><br><span class="line">.<span class="string">\.venv\Scripts\activate</span> : 无法加载文件 (yourpath<span class="string">\yourProj)\.venv\Scripts\activate.ps1，因为在此系统上禁止运行脚本。</span></span><br><span class="line">有关详细信息，请参阅 https:<span class="regexp">/go.microsoft.com/fwlink/</span>?LinkID=<span class="number">135170</span> 中的 about_Execution_Policies。</span><br><span class="line">所在位置 行:<span class="number">1</span> 字符: <span class="number">1</span></span><br><span class="line">+ .<span class="string">\.venv\Scripts\activate</span></span><br><span class="line">+ ~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">    + CategoryInfo          : SecurityError: (:) []，PSSecurityException</span><br><span class="line">    + FullyQualifiedErrorId : UnauthorizedAccess</span><br></pre></td></tr></table></figure><h1>报错原因</h1><p>Windows系统具有执行策略（Execution Policy），导致无法运行虚拟环境的激活脚本。<br>执行策略是Windows中的一种安全机制，它可以防止执行不信任的脚本。</p><h1>解决方案</h1><ol><li>点击屏幕左下角Windows徽标打开“开始”菜单栏，在搜索栏搜索“PowerShell”，然后单击 “以管理员身份运行”。<br><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_19.png" alt="Python_venv1"></li><li>在弹出的终端中输入以下命令，回车：</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Set</span>-ExecutionPolicy <span class="comment">RemoteSigned</span></span><br></pre></td></tr></table></figure><ol start="3"><li>弹出询问时输入“y”，回车：<br><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_20.png" alt="Python_venv2"></li><li>没有消息提示，退出 PowerShell 终端，回到你激活Python虚拟环境的终端。此时可以正常激活Python虚拟环境：</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS (yourpath<span class="string">\yourProj)&gt;</span> .<span class="string">\.venv\Scripts\activate</span></span><br><span class="line">(yourProj) PS (yourpath<span class="string">\yourProj)&gt;</span> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>教程|Python安装指南</title>
      <link href="/posts/Tutor_Python_Install.html"/>
      <url>/posts/Tutor_Python_Install.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-选择正确的版本，下载安装包">1. 选择正确的版本，下载安装包</h2><p>根据你的实际需要选择Python发行版本。值得注意的是，编程语言包并不是越新越好的，不同版本的Python之间可能会产生兼容性问题。<br>如果你不确定你的项目需要哪个版本，请查阅您可能需要使用到的插件的文档或咨询有相关经验的前辈。</p><ul><li>注：Python于10月2日发布3.12.0版本，站长今天使用该版本安装某项目依赖包时发生兼容性错误//本教程采用先前成功过的Python3.11.5版本。</li></ul><p>Python 3.11.5官方下载链接：<a href="https://www.python.org/downloads/release/python-3115/">Python 3.11.5</a><br>拉到页面底部，<strong>根据你的系统选择对应的版本下载</strong>，站长使用的是64位Windows系统，国内大多数普通用户使用的一般也是这个版本。<br><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_01.png" alt="Download"></p><p>国内下载速度可能会有点慢，有条件的可以通过国际网络访问<br>站长这里提供Python 3.11.5 Windows64位版本的下载：<a href="https://source.cclmsy.cc/Tools/python-3.11.5-amd64.exe">python-3.11.5-amd64</a></p><h2 id="2-安装Python到计算机">2. 安装Python到计算机</h2><p>下载完成后，打开文件所在的文件夹，选中文件右键，以管理员身份运行，按下图所示的步骤安装<br><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_02.png" alt="Install1"><br><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_03.png" alt="Install2"><br><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_04.png" alt="Install3"><br><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_05.png" alt="Install4"><br><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_06.png" alt="Install5"></p><h2 id="3-检查环境变量">3. 检查环境变量</h2><ol><li>打开设置，搜索“环境变量”，点击“编辑账户的环境变量”<br><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_07.png" alt="Env1"></li><li>在弹出的页面单击选中“Path”，点击“编辑”<br><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_08.png" alt="Env2"></li><li>在弹出的页面查看是否包含这两项。若没有，则添加这两项。（如果你在上一步自定义了安装路径，则添加对应的路径）<br><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_09.png" alt="Env3"></li><li>依次点击上面两个弹窗的“确定”，才能正确保存PATH。如果不确定是否正确保存，可以回去看一下//</li></ol><h2 id="4-检查是否正确安装了Python">4. 检查是否正确安装了Python</h2><ol><li>键盘按Windows+R，输入cmd运行终端<br><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_10.png" alt="Check1"></li><li>输入python回车，若显示版本号则表示安装成功<br><img src="https://source.cclmsy.cc/Images/Posts/BOT/BOT_11.png" alt="Check2"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduction</title>
      <link href="/posts/ed318fdc.html"/>
      <url>/posts/ed318fdc.html</url>
      
        <content type="html"><![CDATA[<h1>博客介绍</h1><p>关于网站、关于站长：见<a href="/about">关于</a>栏目<br>维护日志：见<a href="/site/time">旧时光</a>栏目</p><p>欢迎来到CCLMSY的Blog！<br>本博客自2023/9/26开始建设，于2023/10/4正式发布。<br>博客不定期更新算法竞赛题解、学习笔记、模板等内容//<br><s>也可能会日常发疯（毕竟带学生哪有不疯的）</s><br>网站已开启邮件提醒功能。正确输入邮箱后，评论收到回复将有邮件提醒。</p><p>已知问题：</p><ul><li>由于书写时使用的MarkDown版本不同，部分内容的MarkDown格式或Katex公式渲染可能会不正确。如有发现请在评论区指正！非常感谢！（鞠躬）</li><li>使用国际网络访问可能导致无法正常使用自定义美化功能，目前尚未查明原因。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划-背包DP</title>
      <link href="/posts/Model_DP_Bag.html"/>
      <url>/posts/Model_DP_Bag.html</url>
      
        <content type="html"><![CDATA[<h1>1.01背包</h1><h2 id="1-1-DFS记忆化搜索">1.1.DFS记忆化搜索</h2><p>$O(wn)$ <a href="https://www.luogu.com.cn/problem/P1048">洛谷P1048</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 1005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 105</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;z</span><br><span class="line">ll mem[W][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll maxw,n;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll i,ll curw)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mem[i][curw]) <span class="keyword">return</span> mem[i][curw];</span><br><span class="line">    <span class="keyword">if</span>(i&gt;n) <span class="keyword">return</span> mem[i][curw]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(curw&gt;=w[i])</span><br><span class="line">        <span class="keyword">return</span> mem[i][curw]=<span class="built_in">max</span>(<span class="built_in">dfs</span>(i+<span class="number">1</span>,curw-w[i])+v[i],<span class="built_in">dfs</span>(i+<span class="number">1</span>,curw));</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> mem[i][curw]=<span class="built_in">dfs</span>(i+<span class="number">1</span>,curw);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(<span class="number">1</span>,maxw) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-二维数组">1.2.二维数组</h2><p>$O(wn) M(wn)$ <a href="https://www.luogu.com.cn/problem/P1048">洛谷P1048</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*----------Code Area----------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 105</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[N][W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n,maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,maxw)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=w[i]) dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j-w[i]]+v[i],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-一维滚动数组">1.3.一维滚动数组</h2><p>$O(wn) M(w)$ <a href="https://www.luogu.com.cn/problem/P2871">洛谷P2871</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 20005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n,maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; maxw;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) </span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,w[i])&#123;<span class="comment">//01背包从大到小遍历，每个物品只能取一次</span></span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j-w[i]]+v[i],dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>2.完全背包</h1><h2 id="2-1-一维滚动数组">2.1.一维滚动数组</h2><p>$O(wn) M(w)$ <a href="https://www.luogu.com.cn/problem/P1616">洛谷P1616</a><br>和01背包唯一区别在剩余容量从小到大遍历，每个物品能取多次</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 10000005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n,maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) </span><br><span class="line">        <span class="built_in">FORLL</span>(j,w[i],maxw)&#123;<span class="comment">//和01背包唯一区别在从小到大遍历，每个物品能取多次</span></span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j-w[i]]+v[i],dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-贪心优化">2.2.贪心优化</h2><p>$O(wn) M(w)$ <a href="https://www.luogu.com.cn/problem/P1616">洛谷P1616</a><br>贪心思想：对于两件物品 $i,j$ ，如果 $w_i \le w_j \And v_i \ge v_j$ ，则只需保留 $i$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 10000005</span></span><br><span class="line">vector&lt;pll&gt; objs,tv;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n,maxw,w,v;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    tv.<span class="built_in">resize</span>(n);<span class="comment">//物品：&lt;weight,value&gt;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:tv) cin &gt;&gt; x.first &gt;&gt; x.second;</span><br><span class="line">    <span class="built_in">SORT</span>(tv);ll maxv=<span class="number">-1</span>;<span class="comment">//物品序列按主w次v排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:tv)</span><br><span class="line">        <span class="keyword">if</span>(x.second&gt;maxv)<span class="comment">//O(n)筛去多余物品</span></span><br><span class="line">            &#123;objs.<span class="built_in">emplace_back</span>(x);maxv=x.second;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:objs)&#123;</span><br><span class="line">        w=x.first;v=x.second;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,w,maxw)&#123;<span class="comment">//和01背包唯一区别在从小到大遍历，每个物品能取多次</span></span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j-w]+v,dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>3.多重背包</h1><h2 id="3-1-朴素方法">3.1.朴素方法</h2><p>$O(w\sum cnt_i)$<br>朴素方法：按有 $cnt_i$ 个的物品 $i$ ，进行01背包</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 100005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n=<span class="number">0</span>,maxw,tn;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; tn &gt;&gt; maxw;</span><br><span class="line">    ll tv,tw,cnt,n=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,tn)&#123;</span><br><span class="line">        cin &gt;&gt; tv &gt;&gt; tw &gt;&gt; cnt;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,cnt)&#123;</span><br><span class="line">            v[++n]=tv;</span><br><span class="line">            w[n]=tw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,w[i])</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j-w[i]]+v[i],dp[j]);</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-二进制分组">3.2.二进制分组</h2><p>$O(w\sum\lg{cnt_i})$<br>二进制分组优化：对于每个物品，将其按二进制分组，捆绑一个物品</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 100005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n=<span class="number">0</span>,maxw,tn;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; tn &gt;&gt; maxw;</span><br><span class="line">    ll tv,tw,cnt,n=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,tn)&#123;</span><br><span class="line">        cin &gt;&gt; tv &gt;&gt; tw &gt;&gt; cnt;</span><br><span class="line">        ll b=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cnt&gt;b)&#123;</span><br><span class="line">            v[++n]=tv*b;</span><br><span class="line">            w[n]=tw*b;</span><br><span class="line">            cnt-=b;b*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt) &#123;v[++n]=tv*cnt;w[n]=tw*cnt;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,w[i])</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j-w[i]]+v[i],dp[j]);</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>4.混合背包</h1><p>$O(wn)$ <a href="https://www.luogu.com.cn/problem/P1833">洛谷P1833</a><br>01背包、多重背包和完全背包的缝合怪//</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 100005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> cnt[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n=<span class="number">0</span>,maxw,tn;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll h1,m1,h2,m2;<span class="type">char</span> tc;</span><br><span class="line">    cin &gt;&gt; h1 &gt;&gt; tc &gt;&gt; m1 &gt;&gt; h2 &gt;&gt; tc &gt;&gt; m2 &gt;&gt; tn;</span><br><span class="line">    maxw=<span class="built_in">abs</span>((h2*<span class="number">60</span>+m2)-(h1*<span class="number">60</span>+m1));</span><br><span class="line">    ll tv,tw,tcnt,n=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,tn)&#123;</span><br><span class="line">        cin &gt;&gt; tw &gt;&gt; tv &gt;&gt; tcnt;</span><br><span class="line">        <span class="keyword">if</span>(tcnt)&#123;</span><br><span class="line">            ll b=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(tcnt&gt;b)&#123;</span><br><span class="line">                v[++n]=tv*b;</span><br><span class="line">                w[n]=tw*b;</span><br><span class="line">                cnt[n]=b;</span><br><span class="line">                tcnt-=b;b*=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="comment">//多重背包二进制分组</span></span><br><span class="line">            <span class="keyword">if</span>(tcnt) &#123;v[++n]=tv*tcnt;w[n]=tw*tcnt;cnt[n]=<span class="number">1</span>;&#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            v[++n]=tv;</span><br><span class="line">            w[n]=tw;</span><br><span class="line">            cnt[n]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="keyword">if</span>(cnt[i])&#123;<span class="comment">//01背包</span></span><br><span class="line">            <span class="built_in">FORLL_rev</span>(j,maxw,w[i])</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j-w[i]]+v[i],dp[j]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//完全背包</span></span><br><span class="line">            <span class="built_in">FORLL</span>(j,w[i],maxw)</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j-w[i]]+v[i],dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>5.二维费用背包</h1><p>$O(nw_1w_2)$ <a href="https://www.luogu.com.cn/problem/P1855">洛谷P1855</a><br>具有两种费用属性的背包问题，以01背包为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 205</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w1[N]=&#123;<span class="number">0</span>&#125;,w2[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W][W]=&#123;<span class="number">0</span>&#125;;<span class="comment">//二维滚动数组</span></span><br><span class="line">ll n,maxw1,maxw2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; maxw1 &gt;&gt; maxw2;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; w1[i] &gt;&gt; w2[i];</span><br><span class="line">        v[i]=<span class="number">1</span>;<span class="comment">//本题中价值均为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j1,maxw1,w1[i])</span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j2,maxw2,w2[i])</span><br><span class="line">            dp[j1][j2]=<span class="built_in">max</span>(dp[j1-w1[i]][j2-w2[i]]+v[i],dp[j1][j2]);</span><br><span class="line">    cout &lt;&lt; dp[maxw1][maxw2] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>6.分组背包</h1><p>$O(nw)$ <a href="https://www.luogu.com.cn/problem/P1757">洛谷P1757</a><br>01背包的进化体，每个组中最多能取1个物品</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 65536</span></span><br><span class="line">ll maxw,n;</span><br><span class="line">ll v[<span class="number">105</span>][N]=&#123;<span class="number">0</span>&#125;,w[<span class="number">105</span>][N]=&#123;<span class="number">0</span>&#125;,dp[<span class="number">1000</span>*N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll cnt[<span class="number">105</span>]=&#123;<span class="number">0</span>&#125;,mxid=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    ll tv,tw,id;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; tw &gt;&gt; tv &gt;&gt; id;</span><br><span class="line">        cnt[id]++;</span><br><span class="line">        v[id][cnt[id]]=tv;</span><br><span class="line">        w[id][cnt[id]]=tw;</span><br><span class="line">        mxid=<span class="built_in">max</span>(mxid,id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(k,<span class="number">1</span>,mxid)<span class="comment">//对于每一组物品</span></span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,<span class="number">0</span>)<span class="comment">//对于每一种容量（从后往前遍历，保证同组两种物品不同时取到）</span></span><br><span class="line">            <span class="built_in">FORLL</span>(i,<span class="number">1</span>,cnt[k]) <span class="keyword">if</span>(j&gt;=w[k][i])<span class="comment">//放入该组每种物品时可达到的最大值</span></span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j-w[k][i]]+v[k][i],dp[j]);</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>7.有依赖的背包</h1><p>$O(nw)$ <a href="https://www.luogu.com.cn/problem/P1064">洛谷P1064</a><br>分组背包的进化体，将所有主副件组合方案作为一组进行分组背包</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> W 32005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 61</span></span><br><span class="line">ll maxw,n;</span><br><span class="line">ll w[N][<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;,v[N][<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;,dp[W]=&#123;<span class="number">0</span>&#125;,cnt[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">vector&lt;ll&gt; id_list;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    ll tw,tp,id;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; tw &gt;&gt; tp &gt;&gt; id;</span><br><span class="line">        <span class="keyword">if</span>(id==<span class="number">0</span>)&#123;<span class="comment">//0：纯主件</span></span><br><span class="line">            id=i;w[id][<span class="number">0</span>]=tw;v[id][<span class="number">0</span>]=tw*tp;</span><br><span class="line">            id_list.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cnt[id]==<span class="number">0</span>)&#123;<span class="comment">//1：主件+配件1</span></span><br><span class="line">            cnt[id]++;</span><br><span class="line">            w[id][<span class="number">1</span>]=tw+w[id][<span class="number">0</span>];</span><br><span class="line">            v[id][<span class="number">1</span>]=tw*tp+v[id][<span class="number">0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cnt[id]==<span class="number">1</span>)&#123;<span class="comment">//2：主件+配件2//3：主件+配件1+配件2</span></span><br><span class="line">            cnt[id]++;</span><br><span class="line">            w[id][<span class="number">2</span>]=tw+w[id][<span class="number">0</span>];</span><br><span class="line">            v[id][<span class="number">2</span>]=tw*tp+v[id][<span class="number">0</span>];</span><br><span class="line">            w[id][<span class="number">3</span>]=tw+w[id][<span class="number">1</span>];</span><br><span class="line">            v[id][<span class="number">3</span>]=tw*tp+v[id][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> k:id_list)&#123;<span class="comment">//对于每一组物品</span></span><br><span class="line">        ll t=<span class="number">0</span>; <span class="keyword">if</span>(cnt[k]==<span class="number">1</span>) t=<span class="number">1</span>; <span class="keyword">if</span>(cnt[k]==<span class="number">2</span>) t=<span class="number">3</span>; </span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,<span class="number">0</span>)<span class="comment">//对于每一种容量（从后往前遍历，保证同组两种方案不同时取到）</span></span><br><span class="line">            <span class="built_in">FORLL</span>(i,<span class="number">0</span>,t) <span class="keyword">if</span>(j&gt;=w[k][i])<span class="comment">//采取该组每种方案时可达到的最大值</span></span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j-w[k][i]]+v[k][i],dp[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>8.进阶问题</h1><h2 id="1-求具体方案">1.求具体方案</h2><p>$O(wn)$<br>以完全背包为例，在转移时记录容量j下选择的物品编号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 10000005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;,cnt[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;,g[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n,maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) </span><br><span class="line">        <span class="built_in">FORLL</span>(j,w[i],maxw)&#123;<span class="comment">//和01背包唯一区别在从小到大遍历，每个物品能取多次</span></span><br><span class="line">            <span class="keyword">if</span>(dp[j-w[i]]+v[i]&gt;dp[j])&#123;</span><br><span class="line">                dp[j]=dp[j-w[i]]+v[i];</span><br><span class="line">                g[j]=i;<span class="comment">//记录在容量j下选择了物品i</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">    ll curw=maxw;</span><br><span class="line">    <span class="keyword">while</span>(g[curw])&#123;</span><br><span class="line">        cnt[g[curw]]++;</span><br><span class="line">        curw-=w[g[curw]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) ;<span class="comment">//输出方案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-装满方案计数">2.装满方案计数</h2><p>对于给定的一个背包容量、物品费用、其他关系等的问题，求装到一定容量的方案总数。</p><h3 id="2-1-不考虑顺序">2.1.不考虑顺序</h3><p>$O(wn)$<br>不同的选择顺序看作相同方案。以01背包为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 20005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//dp[0]即不选，方案数为1</span></span><br><span class="line">ll n,maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; maxw;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="comment">//先遍历物品</span></span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,w[i])&#123;<span class="comment">//01背包从大到小遍历，每个物品只能取一次</span></span><br><span class="line">            dp[j]=dp[j]+dp[j-w[i]];<span class="comment">//不选+选</span></span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-考虑顺序">2.2.考虑顺序</h3><p>$O(wn)$ ZJNU C1299_B<br>不同的选择顺序看作不同方案。以完全背包为例</p><blockquote><p>从 $0$ 到 $n$ ，每次可以前进 {1,2,4} ，求方案数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> W 205</span></span><br><span class="line">ll w[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">ll maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw;</span><br><span class="line">    <span class="built_in">FORLL</span>(j,<span class="number">1</span>,maxw) <span class="comment">//先遍历容量</span></span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,<span class="number">3</span>) <span class="keyword">if</span>(j&gt;=w[i])</span><br><span class="line">            dp[j]=dp[j]+dp[j-w[i]];</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-最优方案计数">3.最优方案计数</h2><p>$O(wn)$<br>求最优背包方案数，以01背包为例，g[j]代表容量j下最优方案数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 20005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;,g[W]=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//g[0]即不选，方案数为1</span></span><br><span class="line">ll n,maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; maxw;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) </span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,w[i])<span class="comment">//01背包从大到小遍历，每个物品只能取一次</span></span><br><span class="line">            <span class="keyword">if</span>(dp[j-w[i]]+v[i]&gt;dp[j])&#123;<span class="comment">//取 最优</span></span><br><span class="line">                dp[j]=dp[j-w[i]]+v[i];</span><br><span class="line">                g[j]=g[j-w[i]];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[j-w[i]]+v[i]==dp[j]) g[j]+=g[j-w[i]]; <span class="comment">//取或不取都最优</span></span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; g[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-求第k优解">4.求第k优解</h2><p>$O(wnk)$ <a href="https://vjudge.net/problem/HDU-2639">HDU2639</a><br>求背包的第k优解，以01背包为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 1005</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ll dp[W][<span class="number">35</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//dp[j][k]表示容量j下第k优解</span></span><br><span class="line">    ll a[<span class="number">35</span>]=&#123;<span class="number">0</span>&#125;,b[<span class="number">35</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ll n,maxw,tark;</span><br><span class="line">    ll x,y,z;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; maxw &gt;&gt; tark;</span><br><span class="line">    a[tark+<span class="number">1</span>]=b[tark+<span class="number">1</span>]=<span class="number">-1</span>;<span class="comment">//哨兵</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="comment">//考虑前i个物品时</span></span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,w[i])&#123; <span class="comment">//容量为j下</span></span><br><span class="line">            <span class="built_in">FORLL</span>(k,<span class="number">1</span>,tark)&#123;</span><br><span class="line">                a[k]=dp[j-w[i]][k]+v[i];<span class="comment">//第k优解，选</span></span><br><span class="line">                b[k]=dp[j][k];<span class="comment">//第k优解，不选</span></span><br><span class="line">            &#125;<span class="comment">//dp数组不升保证a,b数组不升</span></span><br><span class="line">            x=y=z=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(z&lt;=tark&amp;&amp;!(a[x]==<span class="number">-1</span>&amp;&amp;b[y]==<span class="number">-1</span>))&#123;<span class="comment">//循环直到找到全部前k解，或两指针都到末尾</span></span><br><span class="line">                <span class="keyword">if</span>(a[x]&gt;b[y]) dp[j][z]=a[x++];</span><br><span class="line">                <span class="keyword">else</span> dp[j][z]=b[y++];</span><br><span class="line">                <span class="keyword">if</span>(dp[j][z]!=dp[j][z<span class="number">-1</span>]) z++;<span class="comment">//非严格比较则删去if条件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw][tark] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Reference：<a href="https://oi-wiki.org/dp/">OI-Wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码/模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划-其他</title>
      <link href="/posts/Models_DP_Others.html"/>
      <url>/posts/Models_DP_Others.html</url>
      
        <content type="html"><![CDATA[<h1>一.子序列问题</h1><h2 id="1-最长公共子序列-LCS">1.最长公共子序列(LCS)</h2><p>O(mn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 1005</span></span><br><span class="line">ll a[N]=&#123;<span class="number">0</span>&#125;,b[N]=&#123;<span class="number">0</span>&#125;,dp[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m) cin &gt;&gt; b[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j]) dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-最长上升子序列">2.最长上升子序列</h2><h3 id="2-1-DP">2.1.DP</h3><p>$O(n^2)$ 洛谷B3637</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*----------Code Area----------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line">ll a[N]=&#123;<span class="number">0</span>&#125;,dp[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; a[i];</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        ll mx=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,i<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[j]) mx=<span class="built_in">max</span>(mx,dp[j]);</span><br><span class="line">        dp[i]=mx+<span class="number">1</span>;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-贪心">2.2.贪心</h3><p>$O(n\log n)$ 洛谷B3637<br>贪心：维护当前子序列d，替换序列中不小于a[i]的第一个元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line">ll a[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">vector&lt;ll&gt; d;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; a[i];</span><br><span class="line">    d.<span class="built_in">emplace_back</span>(a[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d.<span class="built_in">back</span>()&lt;a[i]) d.<span class="built_in">emplace_back</span>(a[i]);</span><br><span class="line">        <span class="keyword">else</span> *<span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(d),a[i])=a[i];</span><br><span class="line">    &#125;<span class="comment">//最长不降子序列改成upper_bound</span></span><br><span class="line">    cout &lt;&lt; d.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>二.区间DP</h1><p>$O(n^3)$ NOI1995/LOJ10147<br>分治：父问题的答案由子问题集中最优解转移</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 205</span></span><br><span class="line">ll v[N*<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;,S[N*<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dpmx[N*<span class="number">2</span>][N*<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;,dpmn[N*<span class="number">2</span>][N*<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; v[i];</span><br><span class="line">        v[i+n]=v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n*<span class="number">2</span>) <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n*<span class="number">2</span>) dpmn[i][j]=INF;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n*<span class="number">2</span>) dpmn[i][i]=<span class="number">0</span>;<span class="comment">//Init</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n*<span class="number">2</span>) S[i]=S[i<span class="number">-1</span>]+v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(len,<span class="number">1</span>,n)&#123;<span class="comment">//枚举区间长度</span></span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n*<span class="number">2</span>-len+<span class="number">1</span>)&#123;</span><br><span class="line">            ll j=i+len<span class="number">-1</span>;<span class="comment">//根据长度和i算出j</span></span><br><span class="line">            <span class="built_in">FORLL</span>(k,i,j<span class="number">-1</span>)&#123;<span class="comment">//枚举分界点</span></span><br><span class="line">                dpmx[i][j]=<span class="built_in">max</span>(dpmx[i][j],dpmx[i][k]+dpmx[k+<span class="number">1</span>][j]+S[j]-S[i<span class="number">-1</span>]);</span><br><span class="line">                dpmn[i][j]=<span class="built_in">min</span>(dpmn[i][j],dpmn[i][k]+dpmn[k+<span class="number">1</span>][j]+S[j]-S[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;<span class="comment">//转移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mx=<span class="number">0</span>,mn=INF;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n+<span class="number">1</span>) mx=<span class="built_in">max</span>(mx,dpmx[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n+<span class="number">1</span>) mn=<span class="built_in">min</span>(mn,dpmn[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    cout &lt;&lt; mn &lt;&lt; endl &lt;&lt; mx &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>三.期望DP</h1><p>ATC-abc323_e<br>某点的期望从此前的一段区间内转移</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 1003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X 10004</span></span><br><span class="line">ll dp[X]=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//歌曲在t时刻切换的概率</span></span><br><span class="line">ll t[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,x;cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; t[i];</span><br><span class="line">    ll invn=<span class="built_in">inv</span>(n);<span class="comment">//1/n</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,x)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n) <span class="keyword">if</span>(i&gt;=t[j])</span><br><span class="line">            <span class="built_in">addto</span>(dp[i],dp[i-t[j]]);</span><br><span class="line">        <span class="built_in">multo</span>(dp[i],invn);</span><br><span class="line">    &#125;</span><br><span class="line">    ll re=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="built_in">max</span>(<span class="number">0ll</span>,x-t[<span class="number">1</span>]+<span class="number">1</span>),x) <span class="built_in">addto</span>(re,dp[i]);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">multo</span>(re,invn) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>四.DP优化</h1><h2 id="1-单调队列优化DP">1. 单调队列优化DP</h2><p>O(mn) M(m) CF372C<br>利用单调队列将每次区间DP均摊复杂度降至O(1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 305</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 150005</span></span><br><span class="line">ll a[N]=&#123;<span class="number">0</span>&#125;,b[N]=&#123;<span class="number">0</span>&#125;,t[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[<span class="number">2</span>][M]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n,m,d;<span class="type">int</span> fl=<span class="number">1</span>;</span><br><span class="line">ll que[M]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m) cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; t[i];</span><br><span class="line">    fl=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        ll l=<span class="number">1</span>,r=<span class="number">0</span>,k=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="keyword">for</span>(;k&lt;=<span class="built_in">min</span>(n,j+(t[i]-t[i<span class="number">-1</span>])*d);k++)&#123;</span><br><span class="line">                <span class="keyword">while</span>(r&gt;=l&amp;&amp;dp[fl^<span class="number">1</span>][que[r]]&lt;dp[fl^<span class="number">1</span>][k]) r--;</span><br><span class="line">                que[++r]=k;<span class="comment">//单调队列优化DP：维护上一状态的有效区间内的最大值的下标</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(r&gt;=l&amp;&amp;que[l]&lt;<span class="built_in">max</span>(<span class="number">1ll</span>,j-(t[i]-t[i<span class="number">-1</span>])*d)) l++;</span><br><span class="line">            dp[fl][j]=dp[fl^<span class="number">1</span>][que[l]]+b[i]-<span class="built_in">abs</span>(a[i]-j);</span><br><span class="line">        &#125;fl^=<span class="number">1</span>;<span class="comment">//状态转换</span></span><br><span class="line">    &#125;fl^=<span class="number">1</span>;<span class="comment">//回到最终状态</span></span><br><span class="line">    ll ans=-INF;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) ans=<span class="built_in">max</span>(ans,dp[fl][i]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Reference：<a href="https://oi-wiki.org/dp/">OI-Wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码/模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期牛客多校10</title>
      <link href="/posts/ACM_2023Summer_NCD10.html"/>
      <url>/posts/ACM_2023Summer_NCD10.html</url>
      
        <content type="html"><![CDATA[<h1>K.First Last</h1><p><strong>签到题</strong></p><h2 id="题意">题意</h2><p>$n$ 个人参加 $m$ 场比赛，每场比赛中获得名次得概率均等<br>问针对某一人，他在所有场次比赛中都获得第一或倒数第一的概率</p><h2 id="解题思路">解题思路</h2><p>如果人数 $n&gt;1$ ，每场比赛的概率是 $p=\dfrac{2}{n}$ ；人数为 $1$ 时 $p=1$</p><p>输出 $p^m$ 即可</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">double</span> p=<span class="number">2.</span>/n,re=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) p=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m) re*=p;</span><br><span class="line">    <span class="built_in">print_float</span>(re,<span class="number">15</span>);cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>M.Fair Equation</h1><p><strong>模拟</strong></p><h2 id="题意-2">题意</h2><p>给定一个式子 $A+B=C$ ，其中正整数 $A,B,C\le 10^6$<br>问能否在 $A,B,C$ 其中一个数的某一位置（可以是开头和结尾）插入一个数字，使得等式成立；或原式自然成立。<br>若成立，输出成立的等式</p><h2 id="解题思路-2">解题思路</h2><p>如题如题目所述，取出等式中的数字，逐位模拟即可。具体实现可参考代码</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_equal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; YES;</span><br><span class="line">    cout &lt;&lt; num[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; num[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; num[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;<span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="built_in">get_nums</span>(s);ll t;<span class="comment">//分离出数字</span></span><br><span class="line">    <span class="keyword">if</span>(num[<span class="number">0</span>]+num[<span class="number">1</span>]==num[<span class="number">2</span>]) &#123;<span class="built_in">print_equal</span>();<span class="keyword">return</span> ;&#125;<span class="comment">//原式成立</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,<span class="number">9</span>)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(k,<span class="number">0</span>,numlen[<span class="number">0</span>])&#123;</span><br><span class="line">            t=(num[<span class="number">0</span>]/pow_10[k])*pow_10[k]*<span class="number">10</span>+i*pow_10[k]+num[<span class="number">0</span>]%pow_10[k];</span><br><span class="line">            <span class="keyword">if</span>(t+num[<span class="number">1</span>]==num[<span class="number">2</span>]) &#123;num[<span class="number">0</span>]=t;<span class="built_in">print_equal</span>();<span class="keyword">return</span> ;&#125;</span><br><span class="line">        &#125;<span class="comment">//在A的第k位插入i，判断是否符合条件，下面同理</span></span><br><span class="line">        <span class="built_in">FORLL</span>(k,<span class="number">0</span>,numlen[<span class="number">1</span>])&#123;</span><br><span class="line">            t=(num[<span class="number">1</span>]/pow_10[k])*pow_10[k]*<span class="number">10</span>+i*pow_10[k]+num[<span class="number">1</span>]%pow_10[k];</span><br><span class="line">            <span class="keyword">if</span>(num[<span class="number">0</span>]+t==num[<span class="number">2</span>]) &#123;num[<span class="number">1</span>]=t;<span class="built_in">print_equal</span>();<span class="keyword">return</span> ;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">FORLL</span>(k,<span class="number">0</span>,numlen[<span class="number">0</span>])&#123;</span><br><span class="line">            t=(num[<span class="number">2</span>]/pow_10[k])*pow_10[k]*<span class="number">10</span>+i*pow_10[k]+num[<span class="number">2</span>]%pow_10[k];</span><br><span class="line">            <span class="keyword">if</span>(num[<span class="number">0</span>]+num[<span class="number">1</span>]==t) &#123;num[<span class="number">2</span>]=t;<span class="built_in">print_equal</span>();<span class="keyword">return</span> ;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期杭电多校10</title>
      <link href="/posts/ACM_2023Summer_HDU10.html"/>
      <url>/posts/ACM_2023Summer_HDU10.html</url>
      
        <content type="html"><![CDATA[<h1><a href="http://1004.Do">1004.Do</a> You Like Interactive Problems?</h1><p><strong>概率论-数学期望</strong></p><h2 id="题意">题意</h2><p>给定一个正整数 $n$ ，在 $1$ ~ $n$ 范围内有一个正整数 $x$<br>进行若干轮猜测，每次猜测在 $1$ ~ $n$ 范围内等概率随机选择一个正整数 $y$ ，可以得到如下信息中的一个： $y&gt;x,y=x,y&lt;x$<br><strong>每次猜测后，下一次猜测仍在原范围内随机选择</strong>。当得到的信息能够唯一确定 $x$ 时，游戏结束<br>求猜测轮数的数学期望</p><h2 id="解题思路">解题思路</h2><p>由题意可知，当且仅当出现以下情况时，可以唯一确定 $x$ ：</p><ol><li>选到 $x$</li><li>$x$ 的相邻元素都被选到</li></ol><p>每次选择后，下一次选择的范围是不变的，因此其他元素的信息对唯一确定 $x$ 是没有作用的</p><p>对于给定 $n$ ，根据以下情况展开讨论：</p><ol><li>不论 $x$ 的位置，直接选到 $x$ ，轮数为 $1$ ，概率为 $\dfrac{1}{n}$</li><li>已经选到一个相邻点（或 $x$ 在两端），轮数期望记为 $E_2$<ol><li>选另一相邻点（或唯一相邻点），轮数为 $1$ ，概率为 $\dfrac{1}{n}$</li><li>选其他点没有贡献，概率为 $\dfrac{n-2}{n}$</li></ol></li><li>$x$ 在中间，没有选到过相邻点，轮数期望记为 $E_3$<ol><li>选到两个相邻点之一，转移到情况 $2$ ，概率为 $\dfrac{2}{n}$</li><li>选到其他点没有贡献，概率为 $\dfrac{n-3}{n}$</li></ol></li></ol><p>综上可得：</p><p>$E_2=\dfrac{1}{n}+\dfrac{1}{n}+\dfrac{n-2}{n}(1+E_2)$</p><p>$E_3=\dfrac{1}{n}+\dfrac{2}{n}(1+E_2)+\dfrac{n-3}{n}(1+E_3)$</p><p>解得 $E_2=\dfrac{n}{2},E_3=\dfrac{2n}{3}$<br>得到最终期望为：$E=\dfrac{2}{n}E_2+\dfrac{n-2}{n}E_3=\dfrac{2n-1}{3}$</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    ll t=<span class="built_in">mul</span>(<span class="built_in">Get_Mod</span>(<span class="number">2</span>*(n<span class="number">-2</span>)+<span class="number">3</span>),<span class="built_in">inv</span>(<span class="number">3</span>));</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1012.Equalize the Array</h1><p><strong>签到</strong></p><h2 id="题意-2">题意</h2><p>定义一个数组的 $mode$ 是其中出现次数最多的数字（可不唯一）<br>给定一个数组 $a$ ，每次操作可以选定其一个 $mode$ 并使数组中所有与之相等的元素 $+1$<br>问任意次操作后能否使数组中全部元素相等</p><h2 id="解题思路-2">解题思路</h2><p>如果数组中最小的元素是 $mode$ ，连续操作最小元素即可实现//<br>元素计数，判断最小元素出现次数是否最多即可</p><h3 id="时间复杂度">时间复杂度</h3><p>$O(n\log n)$</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    map&lt;ll,ll&gt; mp;ll t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;mp[t]++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mxcnt=<span class="number">0</span>,mxi=<span class="number">0</span>,mn=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        t=mp[i];<span class="keyword">if</span>(!mn&amp;&amp;t) mn=i;</span><br><span class="line">        <span class="keyword">if</span>(t&gt;mxcnt) &#123;mxcnt=t;mxi=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mxi&lt;=mn) cout &lt;&lt; YES;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期杭电多校09</title>
      <link href="/posts/ACM_2023Summer_HDU09.html"/>
      <url>/posts/ACM_2023Summer_HDU09.html</url>
      
        <content type="html"><![CDATA[<h1>1002.Shortest path</h1><p><strong><s>签到题</s></strong> <strong>DFS记忆化搜索</strong></p><h2 id="题意">题意</h2><p>给定一个正整数 $n$ ，可以对其进行以下操作：</p><ol><li>如果 $n$ 能被 $3$ 整除，则可以使 $n=n/3$ ;</li><li>如果 $n$ 能被 $2$ 整除，则可以使 $n=n/2$ ;</li><li>使 $n=n-1$</li></ol><p>求使得 $n$ 变成 $1$ 的最少操作次数</p><h2 id="解题思路">解题思路</h2><p><s>将样例Output输出即可</s></p><blockquote><p>这题不难，但确实精彩()//毕竟……<br>《钉耙编程”中国大学生算法设计超级联赛》是由hdu自主研发的一款全新开放世界冒险竞赛。竞赛发生在一个被称作“hdu”的幻想世界，在这里，被编译器选中的人将被授予“C++”，导引代码之力。你将扮演一位名为“acmer”的神秘角色，在自由的打题中邂逅性格各异能力独特的STL容器，和他们一起击败强题，找回AC的代码</p></blockquote><p>不闹了，解题吧</p><p>不难看出操作 $3$ 的收益最低，是不满足操作 $1,2$ 的时候凑条件用的。<br>而由于只允许整除，操作 $1,2$ 的优劣性不好评估（因为要夹杂操作 $3$ 而不单纯是减少的量的区别），因此每次对本次进行的两种操作方案进行比较。</p><p>按以下操作递归处理 $n$ ：</p><ol><li>如果 $n=1$ ，则返回 $0$ ；</li><li>进行若干次（可能0次）操作 $3$ 使得 $n$ 能被 $2$ 整除，执行操作 $2$</li><li>进行若干次（可能0次）操作 $3$ 使得 $n$ 能被 $3$ 整除，执行操作 $1$</li></ol><p>由于数据范围的关系，传统的DFS会超时，因此需要使用记忆化搜索<br>即每次计算完某个数（记为 $x$ ）的结果，将其保存下来，后续搜索 $x$ 时就无需继续搜索到底部，直接输出这个数的结果即可<br>记忆化搜索可以用 map 实现，频繁读取而不考虑元素顺序的可以使用 unordered_map ，有效降低时间空间复杂度</p><p><img src="/images/ACM/2023Summer_HDU09_1002.png" alt="Img"></p><p>第2、3行的提交使用了 map ，代码完全一致；第1行的提交仅仅将 map 改为了 unordered_map</p><h3 id="时间复杂度">时间复杂度</h3><p>$O(t\log^2n)$</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;ll,ll&gt; mp;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>-n;</span><br><span class="line">    <span class="keyword">if</span>(mp[n]) <span class="keyword">return</span> mp[n];</span><br><span class="line">    ll t1,t2;</span><br><span class="line">    t1=n%<span class="number">2</span>+<span class="number">1</span>+<span class="built_in">dfs</span>(n/<span class="number">2</span>);</span><br><span class="line">    t2=n%<span class="number">3</span>+<span class="number">1</span>+<span class="built_in">dfs</span>(n/<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> mp[n]=<span class="built_in">min</span>(t1,t2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(n) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1005.List Reshape</h1><p><strong>签到题、模拟</strong></p><h2 id="题意-2">题意</h2><p>按一定格式给定一个纯数字一维数组，按给定格式输出成二维数组。</p><h2 id="解题思路-2">解题思路</h2><p>读入初始数组字符串，将每个数字分离，按要求输出即可</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="type">char</span> s[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">vector&lt;string&gt; nums;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getnums</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string ts;ll len=<span class="built_in">strlen</span>(s);<span class="type">char</span> c;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,len)&#123;</span><br><span class="line">        c=s[i];</span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) ts.<span class="built_in">push_back</span>(c);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ts.<span class="built_in">size</span>())&#123;</span><br><span class="line">            nums.<span class="built_in">emplace_back</span>(ts);</span><br><span class="line">            ts.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">getchar</span>();<span class="built_in">gets</span>(s);</span><br><span class="line">    ll n,m;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    nums.<span class="built_in">clear</span>();<span class="built_in">getnums</span>();</span><br><span class="line">    <span class="comment">//print_vec(nums);</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">            cout &lt;&lt; nums[i*m+j];</span><br><span class="line">            <span class="keyword">if</span>(m<span class="number">-1</span>-j) cout &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        &#125;cout &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(n<span class="number">-1</span>-i) cout &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;cout &lt;&lt; <span class="string">&#x27;]&#x27;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1008.Coins</h1><p><strong>概率论</strong></p><h2 id="题意-3">题意</h2><p>$n$ 个人进行游戏，每个人初始有 $a_i$ 个硬币，每次随机选择一个人给另一个人一枚硬币<br>若某人给出硬币后没有剩余，则退出游戏。直到有人拿到所有硬币游戏结束<br>求游戏轮数的数学期望</p><h2 id="解题思路-3">解题思路</h2><p>概率论还没学（）官方题解的鞅论看不懂（躺）//<br>等学完回来给严格推导（手搓大饼ing）<br>ACMer三大美德：暴力、打表、猜结论//下面给出道德解法（）</p><p>假设现在只有两个人，那么每个人给对方硬币的概率都为50%，直到其中一人没有硬币为止。<br>设这两个人的硬币数分别为 $m,n$ ，则游戏轮数期望为：<br>$f(m,n)=1+\dfrac{1}{2}f(m+1,n-1)+\dfrac{1}{2}f(m-1,n+1)$</p><p>可以发现越往后对期望的贡献越低，限制递归深度，利用如下程序暴力打表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(ll m,ll n,ll rnd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rnd&gt;<span class="number">40</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//递归上限40层（已经要跑很久了）</span></span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>||n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+<span class="number">0.5</span>*<span class="built_in">f</span>(m+<span class="number">1</span>,n<span class="number">-1</span>,rnd+<span class="number">1</span>)+<span class="number">0.5</span>*<span class="built_in">f</span>(m<span class="number">-1</span>,n+<span class="number">1</span>,rnd+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(m,n,<span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到以下打表结果（不得不说跑的是真慢）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">in</span>:<span class="number">1</span> <span class="number">3</span> out:<span class="number">3</span></span><br><span class="line"><span class="attribute">in</span>:<span class="number">1</span> <span class="number">5</span> out:<span class="number">4</span>.<span class="number">98732</span></span><br><span class="line"><span class="attribute">in</span>:<span class="number">2</span> <span class="number">3</span> out:<span class="number">5</span>.<span class="number">99897</span></span><br><span class="line"><span class="attribute">in</span>:<span class="number">2</span> <span class="number">5</span> out:<span class="number">9</span>.<span class="number">8626</span></span><br><span class="line"><span class="attribute">in</span>:<span class="number">3</span> <span class="number">4</span> out:<span class="number">11</span>.<span class="number">8287</span></span><br></pre></td></tr></table></figure><p>暴力打完表可以猜结论了： $f(m,n)=mn$ ，即对于两个人，答案是他们硬币数的乘积；<br>那么对于三个人，利用样例<code>in:1 1 1 out:3</code>盲猜是 $a_1a_2+a_1a_3+a_2a_3$<br>推广到 $n$ 个人，两两相乘再相加即可</p><p>由于数据较大，答案需要开int128才能放得下<br>另外结合数据范围，利用前缀和算出结果即可</p><h3 id="时间复杂度-2">时间复杂度</h3><p>前缀和&amp;求和：$O(n)$</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int128 res;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(n+<span class="number">1</span>)</span>,<span class="title">sum</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; v[i];</span><br><span class="line">        sum[i]=v[i]+sum[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,n,<span class="number">1</span>)&#123;</span><br><span class="line">        res=res+sum[i<span class="number">-1</span>]*v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="built_in">print</span>();<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期牛客多校09</title>
      <link href="/posts/ACM_2023Summer_NCD09.html"/>
      <url>/posts/ACM_2023Summer_NCD09.html</url>
      
        <content type="html"><![CDATA[<h1>E.Puzzle: Square Jam</h1><p><strong>几何</strong></p><h2 id="题意">题意</h2><p>给定一个 $n$ 行 $m$ 列的矩形，将其切割为若干个边长为正整数的正方形部分<br>要求矩形内每个整点都不能同时在四个正方形的边界上</p><h2 id="解题思路">解题思路</h2><p>每次在矩形中取最大的正方形，剩余部分递归处理即可。如此取，每个点最多在三个正方形的边界上</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;pll,ll&gt;&gt; ans;</span><br><span class="line">pair&lt;pll,ll&gt; tp;<span class="comment">//&lt;坐标,边长&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve_sqr</span><span class="params">(ll x,ll y,ll n,ll m)</span></span>&#123;</span><br><span class="line">    <span class="comment">//处理坐标在(x,y)，n行m列的矩形</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||m==<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;=m)&#123;</span><br><span class="line">        tp.first.first=x;tp.first.second=y;tp.second=m;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(tp);</span><br><span class="line">        <span class="built_in">solve_sqr</span>(x+m,y,n-m,m);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        tp.first.first=x;tp.first.second=y;tp.second=n;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(tp);</span><br><span class="line">        <span class="built_in">solve_sqr</span>(x,y+n,n,m-n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ans.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">solve_sqr</span>(<span class="number">0</span>,<span class="number">0</span>,n,m);</span><br><span class="line">    cout &lt;&lt; YES ;</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:ans)&#123;</span><br><span class="line">        cout &lt;&lt; x.first.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x.first.second &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期牛客多校08</title>
      <link href="/posts/ACM_2023Summer_NCD08.html"/>
      <url>/posts/ACM_2023Summer_NCD08.html</url>
      
        <content type="html"><![CDATA[<h1>A.Alive Fossils</h1><p><strong>签到</strong></p><h2 id="题意">题意</h2><p>给定 $n$ 个字符串集，求它们的交集，按字典序输出</p><h2 id="解题思路">解题思路</h2><p>逐一处理字符串集，开个 map 记录此前的交集，从当前集合中选走元素即可</p><h3 id="时间复杂度">时间复杂度</h3><p>$O(n)$</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;ll tn;cin &gt;&gt; tn;</span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt; mp;string ts;</span><br><span class="line">    vector&lt;string&gt; v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,tn)&#123;</span><br><span class="line">        cin &gt;&gt; ts;</span><br><span class="line">        mp[ts]++;</span><br><span class="line">        v.<span class="built_in">emplace_back</span>(ts);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        v.<span class="built_in">clear</span>();</span><br><span class="line">        cin &gt;&gt; tn;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,tn)&#123;</span><br><span class="line">            cin &gt;&gt; ts;</span><br><span class="line">            <span class="keyword">if</span>(mp[ts]) v.<span class="built_in">emplace_back</span>(ts);</span><br><span class="line">        &#125;</span><br><span class="line">        mp.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s:v) mp[s]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> s:v) cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>J.Permutation and Primes</h1><p><strong>构造</strong></p><h2 id="题意-2">题意</h2><p>给定一个正整数 $n$ ，构造一个 $n$ 的排列，使得每对相邻元素的和或差的绝对值为一奇素数</p><h2 id="解题思路-2">解题思路</h2><p>两个数的和或差是奇数，那么它们的奇偶性一定是不同的，因此所求排列中，奇数和偶数是交错分布的</p><p>对于排列的构造，首先考虑能不能通过自然排列转化而成//</p><p>赛时首先想到奇偶分开后，将全体偶数向左或向右循环移动 $2$ ~ $3$ 位，这样可以保证绝大部分位置和左右两边之差为 $3$ 或 $5$ //当时以为要切了，结果剩余的数字考虑了两年半还是没有找到符合题意而不失一般性的构造方法</p><p>然后考虑分段调整。在上面思想的基础上，发现如果元素个数为 $8$ 个，那么全体偶数左移 $2$ 位和右移 $2$ 位的结果都为： $1,6,3,8,5,2,7,4$ 。并且如果下一段长度为 $8$ 的序列也按照这种规则变换顺序，那么 $4$ 和下一段长度为 $8$ 的序列的开头 $9$ 之差为 $5$ ，符合题意，从而解决了边界问题</p><p>将 $n$ 模 $8$ 取余，记 $n=8k+r$ 。解决前 $r$ 个数的排列后，之后每 $8$ 个数按 $1,6,3,8,5,2,7,4$ 的顺序变换即可</p><h3 id="时间复杂度-2">时间复杂度</h3><p>$O(n)$</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ll rem[<span class="number">8</span>][<span class="number">8</span>]=&#123;&#123;&#125;,&#123;<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>&#125;,&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>&#125;,&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">ll pl[<span class="number">9</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    ll r=n%<span class="number">8</span>,d=n/<span class="number">8</span>;</span><br><span class="line">    vector&lt;ll&gt; v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,r<span class="number">-1</span>) v.<span class="built_in">emplace_back</span>(rem[r][i]);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,d<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,<span class="number">8</span>)&#123;</span><br><span class="line">            v.<span class="built_in">emplace_back</span>(<span class="number">8</span>*i+pl[j]+r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cout &lt;&lt; v[i] &lt;&lt; <span class="built_in">Presentation</span>(i,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期杭电多校08</title>
      <link href="/posts/ACM_2023Summer_HDU08.html"/>
      <url>/posts/ACM_2023Summer_HDU08.html</url>
      
        <content type="html"><![CDATA[<h1>1005.0 vs 1</h1><p><strong>博弈，模拟</strong></p><h2 id="题意">题意</h2><p>两人名为零和壹，在给定的 $01$ 串上进行博弈<br>零只能取走两端的某一个 $0$ ，壹只能取走两端的某一个 $1$ ，零执先<br>先不能取的人判负，若取完则判平局</p><h2 id="解题思路">解题思路</h2><p>模拟博弈过程，当前操作者 $x$ 可以可以遵循以下策略：</p><ol><li>两端不同，只能取 $x$ 的一端，交替操作权</li><li>两端相同<ol><li>两端都不是 $x$ ，无法操作，失败</li><li>两端都是 $x$ ，假设取了某端<ol><li>这端的下一个数字是 $x$ ，则两端都是 $x$ ，对方无法操作，获胜</li><li>这端的下一个数字是 $!x$ ，则对方只能取这一端</li></ol></li><li>如果离任一端最近的连续两个相同的数都为 $x$ ，则根据上 $2$ 一直取到 $x$ 获胜</li><li>如果离两端最近的连续两个相同的数都为 $!x$ ，则不论选哪端，最终都会到达两端都为 $!x$ 的情况，失败<ol><li>特判：如果整个串有且仅有 $1$ 段连续两个相同的 $!x$ ，则从两端向中间将各会取掉一个，达成平局</li></ol></li></ol></li></ol><p>可以结合代码注释理解这一过程</p><h3 id="时间复杂度">时间复杂度</h3><p>$O(n)$</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve_s</span><span class="params">(deque&lt;<span class="type">int</span>&gt; s,<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">    ll n=s.<span class="built_in">size</span>(),i,j;;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">empty</span>()) &#123;cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//取完平局</span></span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">front</span>()!=s.<span class="built_in">back</span>())&#123;<span class="comment">//前后不同，无法自由选择，交替操作权</span></span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">front</span>()==now)&#123;<span class="comment">//取前</span></span><br><span class="line">            s.<span class="built_in">pop_front</span>();<span class="built_in">solve_s</span>(s,(now?<span class="number">0</span>:<span class="number">1</span>));<span class="keyword">return</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//取后</span></span><br><span class="line">            s.<span class="built_in">pop_back</span>(); <span class="built_in">solve_s</span>(s,(now?<span class="number">0</span>:<span class="number">1</span>));<span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//前后相同</span></span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">front</span>()!=now) &#123;cout &lt;&lt; (now?<span class="string">&quot;0&quot;</span>:<span class="string">&quot;1&quot;</span>) &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//两端不可取，失败</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++) <span class="keyword">if</span>(s[i]==s[i+<span class="number">1</span>]) <span class="keyword">break</span>;<span class="comment">//从前往后找第一个连续</span></span><br><span class="line">        <span class="keyword">if</span>(i==n<span class="number">-1</span>) &#123;cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//无连续，取完平局</span></span><br><span class="line">        <span class="keyword">if</span>(s[i]==now) &#123;cout &lt;&lt; (now?<span class="string">&quot;1&quot;</span>:<span class="string">&quot;0&quot;</span>) &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//有己方连续，胜利</span></span><br><span class="line">        <span class="keyword">for</span>(j=n<span class="number">-1</span>;j&gt;i;j--) <span class="keyword">if</span>(s[j]==s[j<span class="number">-1</span>]) <span class="keyword">break</span>;<span class="comment">//从后往前找最后一个连续</span></span><br><span class="line">        <span class="keyword">if</span>(s[j]==now) &#123;cout &lt;&lt; (now?<span class="string">&quot;1&quot;</span>:<span class="string">&quot;0&quot;</span>) &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//有己方连续，胜利</span></span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>==j) &#123;cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//有且仅有一对对方连续，取完平局</span></span><br><span class="line">        &#123;cout &lt;&lt; (now?<span class="string">&quot;0&quot;</span>:<span class="string">&quot;1&quot;</span>) &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//两对以上对方连续，失去主动权，判负</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    string ts;cin &gt;&gt; ts;</span><br><span class="line">    <span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n)</span></span>;<span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) s[i]=ts[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="built_in">solve_s</span>(s,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1007.Solubility</h1><p><strong>并查集/DFS</strong></p><h2 id="题意-2">题意</h2><p>给定 $n$ 个元素之间的 $m$ 对等价关系，问指定 $k$ 个元素是否属于同一等价类</p><h2 id="解题思路-2">解题思路</h2><p>这里给出两种解题思路：</p><ol><li>DFS：建无向图，DFS判断指定元素是否在同一个连通分量里</li><li>并查集：标准并查集板子题，裸套即可</li></ol><h2 id="参考代码-2">参考代码</h2><ol><li>DFS</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="type">int</span> visited[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">vector&lt;vector&lt;ll&gt;&gt; G;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    visited[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:G[x])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[v]) <span class="built_in">DFS</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    G.<span class="built_in">clear</span>();G.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) visited[i]=<span class="number">0</span>;</span><br><span class="line">    ll u,v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">        G[v].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    ll k;cin &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">s</span><span class="params">(k)</span></span>;<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:s) cin &gt;&gt; x;</span><br><span class="line">    <span class="built_in">DFS</span>(s[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:s) <span class="keyword">if</span>(!visited[x]) &#123;cout &lt;&lt; NO;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    cout &lt;&lt; YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>并查集</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">DSU <span class="title">dsu</span><span class="params">(n)</span></span>;</span><br><span class="line">    ll a,b;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        dsu.<span class="built_in">merge</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    ll k;cin &gt;&gt; k &gt;&gt; a;a=dsu.<span class="built_in">find</span>(a);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,k)&#123;</span><br><span class="line">        cin &gt;&gt; b;b=dsu.<span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(b!=a) &#123;cout &lt;&lt; NO;<span class="built_in">FORLL</span>(j,i+<span class="number">1</span>,k) cin &gt;&gt; n;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    &#125;cout &lt;&lt; YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1008.Expectation of Rank</h1><p><strong>线性代数-矩阵与向量空间、期望、动态规划</strong></p><h2 id="题意-3">题意</h2><p>给定两个正整数 $n,p$ ，其中 $p$ 是质数<br>$n$ 阶矩阵 $\bf A$ 中的所有元素随机在 $p$ 的有限域 $\mathbb{F}_p$ 中产生，求矩阵 $\bf A$ 的秩的期望 $\mathbb{E}(rank(\bf A))$ ，答案取模</p><h3 id="前置知识点">前置知识点</h3><ol><li><a href="https://baike.baidu.com/item/%E6%9C%89%E9%99%90%E5%9F%9F/4273049">有限域</a> $\mathbb{F}_p$ ：在本题中可以粗略的理解为 $[0,p-1]$ 的整数集</li><li>线性代数-矩阵与向量空间基础知识：多维向量与向量组、线性相关、矩阵的秩与向量之间的关系、向量组张成向量空间的概念等</li></ol><p>建议在学习过《线性代数》课程后再解决本题。</p><h2 id="解题思路-3">解题思路</h2><p>一个含 $k$ 个向量的极大无关组可以张成一个 $k$ 维向量空间</p><p>在 $p$ 的有限域 $\mathbb{F}_p$ 下，每一维度上的坐标有 $p$ 种选择，故以该极大无关组为基，通过线性组合可以产生 $p^k$ 种不同的 $k$ 维向量（高维包含低维）<br>顺带一提，这并不意味着这 $p^k$ 种向量仅有 $k$ 位坐标非 $0$</p><p>矩阵 $\bf A$ 的每一行可以视为一个 $n$ 维向量，前 $i$ 行的秩表示了前 $i$ 个向量组成的向量组，其极大无关组中有多少个向量。这也意味着前 $i$ 行已经张成了一个多少维度的向量空间</p><p>构造DP数组， $dp_{i,k}$ 用以表示矩阵 $\bf A$ 前 $i$ 行的秩为 $k$ 的方案数</p><p>假设前 $i-1$ 行的秩为 $k$ ，那么其张成的向量空间为 $k$ 维，考虑状态转移：</p><ol><li>第 $i$ 行中可以构造出 $p^k$ 个向量落在这个向量空间中，并不改变秩（或者说维数）</li><li>余下 $p^n-p^k$ 个向量将与前 $i-1$ 个向量线性无关，并使张成的空间增大一维，秩 $+1$</li></ol><p>综上所述，构造出以下状态转移方程：<br>$$dp_{i,k}=<br>\begin{cases}<br>0 \qquad,k&gt;i\quad(rank_i\le i恒成立) \newline<br>1 \qquad,k=0\quad(当且仅当全为 \bf{0} \text{向量}) \newline<br>\sum\limits_{j=1}^{i-1} dp_{i-1,j}\times p^j + dp_{i-1,j-1}\times (p^n-p^j) &amp;,Otherwise<br>\end{cases}<br>$$</p><p>总方案数为 $(p^n)^n=p^{n^2}$ ，最终期望为 $\dfrac{1}{p^{n^2}}\sum\limits_{j=1}^{n} j\times dp_{n,j}$</p><h3 id="时间复杂度-2">时间复杂度</h3><p>DP：$O(n^2)$</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5005</span></span><br><span class="line">ll n,p;</span><br><span class="line">ll dp[N][N],powp[N];<span class="comment">//dp_i,k表示矩阵前i行秩为k的方案数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n)</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,n)</span><br><span class="line">            dp[i][j]=<span class="number">0</span>;</span><br><span class="line">    powp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) powp[i]=<span class="built_in">mul</span>(powp[i<span class="number">-1</span>],p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">    <span class="built_in">Init</span>(n);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(k,<span class="number">1</span>,i)&#123;<span class="comment">//每行看作一个向量，有p^n种构造法。确定前i行的秩为k的总向量方案数</span></span><br><span class="line">            <span class="built_in">addto</span>(dp[i][k],<span class="built_in">mul</span>(dp[i<span class="number">-1</span>][k],powp[k]));</span><br><span class="line">            <span class="comment">//对于前i-1行秩为k的某方案，其向量空间为k维，故在p的有限集下有且仅有p^k个向量落在该向量空间</span></span><br><span class="line">            <span class="built_in">addto</span>(dp[i][k],<span class="built_in">mul</span>(dp[i<span class="number">-1</span>][k<span class="number">-1</span>],<span class="built_in">sub</span>(powp[n],powp[k<span class="number">-1</span>])));</span><br><span class="line">            <span class="comment">//对于前i-1行秩为k-1的某方案，有p^(k-1)个向量落在其张成的向量空间，剩余向量与前i-1行线性无关</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll re=<span class="number">0</span>,ninv=<span class="built_in">inv</span>(<span class="built_in">qcpow</span>(powp[n],n));<span class="comment">//ninv:总方案数(p^n)^n的倒数</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="built_in">addto</span>(re,<span class="built_in">mul</span>(<span class="built_in">mul</span>(i,dp[n][i]),ninv));</span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1010.Rikka with Square Numbers</h1><p><strong>数学、贪心</strong></p><h2 id="题意-4">题意</h2><p>给定两个正整数 $a,b$ ，每次操作可以使 $a$ 增大或减小一个平方数 $x$ ，求把 $a$ 变成 $b$ 的最小操作次数</p><h2 id="解题思路-4">解题思路</h2><p>即求 $a,b$ 之差最少可以用多少个平方数的和差表示。以下是一些思路：</p><ol><li>$a=b$ ， $0$</li><li>$n^2$ ，平方数本身， $1$</li><li>$n^2-(n-1)^2=2n-1$ ，用两个相邻平方数之差即可表示任意奇数</li><li>$n^2-(n-2)^2=4(n-1)$ ，用两个距离为 $2$ 的平方数之差可以表示任意 $4$ 的倍数</li><li>结合以上两条可以归纳证明两个平方数之差一定为奇数或 $4$ 的倍数，$2$</li><li>模 $4$ 余 $2$ 的情况可能为两平方数加和，可以枚举判断， $2$</li><li>其余的数可以用第 $3$ 点得到任意奇数后加减 $1$ ， $3$</li></ol><p>综上判定即可</p><h3 id="时间复杂度-3">时间复杂度</h3><p>$O(\sqrt n)$</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Is_Sqr</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    ll t=<span class="built_in">sqrt</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(t*t==x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a,b;cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b) <span class="built_in">swap</span>(a,b); ll dif=a-b;</span><br><span class="line">    <span class="keyword">if</span>(a==b) &#123;cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Is_Sqr</span>(dif)) &#123;cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">if</span>(dif%<span class="number">2</span>||(dif%<span class="number">4</span>==<span class="number">0</span>)) &#123;cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i*i&lt;=dif;i++) <span class="keyword">if</span>(<span class="built_in">Is_Sqr</span>(dif-i*i)) &#123;cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    cout &lt;&lt; <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期杭电多校07</title>
      <link href="/posts/ACM_2023Summer_HDU07.html"/>
      <url>/posts/ACM_2023Summer_HDU07.html</url>
      
        <content type="html"><![CDATA[<h1>1002.Random Nim Game</h1><p><strong>诈骗博弈题</strong></p><h2 id="题意">题意</h2><p>Nim是一种双人数学策略游戏，玩家轮流从不同的堆中移除棋子。在每一轮游戏中，玩家必须至少取出一个棋子，并且可以取出任意数量的棋子，条件是这些棋子都来自同一个棋子堆。走最后一步棋（即取出最后一块棋子）的人获胜。</p><p>现在更改游戏规则，在每个回合中，棋手必须选择一个棋子堆。假设他选择的堆包含 $x$ 个棋子，将从 $[1,x]$ 中随机一个整数 $y$ ，并从堆中移除 $y$ 个棋子</p><p>求先手获胜的概率，答案取模</p><h2 id="解题思路">解题思路</h2><p>看起来很吓人的一道题（谁被吓退了我不说）//</p><p>考虑只有一个堆的情况<br>若只有 $1$ 个棋子，先手必胜<br>如果有 $2$ 个棋子，有 $\dfrac{1}{2}$ 的概率拿完获胜，有 $\dfrac{1}{2}$ 的概率余 $1$ 失败，综合胜率 $\dfrac{1}{2}$<br>$\vdots$<br>如果有 $x\ (x&gt;1)$ 个棋子，有 $\dfrac{n-2}{n}$ 的概率转移到 剩余个数 $&gt;1$ 的状态，有 $\dfrac{1}{n}$ 的概率拿完获胜，有 $\dfrac{1}{n}$ 的概率余 $1$ 失败。递归得到 $x&gt;1$ 的状态下的综合胜率为 $\dfrac{1}{2}$</p><p>再考虑多堆的情况<br>如果所有堆的棋子数量均为 $1$ ，则当堆数 $n$ 为奇数时先手必胜<br>如果有某堆的数量多于 $1$ 个，那么必胜态将以 $\dfrac{1}{2}$ 的概率流转</p><p>综上所述，如果所有堆的棋子数量均为 $1$ ，则当堆数 $n$ 为奇数时先手必胜， $n$ 为偶数时先手必败，其余情况综合胜率 $\dfrac{1}{2}$</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;ll mx=<span class="number">0</span>,t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        mx=<span class="built_in">max</span>(mx,t);</span><br><span class="line">    &#125;<span class="keyword">if</span>(mx&gt;<span class="number">1</span>) cout &lt;&lt; <span class="built_in">inv</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n%<span class="number">2</span>) cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1004.Medians Strike Back</h1><p><strong>构造</strong></p><h2 id="题意-2">题意</h2><p>定义长度为 $n$ 的整数序列的中位数：</p><ol><li>如果 $n$ 为奇数，则中位数是将序列排序后正中间的数</li><li>如果 $n$ 为偶数，则中位数是将序列排序后中间两个数中，出现次数较多的那个数，如果出现次数相同则取较小的那个数</li></ol><p>定义序列的 $shikness$ ：该序列中位数出现的次数<br>定义序列的 $nitness$ ：该序列的所有连续子串的 $shikness$ 的最大值</p><p>给定一个正整数 $n$ ，构造长度为 $n$ 且仅含元素 $1,2,3$ 的序列，并使 $nitness$ 最小化，求出最小值</p><h2 id="解题思路-2">解题思路</h2><p>构造找规律<br>$nitness_{min}=1$ 时，构造出最长序列为： $123$<br>$nitness_{min}=2$ 时，构造出最长序列为： $1313221313$<br>$nitness_{min}=3$ 时，构造出最长序列为： $131313222131313$<br>$nitness_{min}=4$ 时，构造出最长序列为： $1313131322131313132213131313$</p><p>如果序列中存在两个及以上的 $2$ ，那么 $2$ 是稳定作为中位数的，因此可以考虑以下构造方法：<br>连续 $n$ 对 $13$ 为一个单位子串//每个单位子串利用两个或三个连续的 $2$ 隔开，将得到以下格式的序列：$1313(n对)\cdots22\ 1313(n对)\cdots22\ 1313(n对)$</p><p>下面阐释这种构造方法的合法性</p><ol><li>对于整个序列， $nitness=cnt_2=n$</li><li>对于含多个 $2$ 的子串， $2$ 稳定做中位数， $nitness&lt;cnt_2=n$</li><li>对于仅含一个 $2$ 的子串，这个 $2$ 一定在单位子串的左边或右边，而单位子串的长度为 $2n$ ，因此加上 $2$ 后的长度为奇数，$2$ 稳定做中位数，$nitness=1$</li><li>对于不含 $2$ 的子串，其一定也是单位子串的子串，而单位子串中 $cnt_1=cnt3=n$ ，因此 $nitness\le n$</li></ol><p>计数得到最长长度的通项公式： $len_i=2i(\lfloor \dfrac{i}{2} \rfloor+1)+i$</p><p>初始化长度数组，二分查找即可</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 500000</span></span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(N)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(v),n)-v.<span class="built_in">begin</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*----------Initialize----------*/</span></span><br><span class="line">    v[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,N)&#123;</span><br><span class="line">        v[i]=(i/<span class="number">2</span>+<span class="number">1</span>)*<span class="number">2</span>*i+i;</span><br><span class="line">        <span class="keyword">if</span>(v[i]&gt;<span class="number">1e11</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;v.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line"><span class="comment">/*----------Initialize----------*/</span></span><br></pre></td></tr></table></figure><hr><h1>1011.Three Operations</h1><p><strong>签到题</strong></p><h2 id="题意-3">题意</h2><p>给定正整数 $x,a,b$ 可以进行以下操作：</p><ol><li>$x\leftarrow x-1$</li><li>$x\leftarrow \lfloor \dfrac{x+a}{2} \rfloor$</li><li>$x\leftarrow \lfloor \sqrt{x+b} \rfloor$</li></ol><p>求使得 $x$ 变为 $0$ 的最少操作次数</p><h2 id="解题思路-3">解题思路</h2><p>每次比较三种操作后的 $x$ 最小即可</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,a,b,t,re=<span class="number">0</span>;cin &gt;&gt; x &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        t=<span class="built_in">min</span>((x+a)/<span class="number">2</span>,(ll)<span class="built_in">sqrt</span>(x+b));</span><br><span class="line">        <span class="keyword">if</span>(t&lt;x<span class="number">-1</span>) &#123;re++;x=t;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;re+=x;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1013.Minimal and Maximal XOR Sum</h1><p><strong>归并排序、贪心</strong></p><h2 id="题意-4">题意</h2><p>给定一个长度为 $n$ 的排列 $p$ ，每次操作可以选定一段连续子序列 $p_{i,j}$ ，花费等同于元素个数的代价 $c=j-i+1$ ，使得这一段顺序反转<br>记使得排序变成自然排序（ $p_i=i$ ）所经过的一系列操作中，每一次的代价的异或和为 $x=c_1 \oplus c_2 \oplus \cdots \oplus c_i$<br>求 $x$ 的最大值和最小值</p><h2 id="解题思路-4">解题思路</h2><p>排列的奇偶性定义为其所具有的逆序对数的奇偶性。任意一个n阶排列，可经过一系列对换转变为标准排列，且所做对换的次数与排列具有相同的奇偶性。</p><p>观察操作的特点可以得出，选定单一元素操作时，排列本身不发生改变，但产生 $1$ 点代价//这意味着所得结果 $x$ 的最后一个二进制位可以任意调整（和 $1$ 做异或）</p><p>考虑使得 $x$ 最小的操作方法<br>每次花费 $2$ 代价做对换，最小值 $x_{min}$ 一定会落在 $0$ 或 $2$ 上。根据对换次数与排列奇偶性的关系，判断排列逆序对数的奇偶性即可，可以使用归并排序进行逆序对计数</p><p>接下来考虑使得 $x$ 最大的操作方法<br>在排列 $p$ 已经有序的情况下，考虑如何操作花费代价可以使得异或和 $x$ 产生高位 $1$ ：先花费高代价 $c$ 反转某个长子序列，再连续花费 $2$ 代价做对换将序列恢复为有序</p><p>可以发现 $x$ 的最大可能二进制位数与 $n$ 相同，逐位考虑转 $1$ 记某位上的权重为 $2^m &lt;n$ ，则反转 $2^m$ 个数后，恢复有序需要连续做对换的次数为 $2^m(2^m-1)/2$ ， $m\ge 2$ 时对换次数为偶数，即对最终的异或和 $x$ 无影响，这意味着按照上述策略可以将 $x$ 倒数第3位（权重为4）及以前的数位全部置1//</p><p>$m=1$ 时对换次数为 $1$ ，和反转 $2^1$ 个数的代价 $2$ 抵消，因此无法变更倒数第二位的值</p><p>综上所述，只需将 $x$ 调整为与 $n$ 具有相同二进制数的最大值，再判断倒数第二位即可//</p><h3 id="时间复杂度">时间复杂度</h3><p>归并排序： $O(n\log n)$</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;ll mn,mx;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:v) cin &gt;&gt; x;</span><br><span class="line">    ll cntinv=<span class="built_in">mergeSortAndCount</span>(v,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(cntinv%<span class="number">2</span>) mn=<span class="number">2</span>;<span class="keyword">else</span> mn=<span class="number">0</span>;</span><br><span class="line">    ll t=n,dig=<span class="number">0</span>;<span class="keyword">while</span>(t) &#123;dig++;t/=<span class="number">2</span>;&#125;</span><br><span class="line">    mx=(<span class="number">1</span>&lt;&lt;dig)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mn==<span class="number">0</span>) mx-=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;0 1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; mn &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; mx &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期牛客多校07</title>
      <link href="/posts/ACM_2023Summer_NCD07.html"/>
      <url>/posts/ACM_2023Summer_NCD07.html</url>
      
        <content type="html"><![CDATA[<h1>M.Writing Books</h1><p><strong>签到</strong></p><h2 id="题意">题意</h2><p>给定一个正整数 $n$ ，求 $1$ ~ $n$ 共有多少位数字</p><h2 id="解题思路">解题思路</h2><p>$1$ ~ $9$ 共 $9\times 10^0 \times 1$ 位；<br>$10$ ~ $99$ 共 $9\times 10^1 \times 2$ 位；<br>以此类推，求和即可</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ll a=<span class="number">1</span>,x=<span class="number">9</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;=x) &#123;n-=x;cnt+=a*x;x*=<span class="number">10</span>;a++;&#125;</span><br><span class="line">    cnt+=a*n;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期牛客多校06</title>
      <link href="/posts/ACM_2023Summer_NCD06.html"/>
      <url>/posts/ACM_2023Summer_NCD06.html</url>
      
        <content type="html"><![CDATA[<h1>A.Tree</h1><p><strong>图论-Kruskal、动态规划</strong></p><h2 id="题意">题意</h2><p>给定一棵 $n$ 个节点带点权和边权的无根树</p><p>节点具有颜色白（$0$）和黑（$1$），颜色可反转，所需代价 $cost_i$ 为该点点权</p><p>整棵树的 $earning$ 为 $\sum\limits_{u\in V_0}\sum\limits_{v\in V_1} val(u,v)$ 。其中， $val(u,v)$ 为节点 $u\rightarrow v$的最短路径上的最大边权， $V_0$ 为白色点集， $V_2$ 为黑色点集</p><p>可以操作反转节点颜色任意次，求最大 $earning-\sum cost$ （以下简称 $score$ ）</p><h2 id="解题思路">解题思路</h2><p>注意到对于每对黑白点对，其贡献为最短路径上的最大边权。考虑利用Kruskal算法对树进行重构，即按边权从小到大的顺序进行加边</p><p>可以发现，在加入某条边 $e_i$ 时，原本在同一连通分量中的黑白点对的 $score$ 不受影响。由于加边顺序，新加的边一定具有目前最大的边权，因此只有经过新加的这条边的点对才对 $score$ 具有贡献，每个点对的贡献值为 $w_i$ ，点对数量为：$左白\times右黑+左黑\times右白$</p><p>构造dp数组：定义 $dp_{i,j}$ 为连通分量 $i$ （以并查集中连通分量的根节点标识）中具有 $j$ 个白色节点时的最大 $score$ 。初始对于点 $i$ ，$dp_{i,color_i}=0$ （不变）；$dp_{i,color_i\oplus 1}=-cost_i$ （反转）</p><p>在合并 $A、B$ 两个连通分量到 $C$ 时具有以下转移方程：<br>$$<br>dp_{C,i}=\max\limits_{0\le k \le |A| \And 0\le i-k\le |B|}{dp_{A,k}+dp_{B,i-k}+w(k(|B|-(i-k))+(i-k)(|A|-k))}<br>$$<br>（两边原有的 $score$ 加上过新加边的 $score$ ）</p><p>可以结合代码注释进行理解</p><h3 id="时间复杂度">时间复杂度</h3><p>$O(n^2\log n)$</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v;ll w;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">edge</span>():<span class="built_in">u</span>(<span class="number">0</span>),<span class="built_in">v</span>(<span class="number">0</span>),<span class="built_in">w</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="type">int</span> _u,<span class="type">int</span> _v,ll _w): <span class="built_in">u</span>(_u),<span class="built_in">v</span>(_v),<span class="built_in">w</span>(_w) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> edge &amp;b)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="comment">//手写edge类，自定义比较方式</span></span><br><span class="line"><span class="comment">//下面的注释中也添加了不用手写的代码，优点是少写一段代码，缺点是表述较为冗杂不直观</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 3005</span></span><br><span class="line"><span class="type">int</span> dsu[N]=&#123;<span class="number">0</span>&#125;,sz[N]=&#123;<span class="number">0</span>&#125;,color[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">vector&lt;ll&gt; dp[N];<span class="comment">//dp_i,j:集合i有j个白色点时的score</span></span><br><span class="line">vector&lt;edge&gt; Edge;</span><br><span class="line"><span class="comment">//vector&lt;pair&lt;ll,pll&gt;&gt; Edge;//&lt;w,&lt;u,v&gt;&gt;;</span></span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">cost</span><span class="params">(N)</span></span>;</span><br><span class="line"><span class="function">ll <span class="title">find_dsu</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dsu[x]==x?x:dsu[x]=<span class="built_in">find_dsu</span>(dsu[x]);</span><br><span class="line">&#125;<span class="comment">//并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_dsu</span><span class="params">(ll a,ll b,ll w)</span></span>&#123;</span><br><span class="line">    a=<span class="built_in">find_dsu</span>(a);b=<span class="built_in">find_dsu</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(sz[a]&gt;sz[b]) <span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="keyword">if</span>(a==b) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    ll n=sz[a]+sz[b],rt;</span><br><span class="line">    <span class="comment">//n:a,b点集体积之和，即白点数量上限</span></span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">tmp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">        rt=-INF;</span><br><span class="line">        <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;=sz[a];k++) <span class="keyword">if</span>(k&lt;=i&amp;&amp;i-k&lt;=sz[b])&#123;<span class="comment">//k:a中白点数量</span></span><br><span class="line">            ll cnt0=i-k,cnt1=sz[b]-(i-k);<span class="comment">//cnt0:b中白点数量 cnt1:b中黑点数量</span></span><br><span class="line">            rt=<span class="built_in">max</span>(rt,dp[a][k]+dp[b][i-k]+w*(k*cnt1+cnt0*(sz[a]-k)));</span><br><span class="line">            <span class="comment">//dp=max(两点集已经具有的最大earning-cost+经过这条边的点对数*边权)</span></span><br><span class="line">        &#125;</span><br><span class="line">        tmp[i]=rt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dp[b]=tmp;</span><br><span class="line"></span><br><span class="line">    sz[b]+=sz[a];</span><br><span class="line">    dsu[a]=b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    Edge.<span class="built_in">resize</span>(n<span class="number">-1</span>);</span><br><span class="line">    ll u,v,w;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        dp[i].<span class="built_in">resize</span>(<span class="number">2</span>);<span class="comment">//接下来有需求会扩容</span></span><br><span class="line">        dsu[i]=i;sz[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; color[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; cost[i];</span><br><span class="line">        dp[i][color[i]]=(ll)<span class="number">0</span>;</span><br><span class="line">        dp[i][color[i]^<span class="number">1</span>]=(ll)-cost[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e:Edge)&#123;</span><br><span class="line">        cin &gt;&gt; e.u &gt;&gt; e.v &gt;&gt; e.w;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span></span><br><span class="line">        <span class="comment">//e.second.first=u;e.second.second=v;e.first=w;</span></span><br><span class="line">    &#125;<span class="comment">//存边</span></span><br><span class="line">    <span class="built_in">SORT</span>(Edge);<span class="comment">//按边权从小到大重构树</span></span><br><span class="line">    edge e;</span><br><span class="line">    <span class="comment">//pair&lt;ll,pll&gt; e;</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-2</span>)&#123;</span><br><span class="line">        e=Edge[i];</span><br><span class="line">        u=e.u;v=e.v;w=e.w;</span><br><span class="line">        <span class="comment">//u=e.second.first;v=e.second.second;w=e.first;</span></span><br><span class="line">        <span class="built_in">merge_dsu</span>(u,v,w);</span><br><span class="line">    &#125;<span class="keyword">auto</span> tmp=dp[<span class="built_in">find_dsu</span>(<span class="number">1</span>)];</span><br><span class="line">    cout &lt;&lt; *<span class="built_in">max_element</span>(<span class="built_in">ALL</span>(tmp)) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>B.Distance</h1><p><strong>数学、贪心(?)</strong></p><h2 id="题意-2">题意</h2><p>对于两个大小相同的多重集 $\mathbb{A},\mathbb{B}$ ，可以选择其中任一元素 $x$ 执行操作 $x=x+1$  任意次数，最少的使得 $\mathbb{A},\mathbb{B}$ 相同的操作次数记为 $C(\mathbb{A},\mathbb{B})$<br>不同大小的 $\mathbb{A},\mathbb{B}$ 视为 $C(\mathbb{A},\mathbb{B})=0$</p><p>现在，给定两个大小为 $n$ 的多重集 $\mathbb{S},\mathbb{T}$ ，求对于 $\mathbb{S},\mathbb{T}$ 的所有子集 $\mathbb{A},\mathbb{B}$ ，最少操作次数之和 $\sum\limits_{\mathbb{A} \subseteq \mathbb{S}}\sum\limits_{\mathbb{B} \subseteq \mathbb{T}} C(\mathbb{A},\mathbb{B})$ 的值<br>具有相同值的两个元素视为不同元素，答案取模</p><h2 id="解题思路-2">解题思路</h2><p>对于某对子集 $\mathbb{A},\mathbb{B}$ ，为了使他们相同的操作次数最少，我们会将他们排序的元素后一一对应，使每一对中较小的数变成较大的数//假设 $a_i$ 与 $b_i$ 对应，他们在这次变化中贡献的操作次数显然是 $|a_i-b_i|$</p><p>那么换一种角度考虑，对于原多重集 $\mathbb{S},\mathbb{T}$ ，任取一对数 $a_i,b_j$ ，考虑它们俩对应的方案数 $cnt_{i,j}$ ，那么它们在全部方案中贡献的总操作次数即为 $|a_i-b_i|\times cnt_{i,j}$</p><p>由于我们的操作策略是排序后对应，因此先对 $\mathbb{S},\mathbb{T}$ 进行排序//<br>选定两个数 $a_i,b_j$ 后，它们在 $\mathbb{S},\mathbb{T}$ 中的位置前面选 $k$ 对数的方案数为 $\sum\limits_{k=0}^{min(i-1,j-1)}C_{i-1}^kC_{j-1}^k=C_{i+j-2}^k$ （<a href="https://oi-wiki.org/math/combinatorics/vandermonde-convolution/">范德蒙德卷积</a>）</p><p>同理，它们在 $\mathbb{S},\mathbb{T}$ 中的位置后面选 $k$ 对数的方案数为 $C_{2<em>n-i-j}^k$<br>总方案数为 $cnt_{i,j}=C_{i+j-2}^kC_{2</em>n-i-j}^k$ ，乘以两数之差的绝对值即为它们对答案的总贡献//</p><p>预处理组合数，枚举 $i,j$ 求和即可</p><h3 id="时间复杂度-2">时间复杂度</h3><p>$O(n^2)$</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 2005</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span>,<span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a) cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:b) cin &gt;&gt; x;</span><br><span class="line">    ll re=<span class="number">0</span>;<span class="built_in">SORT</span>(a);<span class="built_in">SORT</span>(b);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="built_in">FORLL</span>(j,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">addto</span>(re,<span class="built_in">mul</span>(<span class="built_in">abs</span>(a[i]-b[j]),<span class="built_in">mul</span>(<span class="built_in">Get_Combination</span>(i+j,i),<span class="built_in">Get_Combination</span>((n-i<span class="number">-1</span>)+(n-j<span class="number">-1</span>),(n-i<span class="number">-1</span>)))));</span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>C.idol!!</h1><p><strong>数学</strong></p><h2 id="题意-3">题意</h2><p>正整数 $n$ 的双阶乘 $n!!$ 表示不超过 $n$ 且与 $n$ 有相同奇偶性的所有正整数乘积<br>求对于给定 $n$ ，$\prod\limits_{i=1}^n i!!$ 的后缀 $0$ 个数</p><h2 id="解题思路-3">解题思路</h2><p>根据双阶乘的性质，可以得到： $(n-1)!!\times n!!=n!$<br>因此对于给定的 $n$ ，原式可化为：<br>$$\prod\limits_{i=1}^n i!!=\begin{cases}<br>\prod\limits_{i=1}^\frac{n}{2} (2i)! &amp;,n为偶数 \newline<br>\prod\limits_{i=1}^\frac{n+1}{2} (2i-1)! &amp;,n为奇数<br>\end{cases}$$<br>显而易见的，阶乘中因子 $2$ 的个数一定多于因子 $5$ 的个数，因此题目等价于求上式中因子 $5$ 的个数//</p><p>考虑某单一阶乘 $n!$ 中所含因子 $5$ 的个数。<br>可以发现，每个 $5$ 的倍数项会提供 $1$ 个因子 $5$ ，共有 $\lfloor \dfrac{n}{5} \rfloor$ 项<br>除此之外每个 $25=5^2$ 的倍数项会额外提供一个因子 $5$ ，共有 $\lfloor \dfrac{n}{5^2} \rfloor$ 项<br>再除此之外每个 $125=5^3$ 的倍数项会额外提供一个因子 $5$ ，共有 $\lfloor \dfrac{n}{5^3} \rfloor$ 项……<br>因此对于单一阶乘 $n!$ ，其提供因子 $5$ 的数量 $cnt_5=\sum\limits_{i=1}^N \lfloor \dfrac{n}{5^i} \rfloor (5^N&gt;n)$</p><p>接着考虑连乘积中因子 $5$ 个数的总和。<br>$$<br>ans=\begin{cases}<br>\sum\limits_{i=1}^\frac{n}{2} \sum\limits_{j=1}^N \lfloor \dfrac{2i}{5^j} \rfloor=\sum\limits_{i=1}^N \sum\limits_{j=1}^\frac{n}{2} \lfloor \dfrac{2j}{5^i} \rfloor &amp;,n为偶数 \newline<br>\sum\limits_{i=1}^\frac{n+1}{2} \sum\limits_{j=1}^N \lfloor \dfrac{2i-1}{5^j} \rfloor=\sum\limits_{i=1}^N \sum\limits_{j=1}^\frac{n+1}{2} \lfloor \dfrac{2j-1}{5^i} \rfloor &amp;,n为奇数<br>\end{cases} \newline<br>$$</p><p>对于某一 $i$ ，发现不论 $n$ 的奇偶， $j=1$ 开始的每 $5^i$ 项之和构成公差为 $2\times5^i$ 的等差数列//<br>例：$i=1$ ，$n$ 为偶数且足够大时，$\lfloor \dfrac{2j}{5^i} \rfloor$ 的前 $15$ 项如下，其中每 $5$ 项之和构成公差为 $5\times 2$ 的等差数列： $0,0,1,1,2||2,2,3,3,4||4,4,5,5,6……$</p><p>经计算，对于某一 $i$ ，等差数列的首项为<br>$$<br>a_1=\begin{cases}<br>\lfloor \dfrac{5^i}{2} \rfloor+2 &amp;,n为偶数 \newline<br>\lfloor \dfrac{5^i}{2} \rfloor+1 &amp;,n为奇数<br>\end{cases}<br>$$</p><p>完整的段用等差数列求和，非完整的段手算一下//<br>​<br>若此前完整段的数量记为 $m$ ，则非完整段：<br>前 $\lfloor \dfrac{5^i}{2} \rfloor$ 项的值为 $2m$ ，<br>第 $\lfloor \dfrac{5^i}{2} \rfloor+1$ 至 $2\times\lfloor \dfrac{5^i}{2} \rfloor $ 项的值为 $2m+1$（手搓一下就知道了）</p><p>求和即可</p><p>令 $N=\lfloor \log_5n \rfloor+1$ ，对 $i\in[1,N]$ 遍历求和得到答案</p><p>由于答案数据极其庞大，超出了C++ %lld(64bits)的范围，因此需要使用更高位数的整数类型（如int128）//或者直接转战Python</p><h3 id="时间复杂度-3">时间复杂度</h3><p>$O(\log n)$</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment"># while 1:</span></span><br><span class="line">n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">N=<span class="built_in">int</span>(math.log(n,<span class="number">5</span>)+<span class="number">1</span>)</span><br><span class="line">re=<span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> n%<span class="number">2</span>==<span class="number">0</span> :</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N+<span class="number">1</span>) :</span><br><span class="line">        <span class="comment">#print(&quot;i=&quot;+str(i))</span></span><br><span class="line">        a1=(<span class="number">5</span>**i)//<span class="number">2</span>+<span class="number">2</span> <span class="comment">#首项</span></span><br><span class="line">        <span class="comment">#print(&quot;a1=&quot;+str(a1))</span></span><br><span class="line">        d=(<span class="number">5</span>**i)*<span class="number">2</span> <span class="comment">#公差</span></span><br><span class="line">        <span class="comment">#print(&quot;d=&quot;+str(d))</span></span><br><span class="line">        m=(n//<span class="number">2</span>)//(<span class="number">5</span>**i) <span class="comment">#完整段数</span></span><br><span class="line">        <span class="comment">#print(&quot;m=&quot;+str(m))</span></span><br><span class="line">        re+=(<span class="number">2</span>*a1+(m-<span class="number">1</span>)*d)*m//<span class="number">2</span> <span class="comment">#完整段等差数列求和</span></span><br><span class="line">        <span class="comment">#print(&quot;re1:&quot; + str(re))</span></span><br><span class="line">        re+=(n//<span class="number">2</span>-m*(<span class="number">5</span>**i))*<span class="number">2</span>*m <span class="comment">#最后一段余项求和</span></span><br><span class="line">        <span class="comment">#print(&quot;re2:&quot; + str(re))</span></span><br><span class="line">        <span class="comment">#print(&quot;pl1=&quot; + str((n//2-m*(5**i))*2*m))</span></span><br><span class="line">        <span class="keyword">if</span> n//<span class="number">2</span>-m*(<span class="number">5</span>**i)&gt;(<span class="number">5</span>**i)//<span class="number">2</span> :</span><br><span class="line">            re+=n//<span class="number">2</span>-m*(<span class="number">5</span>**i)-(<span class="number">5</span>**i)//<span class="number">2</span></span><br><span class="line">            <span class="comment">#print(&quot;pl2=&quot; + str(n//2-m*(5**i)-(5**i)//2))</span></span><br><span class="line">                </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n%<span class="number">2</span> :</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N+<span class="number">1</span>) :</span><br><span class="line">        <span class="comment">#print(&quot;i=&quot;+str(i))</span></span><br><span class="line">        a1=(<span class="number">5</span>**i)//<span class="number">2</span>+<span class="number">1</span> <span class="comment">#首项</span></span><br><span class="line">        <span class="comment">#print(&quot;a1=&quot;+str(a1))</span></span><br><span class="line">        d=(<span class="number">5</span>**i)*<span class="number">2</span> <span class="comment">#公差</span></span><br><span class="line">        <span class="comment">#print(&quot;d=&quot;+str(d))</span></span><br><span class="line">        m=((n+<span class="number">1</span>)//<span class="number">2</span>)//(<span class="number">5</span>**i) <span class="comment">#完整段数</span></span><br><span class="line">        <span class="comment">#print(&quot;m=&quot;+str(m))</span></span><br><span class="line">        re+=(<span class="number">2</span>*a1+(m-<span class="number">1</span>)*d)*m//<span class="number">2</span> <span class="comment">#完整段等差数列求和</span></span><br><span class="line">        <span class="comment">#print(&quot;re1:&quot; + str(re))</span></span><br><span class="line">        re+=((n+<span class="number">1</span>)//<span class="number">2</span>-m*(<span class="number">5</span>**i))*<span class="number">2</span>*m <span class="comment">#最后一段余项求和</span></span><br><span class="line">        <span class="comment">#print(&quot;re2:&quot; + str(re)) </span></span><br><span class="line">        <span class="comment">#print(&quot;pl1=&quot; + str(((n+1)//2-m*(5**i))*2*m))</span></span><br><span class="line">        <span class="keyword">if</span> (n+<span class="number">1</span>)//<span class="number">2</span>-m*(<span class="number">5</span>**i)&gt;(<span class="number">5</span>**i)//<span class="number">2</span> :</span><br><span class="line">            re+=(n+<span class="number">1</span>)//<span class="number">2</span>-m*(<span class="number">5</span>**i)-(<span class="number">5</span>**i)//<span class="number">2</span></span><br><span class="line">            <span class="comment">#print(&quot;pl2=&quot; + str((n+1)//2-m*(5**i)-(5**i)//2))</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(re)</span><br></pre></td></tr></table></figure><hr><h1>E.Sequence</h1><p><strong>思维题</strong></p><h2 id="题意-4">题意</h2><p>给定一个长度为 $n$ 的正整数序列，并进行 $q$ 次询问<br>每次询问给定一个范围 $[l,r]$ 和一个正整数 $k$<br>问能否将序列中给定范围内的子序列划分为 $k$ 段非空区间，且每段区间之和为偶数</p><h2 id="解题思路-4">解题思路</h2><p>首先对于给定区间：</p><ol><li>给定区间内总元素个数不足 $k$ ，则无法划分</li><li>给定区间内奇数元素个数为奇数，则给定区间的和为奇数，无法划分为 $k$ 个和为偶数的区间</li><li>给定区间内奇数元素个数为偶数，则最优划分为：从前往后奇数两两匹配形成区间，余下的偶数自成一个区间</li></ol><p>因此本题的关键就在于区间内奇数的处理</p><p>输入的记录奇数所在的位置，每次询问对于给定的区间，二分查找第一次出现奇数的位置和最后一次出现的位置，判断奇数个数<br>符合要求再进行区间计数判断，具体实现和解释可以参考代码注释</p><h3 id="时间复杂度-4">时间复杂度</h3><p>2023/8/5：纠正：最坏时间复杂度为 $O(qn)$ ，卡一下平均能过qwq</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,q,t;cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    vector&lt;ll&gt; v,odd;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;v.<span class="built_in">emplace_back</span>(t);</span><br><span class="line">        <span class="keyword">if</span>(t&amp;<span class="number">1</span>) odd.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    &#125;<span class="comment">//奇数下标存入odd,O(n)</span></span><br><span class="line">    ll l,r,k;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,q)&#123;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">        <span class="keyword">if</span>(r-l&lt;k<span class="number">-1</span>) &#123;cout &lt;&lt; NO;<span class="keyword">continue</span>;&#125;<span class="comment">//元素数量小于k</span></span><br><span class="line">        <span class="keyword">if</span>(odd.<span class="built_in">empty</span>()) &#123;cout &lt;&lt; YES;<span class="keyword">continue</span>;&#125;<span class="comment">//整个序列无奇数</span></span><br><span class="line">        <span class="keyword">auto</span> ol=<span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(odd),l);<span class="comment">//找到区间左端点右边最近的奇数的位置</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">upper_bound</span>(<span class="built_in">ALL</span>(odd),r)-ol)&amp;<span class="number">1</span>) &#123;cout &lt;&lt; NO;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="comment">//如果区间内奇数个数为奇数个，一定会残留一个区间和为奇数的区间</span></span><br><span class="line">        ll cnt=<span class="number">0</span>;<span class="comment">//最多区间计数</span></span><br><span class="line">        <span class="keyword">while</span>(ol!=odd.<span class="built_in">end</span>()&amp;&amp;*ol&lt;=r)&#123;<span class="comment">//下一个奇数在区间内</span></span><br><span class="line">            cnt+=*ol-l;ol++;<span class="comment">//奇数左边的偶数一个记一段</span></span><br><span class="line">            <span class="keyword">if</span>(*ol&lt;=r) cnt++;<span class="comment">//两个奇数之间记一段</span></span><br><span class="line">            l=*ol+<span class="number">1</span>;ol++;<span class="comment">//更新左端点</span></span><br><span class="line">        &#125;<span class="keyword">if</span>(ol==odd.<span class="built_in">begin</span>()) &#123;cout &lt;&lt; YES;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        ol--;cnt+=r-*ol;<span class="comment">//加上区间右边剩余偶数</span></span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=k) cout &lt;&lt; YES;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; NO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>G.Gcd</h1><p><strong>数论</strong></p><h2 id="题意-5">题意</h2><p>给定一个包含两个非负数的初始集合 $S={x,y}$<br>每次操作可以选定其中不相等的两个数 $a,b$ ，并将 $a-b$ 或 $gcd(a,b)$ 置入集合 $S$ ，其中 $gcd(0,a)=a$<br>可以操作任意次，问能否使得集合 $S$ 包含非负数 $z$</p><h3 id="前置知识点">前置知识点</h3><p><a href="https://oi-wiki.org/math/number-theory/bezouts/">裴蜀定理</a></p><h2 id="解题思路-5">解题思路</h2><p>根据裴蜀定理，两个正整数辗转相减只能得到他们最大公约数的倍数//<br>因此对于 $z$ ，判断其是否是 $g=gcd(x,y)$ 的倍数即可。<br>如果 $z$ 是 $g$ 的倍数，则可以通过以下操作得到 $z$ ：</p><ol><li>将 $g=gcd(x,y)$ 置入集合</li><li>$x$ 作为 $g$ 的倍数，其加减任意次 $g$ 便可得到任意 $g$ 的倍数。<br>只能减不能加怎么办呢//先把 $x$ 减到 $-g$ 就好了</li></ol><p>值得注意的是，本题的数据约束为<strong>非负数</strong>，这意味着需要对 $0$ 的情况进行特判//</p><ol><li>对于 $z=0$ ，仅当 $x,y$ 有 $0$ 时有解</li><li>对于 $x=0$ 或 $y=0$ ，仅当 $z$ 为非 $0$ 项的倍数时有解（实际上这条也满足裴蜀定理，直接归入一般情况即可）</li></ol><p>参考样例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">in</span>: <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="attribute">out</span>: YES</span><br></pre></td></tr></table></figure><h2 id="参考代码-5">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y,z;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">    <span class="keyword">if</span>(x&amp;&amp;y&amp;&amp;z==<span class="number">0</span>) &#123;cout &lt;&lt; NO;<span class="keyword">return</span>;&#125;</span><br><span class="line">    ll g=<span class="built_in">gcd</span>(x,y);</span><br><span class="line">    <span class="keyword">if</span>(z%g) cout &lt;&lt; NO;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期杭电多校06</title>
      <link href="/posts/ACM_2023Summer_HDU06.html"/>
      <url>/posts/ACM_2023Summer_HDU06.html</url>
      
        <content type="html"><![CDATA[<h1>1001.Count</h1><p><strong>构造</strong></p><h2 id="题意">题意</h2><p>给定 $n,m,k$ ，构造长度为 $n$ 的整数序列，元素大小范围为 $a_i\in [1,m]$ ，并且需要保证前 $k$ 个元素和后 $k$ 个元素对应相同<br>求可以构造出的序列数量</p><h2 id="解题思路">解题思路</h2><p>模拟一下即可<br>对于 $k\le \dfrac{n}{2}$ ，最后 $k$ 个元素由前 $k$ 个元素确定，只需决定前 $n-k$ 个元素<br>对于 $\dfrac{n}{2}\le k \lt n$ ，确定了前 $n-k$ 个元素，可以递归向后确定更多元素<br>对于 $k=n$ ，序列本身自然相同，即可以随意确定 $n$ 个元素</p><p>确定 $x$ 个元素的方案总数为 $m^{x}$ ，快速幂取模即可<br>(P.S.):快速幂前先对底数取模//</p><h3 id="时间复杂度">时间复杂度</h3><p>快速幂： $O(\log n)$</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">if</span>(n==k) cout &lt;&lt; <span class="built_in">qcpow</span>(m,n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">qcpow</span>(m,n-k) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期杭电多校05</title>
      <link href="/posts/ACM_2023Summer_HDU05.html"/>
      <url>/posts/ACM_2023Summer_HDU05.html</url>
      
        <content type="html"><![CDATA[<h1>1001.Typhoon</h1><p><strong>计算几何</strong></p><h2 id="题意">题意</h2><p>依次给定 $n$ 个坐标 $P$ ，预测的台风路线为按顺序两两连接给定坐标所得的折线<br>现在有 $m$ 个庇护所的坐标 $S$ ，求每个庇护所到台风路线的最短距离<br><img src="/images/ACM/2023Summer_HDU05_1001.jpg" alt="Img"></p><h2 id="解题思路">解题思路</h2><p>对于每个庇护所坐标，求它到每个路线线段的距离，再取最短即可<br>常见的错误为计算了点到线段所在直线的距离，而非到线段的距离（<s>别问我怎么知道的</s>）</p><p>问题转移到如何计算点到线段的距离<br>可以考虑将线段表示为向量，记为 $vec$ ;点到线段两端的向量记为 $vec1,vec2$<br>如果 $vec1,vec2$ 与 $vec$ 的点积同时大于 $0$ 或同时小于 $0$ ，则距离在端点取到，否则距离为点到直线的距离//<br>具体说明可以参考代码注释</p><h3 id="时间复杂度">时间复杂度</h3><p>$O(nm)$</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pll&gt; typh,shel;</span><br><span class="line">vector&lt;<span class="type">double</span>&gt; frac,dist;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cal_dist</span><span class="params">(pll s,pll t1,pll t2)</span></span>&#123;<span class="comment">//</span></span><br><span class="line">    ll x,y,x1,y1,x2,y2,p1,p2;</span><br><span class="line">    pll vec,vec1,vec2;<span class="type">double</span> re;</span><br><span class="line">    x=s.first;y=s.second;<span class="comment">//庇护所坐标</span></span><br><span class="line">    x1=t1.first;y1=t1.second;<span class="comment">//端点1</span></span><br><span class="line">    x2=t2.first;y2=t2.second;<span class="comment">//端点2</span></span><br><span class="line">    vec=&#123;x2-x1,y2-y1&#125;;vec1=&#123;x-x1,y-y1&#125;;vec2=&#123;x-x2,y-y2&#125;;</span><br><span class="line">    <span class="comment">//线段向量、点到两个端点的向量</span></span><br><span class="line">    p1=vec.first*vec1.first+vec.second*vec1.second;<span class="comment">//点积1</span></span><br><span class="line">    p2=vec.first*vec2.first+vec.second*vec2.second;<span class="comment">//点积2</span></span><br><span class="line">    <span class="keyword">if</span>(p1&lt;=<span class="number">0</span>&amp;&amp;p2&gt;<span class="number">0</span>||p1&gt;<span class="number">0</span>&amp;&amp;p2&lt;=<span class="number">0</span>)&#123;<span class="comment">//点到直线距离</span></span><br><span class="line">        <span class="type">double</span> frac=(<span class="type">double</span>)<span class="built_in">sqrt</span>((y2-y1)*(y2-y1)+(x1-x2)*(x1-x2));</span><br><span class="line">        re=(<span class="type">double</span>)<span class="built_in">fabs</span>((y2-y1)*x+(x1-x2)*y-y2*x1+x2*y1)/frac;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//点到端点距离</span></span><br><span class="line">        <span class="type">double</span> dist1=(<span class="type">double</span>)<span class="built_in">sqrt</span>(vec1.first*vec1.first+vec1.second*vec1.second);</span><br><span class="line">        <span class="type">double</span> dist2=(<span class="type">double</span>)<span class="built_in">sqrt</span>(vec2.first*vec2.first+vec2.second*vec2.second);</span><br><span class="line">        re=<span class="built_in">min</span>(dist1,dist2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    typh.<span class="built_in">resize</span>(n);shel.<span class="built_in">resize</span>(m);dist.<span class="built_in">resize</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[x,y]:typh) cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[x,y]:shel) cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;dist[i]=INF;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,n<span class="number">-2</span>)</span><br><span class="line">            dist[i]=<span class="built_in">min</span>(dist[i],<span class="built_in">cal_dist</span>(shel[i],typh[j],typh[j+<span class="number">1</span>]));&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">double</span> i:dist) &#123;<span class="built_in">print_float</span>(i,<span class="number">4</span>);cout &lt;&lt; endl;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1006.Touhou Red Red Blue</h1><p><strong>贪心/DP</strong></p><h2 id="题意-2">题意</h2><p>你将依次收到 $n$ 个物品，他们具有颜色红、绿或蓝，记为 $R,G,B$</p><p>你有一个大小为 $2$ 的物品栏。每当你收到一个物品，你可以考虑将其放入物品栏<strong>或直接丢弃</strong><br>物品栏是一个栈，这意味着如果你决定放入物品但物品栏是满的，你将丢弃更早放入的那个物品，并将手上的物品放入</p><p>下面是物品的得分和消除规则：</p><ol><li>如果手上和物品栏中共 $3$ 个物品颜色相同，则消除这 $3$ 个物品，得到 $1$ 分（这是唯一的得分方式），并在物品栏得到 $1$ 个颜色由你决定的新物品</li><li>如果手上和物品栏中共 $3$ 个物品颜色各不相同，则消除这 $3$ 个物品，并在物品栏得到 $2$ 个颜色由你决定的新物品</li></ol><p>求对于给定的物品序列，可以得到的最高分是多少</p><h2 id="解题思路-2">解题思路</h2><p>官方给出的做法是DP，但是考虑所有的状态转移略显繁琐，难以不重复、不遗漏<br>相比起来我还是更喜欢直接贪心的方法//</p><p>决定一种游戏策略前，先掌握游戏核心机制<br>首先，在贪心的思想下，物品栏的栈特性可以不考虑//因为如果需要被迫丢弃物品，大可以在拿到这个物品时就直接丢弃//<br>其次，注意到颜色任选的物品可以不立刻考虑，作为<code>任意物品</code>即可<br>考虑消除过程中的特点：</p><ol><li>规则 $2$ 消除后得到 $2$ 个<code>任意物品</code>，可以配合规则 $1$ ，直接和下一个物品（若有）合成得分</li><li>规则 $1$ 消除后留下 $1$ 个<code>任意物品</code>。这意味着如果有得分，最后一定会留下 $1$ 个<code>任意物品</code></li></ol><p>借助上面两个特点，单独考虑第一次消除，后续消除借助前面得到的<code>任意物品</code>，具体可以参考代码注释<br>计数直到满足条件消除，即视为取需要的物品，并直接丢弃无帮助的物品，重新计数即可</p><h3 id="时间复杂度-2">时间复杂度</h3><p>$O(n)$</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">RGB</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>:<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;cin &gt;&gt; s;</span><br><span class="line">    ll n=s.<span class="built_in">length</span>(),res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cur=<span class="number">0</span>,cnt[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cur=<span class="built_in">RGB</span>(s[i]);cnt[cur]++;</span><br><span class="line">        <span class="keyword">if</span>(res)&#123;<span class="comment">//消除过，前面必定有一个自选</span></span><br><span class="line">            <span class="keyword">if</span>(cnt[<span class="number">1</span>]&amp;&amp;cnt[<span class="number">2</span>]||cnt[<span class="number">1</span>]&amp;&amp;cnt[<span class="number">3</span>]||cnt[<span class="number">2</span>]&amp;&amp;cnt[<span class="number">3</span>])&#123;</span><br><span class="line">                <span class="comment">//已有两种不同颜色+自选：选不同颜色，消3得2</span></span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>==n) <span class="keyword">break</span>;<span class="comment">//没有下一个就结束</span></span><br><span class="line">                i++;res++;<span class="comment">//再用2个自选和下一个出现的颜色消除</span></span><br><span class="line">                cnt[<span class="number">1</span>]=cnt[<span class="number">2</span>]=cnt[<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cnt[<span class="number">1</span>]==<span class="number">2</span>||cnt[<span class="number">2</span>]==<span class="number">2</span>||cnt[<span class="number">3</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">//已有两个相同颜色+自选：选相同颜色，消3得1</span></span><br><span class="line">                res++;cnt[<span class="number">1</span>]=cnt[<span class="number">2</span>]=cnt[<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//还没有消除过</span></span><br><span class="line">            <span class="keyword">if</span>(cnt[<span class="number">1</span>]&amp;&amp;cnt[<span class="number">2</span>]&amp;&amp;cnt[<span class="number">3</span>])&#123;<span class="comment">//兼有三色：消3得2</span></span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>==n) <span class="keyword">break</span>;</span><br><span class="line">                i++;res++;<span class="comment">//再用2个自选和下一个出现的颜色消除</span></span><br><span class="line">                cnt[<span class="number">1</span>]=cnt[<span class="number">2</span>]=cnt[<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cnt[<span class="number">1</span>]==<span class="number">3</span>||cnt[<span class="number">2</span>]==<span class="number">3</span>||cnt[<span class="number">3</span>]==<span class="number">3</span>)&#123;<span class="comment">//有三个同色：消3得1</span></span><br><span class="line">                res++;cnt[<span class="number">1</span>]=cnt[<span class="number">2</span>]=cnt[<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1007.Expectation (Easy Version)</h1><p><strong>数学期望</strong></p><h2 id="题意-3">题意</h2><p>玩 $n$ 次游戏，每次游戏胜利的概率为 $\dfrac{a}{b}$<br>对于给定的 $m$ ，每次游戏胜利将获得 $k^m$ 分，其中 $k$ 是当前总胜利局数，失败得 $0$ 分<br>最终得分为 $n$ 次游戏的得分之和，求最终得分的期望</p><h2 id="解题思路-3">解题思路</h2><p>从全局角度考虑得分情况，游戏输赢概率满足二项分布，记获胜概率为 $p=\dfrac{a}{b}$<br>在 $n$ 局游戏中赢 $k$ 局的概率为： $C_n^k\cdot p^k(1-p)^{n-k}$<br>赢 $k$ 局游戏可以获得的最终得分记为 $score(k)$ ： $score(k)=\sum\limits_{i=1}^k i^m$<br>故最终得分期望为： $E=\sum\limits_{i=1}^n C_n^k\cdot p^k(1-p)^{n-k}\cdot score(k)$</p><p>分别预处理阶乘、乘方、得分数组，求和取模即可</p><h3 id="时间复杂度-3">时间复杂度</h3><p>乘方、阶乘、求和取模： $O(n)$<br>得分（快速幂+前缀和）： $O(n\log m)$<br>总时间复杂度： $O(n\log m)$</p><h2 id="参考代码-3">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中功能请读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ll&gt; powp,pownp,score;<span class="comment">//p的n次、q的n次、赢n局的得分</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,a,b,re=<span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    ll p=<span class="built_in">mul</span>(a,<span class="built_in">inv</span>(b));<span class="comment">//获胜的概率</span></span><br><span class="line">    ll np=<span class="built_in">Get_Mod</span>(<span class="number">1</span>-p);<span class="comment">//失败的概率</span></span><br><span class="line">    powp.<span class="built_in">clear</span>();pownp.<span class="built_in">clear</span>();score.<span class="built_in">clear</span>();</span><br><span class="line">    powp.<span class="built_in">resize</span>(n+<span class="number">1</span>);pownp.<span class="built_in">resize</span>(n+<span class="number">1</span>);score.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    powp[<span class="number">0</span>]=pownp[<span class="number">0</span>]=<span class="number">1</span>;score[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        powp[i]=<span class="built_in">mul</span>(powp[i<span class="number">-1</span>],p);</span><br><span class="line">        pownp[i]=<span class="built_in">mul</span>(pownp[i<span class="number">-1</span>],np);</span><br><span class="line">        score[i]=<span class="built_in">add</span>(score[i<span class="number">-1</span>],<span class="built_in">qcpow</span>(i,m));&#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        re=<span class="built_in">add</span>(re,<span class="built_in">mul</span>(score[i],<span class="built_in">mul</span>(<span class="built_in">Get_Combination</span>(n,i),<span class="built_in">mul</span>(powp[i],pownp[n-i]))));</span><br><span class="line">        <span class="comment">//Ex(i)=C(n,i)*p^i*(1-p)^(n-i)*score(i)</span></span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1012.Counting Stars</h1><p><strong>计数</strong></p><h2 id="题意-4">题意</h2><p>定义 $k$ 星状图：一个 $k+1$ 个节点， $k$ 条边的无向图，中心节点与其他 $k$ 个节点之间各有一条边，其他节点之间没有边<br>给定一个无向图 $G=(V,E),|V|=n,|E|=m$ ，记其中不同的 $k$ 星状图的数量为 $cnt_k$<br>求对于 $2\le k\le n-1$ ，所有 $cnt_k$ 的异或和： $cnt_2\oplus cnt_3\oplus \cdots \oplus cnt_{n-1}$</p><h2 id="解题思路-4">解题思路</h2><p>对于某个节点 $i$ ，记它的度为 $deg_i$ ，考虑以它作为中心节点的情况<br>简单的组合问题，以 $i$ 为中心节点的 $k$ 星图数量即 $C_n^k$<br>遍历 $n$ 个节点，在每个节点处对 $2\le k\le deg_i$ 的 $k$ 星图计数取模<br>最终把所有结果做异或和即可</p><h3 id="时间复杂度-4">时间复杂度</h3><p>预处理阶乘（计算组合数）： $O(n)$<br>遍历节点：$O(n+m)$<br>异或和：$O(n)$<br>总时间复杂度：$O(n+m)$</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ll&gt; deg,cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    deg.<span class="built_in">clear</span>();deg.<span class="built_in">resize</span>(n+<span class="number">1</span>);cnt.<span class="built_in">clear</span>();cnt.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    ll u,v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        deg[u]++;deg[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">2</span>,deg[i])</span><br><span class="line">            cnt[j]=<span class="built_in">Get_Mod</span>(cnt[j]+<span class="built_in">Get_Combination</span>(deg[i],j));</span><br><span class="line">    ll re=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n<span class="number">-1</span>) re^=cnt[i];</span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期牛客多校05</title>
      <link href="/posts/ACM_2023Summer_NCD05.html"/>
      <url>/posts/ACM_2023Summer_NCD05.html</url>
      
        <content type="html"><![CDATA[<h1>C.Cheeeeen the Cute Cat</h1><p><strong>二部图最大匹配</strong></p><h2 id="题意">题意</h2><p>给定一个具有 $2n$ 个节点的二部图，前 $n$ 个节点和后 $n$ 个节点各成一部<br>对于每对 $(i,j),i\ne j$ ，保证在 $i,j+n$ 和 $j,i+n$ 之间有且仅有一条边，整幅图的边数共 $C_n^2$ 条<br>求这个二部图的最大匹配</p><h3 id="前置知识点">前置知识点</h3><p><a href="https://oi-wiki.org/graph/bi-graph/">二分图</a><br><a href="https://oi-wiki.org/graph/graph-matching/bigraph-match/">二分图最大匹配</a></p><h2 id="解题思路">解题思路</h2><p>题解和讨论区谈及竞赛图以及相关特点，稍微了解了一下但是赛事确实没发现可以把这个图转化成一个竞赛图//<br>当时一眼看去就像一道朴实无华的板子题，队友直接交了一发板子就过了//<br>跑一遍增广路求出最大匹配即可，具体的实现原理在OI-Wiki上有非常详细的推导与说明//<br>本蒟蒻就是看它学的qwq这里就不过多赘述了</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">augment_path <span class="title">G</span><span class="params">(n,n*<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            <span class="keyword">if</span>(t) G.<span class="built_in">add</span>(i,j+n);</span><br><span class="line">        &#125;cout &lt;&lt; G.<span class="built_in">solve</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>D.Cirno’s Perfect Equation Class</h1><p><strong>签到</strong></p><h2 id="题意-2">题意</h2><p>给定三个整数 $k,c,n$<br>求满足以下条件的有序对 $(a,b)$ 的个数： $ka+b=c$ ， $b|c$ ， $gcd(a,b)&gt;n$</p><h2 id="解题思路-2">解题思路</h2><p>注意到第二个约束条件： $b$ 是 $c$ 的因子<br>因此对 $b$ 枚举，判断计数即可</p><h3 id="时间复杂度">时间复杂度</h3><p>$O(qc^\frac{1}{2})$</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll k,c,n,a,tb;</span><br><span class="line">cin &gt;&gt; k &gt;&gt; c &gt;&gt; n;</span><br><span class="line">ll r=<span class="built_in">floor</span>(<span class="built_in">sqrt</span>(c)),cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(ll b=<span class="number">1</span>;b*b&lt;=c;b++)&#123;</span><br><span class="line"><span class="keyword">if</span>(c%b==<span class="number">0</span>&amp;&amp;(c-b)%k==<span class="number">0</span>)&#123;</span><br><span class="line">a=(c-b)/k;</span><br><span class="line"><span class="keyword">if</span>(a&amp;&amp;b&amp;&amp;<span class="built_in">gcd</span>(a,b)&gt;=n) cnt++;</span><br><span class="line">&#125;</span><br><span class="line">tb=c/b;</span><br><span class="line"><span class="keyword">if</span>(tb!=b&amp;&amp;c%tb==<span class="number">0</span>&amp;&amp;(c-tb)%k==<span class="number">0</span>)&#123;</span><br><span class="line">a=(c-tb)/k;</span><br><span class="line"><span class="keyword">if</span>(a&amp;&amp;tb&amp;&amp;<span class="built_in">gcd</span>(a,tb)&gt;=n) cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>G.Go to Play Maimai DX</h1><p><strong>签到</strong></p><h2 id="题意-3">题意</h2><p>给定一个长度为 $n$ 仅含有 $1,2,3,4$ 四种数字的序列<br>求最短的包含 $1,2,3$ 和 $k$ 个 $4$ 的区间的长度</p><h2 id="解题思路-3">解题思路</h2><p>用快慢指针确定区间<br>快指针每次记录元素，直到满足条件；<br>慢指针每次移除元素，直到不满足条件<br>即可得到每个满足条件的最小区间，比较长度即可</p><h3 id="时间复杂度-2">时间复杂度</h3><p>$O(n)$</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="type">int</span> v[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll n,k;cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; v[i];</span><br><span class="line">    ll l=<span class="number">0</span>,r=<span class="number">0</span>,cnt[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;,re=n;</span><br><span class="line">    <span class="keyword">while</span>(r&lt;=n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!(cnt[<span class="number">1</span>]&amp;&amp;cnt[<span class="number">2</span>]&amp;&amp;cnt[<span class="number">3</span>]&amp;&amp;cnt[<span class="number">4</span>]&gt;=k))&#123;</span><br><span class="line">            r++;cnt[v[r]]++;<span class="keyword">if</span>(r&gt;n) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cnt[<span class="number">1</span>]&amp;&amp;cnt[<span class="number">2</span>]&amp;&amp;cnt[<span class="number">3</span>]&amp;&amp;cnt[<span class="number">4</span>]&gt;=k)&#123;</span><br><span class="line">            l++;cnt[v[l]]--;<span class="keyword">if</span>(l&gt;r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;re=<span class="built_in">min</span>(re,r-l+<span class="number">1</span>);</span><br><span class="line">    &#125;cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>H.Nazrin the Greeeeeedy Mouse</h1><p><strong>动态规划</strong></p><h2 id="题意-4">题意</h2><p>给定一组 $n$ 个奶酪，第 $i$ 个奶酪具有重量 $w_i$ 和价值 $val_i$<br>将前来取 $m$ 次奶酪，每次会携带一个大小为 $sz$ 的背包，并保证每一次携带背包的大小不小于前一次，并从第一个奶酪出发<br>对于每一个奶酪，可以选择装入背包（如果背包剩余空间足够）或挖洞通过（被挖洞的奶酪无法带走），并且仅当上一块奶酪被带走或挖洞，才能到达下一块<br>每次出发的过程不独立，问 $m$ 次可以获得最大价值为多少//</p><h2 id="解题思路-4">解题思路</h2><p>由于每次携带的背包大小都不小于前一次，因此如果取的次数 $m$ 多于奶酪个数 $n$ ，只需要考虑最后 $n$ 个背包即可//感性证明一下：如果倒数 $n$ 背包内某次装不下任何一块奶酪，那么之前的背包也不可能装下//</p><p>对于奶酪，只有取和不取两种状态（为不影响后续操作，没取的奶酪直接视为挖洞）<br>对于某一轮行动，假设最优解下它取的第一个奶酪和最后一个奶酪之间的区间为 $[l,r]$ ，那么可以视为这一轮行动是携带空间为 $sz_i$ ，第 $[l,r]$ 个奶酪上的01背包问题</p><p>由于不确定每轮取的范围以及对应背包大小，因此每个区间的每个重量都需要一个01背包DP值<br>用 $dp_{i,j,k}$ 表示在区间 $[i,j]$ 内，取重量为 $k$ 的物品可以获得的最大价值，可以得到以下状态转移方程：<br>$$<br>dp_{i,j,k}=\begin{cases}<br>dp_{i,j-1,k} &amp;,dp_{i,j-1,k-w[j]}+val_j&lt;dp_{i,j-1,k}或 k&lt;w_j\newline<br>dp_{i,j-1,k-w[j]}+val_j &amp;,dp_{i,j-1,k-w[j]}+val_j&gt;dp_{i,j-1,k}<br>\end{cases}<br>$$</p><p>在计算完 $[i,j]$ 内的 $dp$ 值后，前缀维护每一个 $k$ 的 $dp_{i,j,k}$ ，使得对于该区间， $dp$ 值随 $k$ 增加不递减</p><p>最后对全部 $m$ 轮行动进行DP，记 $g_{i,j}$ 为第 $i$ 次行动携带背包的容量为 $sz$ ，到达的最后一个位置为 $j$ 所得到的最大价值，可以得到以下状态转移方程：<br>$$<br>g_{i,j}=max{g_{i-1,k}+dp_{k+1,j,sz}},k\in[1,j-1]<br>$$</p><h3 id="时间复杂度-3">时间复杂度</h3><p>$O(n^2w)$</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 205</span></span><br><span class="line">ll dp[N][N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll w[N]=&#123;<span class="number">0</span>&#125;,val[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll g[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">RESET</span>(dp);</span><br><span class="line">    ll n,m,t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; val[i];</span><br><span class="line">    <span class="comment">//规划[i,j]区间内取体积为k的最优解</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;<span class="comment">//从第i个开始考虑</span></span><br><span class="line">        <span class="built_in">FORLL</span>(j,i,n)&#123;<span class="comment">//目前考虑第j个取/不取</span></span><br><span class="line">            <span class="built_in">FORLL</span>(k,<span class="number">0</span>,w[j]<span class="number">-1</span>) dp[i][j][k]=dp[i][j<span class="number">-1</span>][k];</span><br><span class="line">            <span class="comment">//对于无法装下第j个的情况，用j-1之前的维护</span></span><br><span class="line">            <span class="built_in">FORLL</span>(k,w[j],N) dp[i][j][k]=<span class="built_in">max</span>(dp[i][j<span class="number">-1</span>][k],dp[i][j<span class="number">-1</span>][k-w[j]]+val[j]);</span><br><span class="line">            <span class="comment">//可以装下的情况，更新较大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n)</span><br><span class="line">            <span class="built_in">FORLL</span>(k,<span class="number">1</span>,n)</span><br><span class="line">                dp[i][j][k]=<span class="built_in">max</span>(dp[i][j][k],dp[i][j][k<span class="number">-1</span>]);</span><br><span class="line">                <span class="comment">//对于区间[i,j]，前缀维护最优解</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n)&#123;<span class="built_in">FORLL</span>(i,<span class="number">1</span>,m-n) cin &gt;&gt; t; m=n;&#125;ll sz,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;cin &gt;&gt; sz;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="built_in">FORLL</span>(k,<span class="number">0</span>,j<span class="number">-1</span>) g[i][j]=<span class="built_in">max</span>(g[i][j],g[i<span class="number">-1</span>][k]+dp[k+<span class="number">1</span>][j][sz]);</span><br><span class="line">            <span class="comment">//第二项：前i个背包最远拿到第k项+第i个背包拿[k+1,j]内</span></span><br><span class="line">            ans=<span class="built_in">max</span>(ans,g[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期牛客多校04</title>
      <link href="/posts/ACM_2023Summer_NCD04.html"/>
      <url>/posts/ACM_2023Summer_NCD04.html</url>
      
        <content type="html"><![CDATA[<h1>A.Bobo String Construction</h1><p><strong>构造</strong></p><h2 id="题意">题意</h2><p>给定一个标识01串 $t$ ，构造一个长度为 $n$ 的信息01串 $s$ ，使得串 $m=t+s+t$ 中，串$t$ 仅在开头和结尾各出现过一次。（其中 $+$ 表示字符串连接运算）</p><h2 id="解题思路">解题思路</h2><p>考虑构造 $s$ 全为 $0$ 或 $1$</p><p>对于特殊情况， $t$ 全为 $0$ 或 $1$ ，则使 $s$ 全为 $1$ 或 $0$ 即可</p><p>如果 $t$ 中兼有 $0$ 和 $1$ ，则 显然 $s$ 中不可能有子串 $t$<br>但对于 $m=t+s+t$ ，可能有 $t的后缀+s+t的前缀=t$ 的情况出现，导致不满足题设条件//</p><p>那么下面感性证明一下两种方案至少有一种成立。<br>假设对于兼有 $0$ 和 $1$ 的 $t$ ，在 $s$ 全为 $0$ 的情况下出现：<br>$t的后缀+s+t的前缀=t$<br>那么构造 $s$ 全为 $1$ 即可，反之亦然</p><p>于是问题就转化为在 $s$ 全为 $1$ 或 $0$ 的方案中选择一种使得串$t$ 仅在开头和结尾各出现过一次<br>先使 $s$ 全为 $1$ 将 $m=t+s+t$ 去掉首尾一个字符，判断中间有无字串 $t$ 即可<br>归纳发现特殊情况也可以用这种方法构造</p><h3 id="时间复杂度">时间复杂度</h3><p>数据范围小（ $n\le 1000,|t|\le 1000$ ），BF即可</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string t;ll n;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; t;</span><br><span class="line">    string s;<span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) s.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    string m=t+s+t;m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());m.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">if</span>(m.<span class="built_in">find</span>(t)!=string::npos) <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cout &lt;&lt; <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cout &lt;&lt; <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>F.Election of the King</h1><p><strong>签到、模拟</strong></p><h2 id="题意-2">题意</h2><p>$n$ 个人竞选国王，每个人的从政理念用 $a_i$ 量化表示<br>每人每轮可以进行投票，对于个人而言，他会将票投给和他自己的政治理念相差最大的人<br>票数最多的人将被淘汰。如果票数相同，则淘汰值最大的；如果最大值有多个，则淘汰序号最大的人。<br>重复直到剩余一人成为国王，问最后谁会竞选上国王</p><h2 id="解题思路-2">解题思路</h2><p>对于其中某一个人，和他相差最大的，一定是最大值与最小值之一<br>那么每次一定淘汰最大值或最小值<br>因此对所有人进行排序，每轮投票处于中间位置的人代表着多数人的意志<br>因此每轮看中间的人投最大值还是最小值，踢到只剩一人即可</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    deque&lt;pll&gt; v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        v.<span class="built_in">emplace_back</span>(t,i);</span><br><span class="line">    &#125;<span class="built_in">SORT</span>(v);</span><br><span class="line">    <span class="type">float</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        mid=<span class="number">1.</span>*(v.<span class="built_in">front</span>().first+v.<span class="built_in">back</span>().first)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(v[(n+<span class="number">1</span>)/<span class="number">2</span><span class="number">-1</span>].first&lt;=mid) v.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">else</span> v.<span class="built_in">pop_front</span>();</span><br><span class="line">        n--;</span><br><span class="line">    &#125;cout &lt;&lt; v.<span class="built_in">front</span>().second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>H.Merge the squares!</h1><p><strong>几何、分治</strong></p><h2 id="题意-3">题意</h2><p>给定一个 $n\times n$ 的矩阵，它由 $n\times n$ 个小正方形组成<br>每次操作可以选择 $2\le x\le50$ 个正方形并把它们组合成一个更大的正方形（组合后的形状也必须为正方形）<br>求合并到整个边长为 $n$ 大小的正方形的操作过程</p><h2 id="解题思路-3">解题思路</h2><p>这道题可以采用分治的思想</p><p>对于边长不大于 $7$ 的正方形，它的面积不大于 $49$ ，可以直接合并<br>对于边长较大的正方形，可以考虑将其分解为更小的正方形，递归处理</p><p>接下来考虑一种通用可行的分解方法如下图<br><img src="/images/ACM/2023Summer_NCD04_H.png" alt="Img"><br>这种分法将大正方形分解成两个小正方形和两个矩形<br>假设小正方形在递归处理中合并完成，占用块数为 $2$ ，那么每个长方形部分允许占用的块数为 $(50-2)/2=24$ 块</p><p>对于每个长方形，按照宽分割成一个正方形和一个矩形，对两部分分别递归处理</p><p>代码中预处理了一个切割方案，用于决定在大正方形边长为 $i$ 的情况下，满足矩形 $(i-j)\times j$ 即长方形的部分，占用分割块数不超过 $24$ 时，左上角的正方形边长，以此保证每次递归处理大正方形都满足条件</p><h1>参考代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">ll len[<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre_len</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,i<span class="number">-1</span>)&#123;</span><br><span class="line">            ll cnt=<span class="number">0</span>;</span><br><span class="line">            ll a=j,b=i-j;<span class="comment">//先减去一个j*j大小的方形</span></span><br><span class="line">            <span class="keyword">while</span>(b)&#123;</span><br><span class="line">                cnt+=a/b;</span><br><span class="line">                a%=b;</span><br><span class="line">                <span class="built_in">swap</span>(a,b);</span><br><span class="line">            &#125;<span class="comment">//辗转相减得到(i-j)*j下分块数量</span></span><br><span class="line">            <span class="keyword">if</span>(cnt &lt;= <span class="number">24</span>)&#123;</span><br><span class="line">                len[i]=j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="comment">//得到长i下的可用宽j</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node_op</span>&#123;</span><br><span class="line">    ll x,y,n;</span><br><span class="line">&#125;top;</span><br><span class="line">vector&lt;node_op&gt; op;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll x1,ll y1,ll x2,ll y2)</span><span class="comment">//递归处理(x1,y1):(x2,y2)区域的矩形</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll difx=x2-x1+<span class="number">1</span>,dify=y2-y1+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(difx==<span class="number">1</span>||dify==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(difx&gt;dify)&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(x1,y1,x1+dify<span class="number">-1</span>,y2);</span><br><span class="line">        <span class="built_in">dfs</span>(x1+dify,y1,x2,y2);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(difx&lt;dify)&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(x1,y1,x2,y1+difx<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(x1,y1+difx,x2,y2);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//difx==dify</span></span><br><span class="line">        <span class="keyword">if</span>(difx==<span class="number">1</span>) <span class="keyword">return</span>;<span class="comment">//边长为1无需merge</span></span><br><span class="line">        <span class="keyword">if</span>(difx&gt;<span class="number">7</span>)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(x1,y1,x1+len[dify]<span class="number">-1</span>,y1+len[difx]<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">dfs</span>(x1+len[dify],y1+len[difx],x2,y2);</span><br><span class="line">            <span class="built_in">dfs</span>(x1+len[dify],y1,x2,y1+len[difx]<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">dfs</span>(x1,y1+len[difx],x1+len[dify]<span class="number">-1</span>,y2);</span><br><span class="line">        &#125;</span><br><span class="line">        top.x=x1;top.y=y1;top.n=difx;</span><br><span class="line">        op.<span class="built_in">emplace_back</span>(top);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    op.<span class="built_in">clear</span>();</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">pre_len</span>(n);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>,n,n);</span><br><span class="line">    cout &lt;&lt; op.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:op)&#123;</span><br><span class="line">        cout &lt;&lt; i.x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; i.y &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; i.n &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>J.Qu’est-ce Que C’est?</h1><p><strong>动态规划</strong></p><h2 id="题意-4">题意</h2><p>给定两个正整数 $n,m$ ，要求构造长度为 $n$ 的整数序列 $a$ ，满足：</p><ol><li>$\forall i\in [1,n],-m\le a_i\le m$</li><li>任意长度大于 $1$ 的连续子段之和不小于 $0$</li></ol><p>求满足以上条件的整数序列的个数，结果取模</p><h2 id="解题思路-4">解题思路</h2><p>计数取模，比起DP我会首先考虑猜通项<br>赛时根据样例1：$n=3,m=3\Rightarrow130$ 以及手算的 $n=2,m=3\Rightarrow28$ ，结合题目特征，拟出了一个满足上面两个情况的很奇怪的式子//然后样例2过不了，<s>开摆</s></p><p>DP的思想是先计算出第 $i$ 个位置前已经满足题设条件，且最小后缀和为 $j$ 的方案数量（ $j$ 可以是负数，因为最后一个数可以单独为负数）<br>考虑如何进行状态转移</p><p>对每个位置从大到小遍历当前位置填数后的最小后缀和 $j$ ，记当前遍历到 $i$ ，填入的数为 $x$</p><ol><li>对于非负整数 $j$ ，填入 $x$ 时的方案数为 $dp_{i-1,j-x}$<br>其中 $j-x\in[-m,m],x\in[-m,m],j\ge 0 \Rightarrow x\in [j-m,m]$，此时 $dp_{i,j}=\sum\limits_{x=j-m}^m dp_{i-1,x}$</li><li>对于负整数 $j$ ，此时 $x=j$ ，其方案数为允许 $x$ 填入的所有方案数之和，即 $dp_{i,j}=\sum\limits_{x=-j}^m dp_{i-1,x}$</li></ol><p>由于每次计算都用到了前一个位置的以 $m$ 为上界的区间和，因此可以对每个位置的dp数组从 $m$ 到 $-m$ 维护一个前缀和，以降低时间复杂度</p><h2 id="复杂度">复杂度</h2><p>时间复杂度： $O(n^2)$<br>空间复杂度： $M(Cn^2)$ ， $C$ 是常数，开LL可能会导致MLE<br>7/30：开L都MLE了//进行了空间优化，只保留 $dpsum$ 数组</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> O 5000 <span class="comment">//记为0</span></span></span><br><span class="line"><span class="type">long</span> dp[<span class="number">5005</span>][<span class="number">10005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//表示前i-1个数的最小后缀和为j+5000时，满足条件的可行方案数</span></span><br><span class="line"><span class="type">long</span> dpsum[<span class="number">5005</span>][<span class="number">10005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//表示dp[i][m]到dp[i][j]可行方案数的区间和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(ll j=m;j&gt;=-m;j--) &#123;dp[<span class="number">1</span>][j+O]=<span class="number">1</span>;dpsum[<span class="number">1</span>][j+O]=dpsum[<span class="number">1</span>][j+<span class="number">1</span>+O]+dp[<span class="number">1</span>][j+O];&#125;</span><br><span class="line">    <span class="comment">//预处理前0位</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=m;j&gt;=-m;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=<span class="number">0</span>) dp[i][j+O]=dpsum[i<span class="number">-1</span>][j-m+O];</span><br><span class="line">            <span class="comment">//下界x+m=j =&gt; x=j-m</span></span><br><span class="line">            <span class="keyword">else</span> dp[i][j+O]=dpsum[i<span class="number">-1</span>][-j+O];</span><br><span class="line">            <span class="comment">//j&lt;0 下界-j</span></span><br><span class="line">            dpsum[i][j+O]=<span class="built_in">Get_Mod</span>(dpsum[i][j+<span class="number">1</span>+O]+dp[i][j+O]);</span><br><span class="line">            <span class="comment">//计数取模</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; dpsum[n][-m+O] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7/30：空间优化后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> O 5000 <span class="comment">//记为0</span></span></span><br><span class="line"><span class="comment">//long dp[5001][10001]=&#123;0&#125;;//表示前i-1个数最小后缀和为j+5000，满足条件的可行方案数</span></span><br><span class="line"><span class="type">long</span> dpsum[<span class="number">5001</span>][<span class="number">10001</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//表示dp[i][m]到dp[i][j]可行方案数的区间和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(ll j=m;j&gt;=-m;j--)&#123;</span><br><span class="line">        <span class="comment">//dp[1][j+O]=1;</span></span><br><span class="line">        <span class="comment">//dpsum[1][j+O]=dpsum[1][j+1+O]+dp[1][j+O];</span></span><br><span class="line">        dpsum[<span class="number">1</span>][j+O]=dpsum[<span class="number">1</span>][j+<span class="number">1</span>+O]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=m;j&gt;=-m;j--)&#123;</span><br><span class="line">            <span class="comment">//if(j&gt;=0) dp[i][j+O]=dpsum[i-1][j-m+O];//下界x+m=j =&gt; x=j-m</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=<span class="number">0</span>) dpsum[i][j+O]=<span class="built_in">Get_Mod</span>(dpsum[i][j+<span class="number">1</span>+O]+dpsum[i<span class="number">-1</span>][j-m+O]);</span><br><span class="line">            <span class="comment">//else dp[i][j+O]=dpsum[i-1][-j+O];//j&lt;0 下界-j</span></span><br><span class="line">            <span class="keyword">else</span> dpsum[i][j+O]=<span class="built_in">Get_Mod</span>(dpsum[i][j+<span class="number">1</span>+O]+dpsum[i<span class="number">-1</span>][-j+O]);</span><br><span class="line">            <span class="comment">//dpsum[i][j+O]=Get_Mod(dpsum[i][j+1+O]+dp[i][j+O]);</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; dpsum[n][-m+O] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>L.We are the Lights</h1><p><strong>思维题</strong></p><h2 id="题意-5">题意</h2><p>有 $n\times m$ 的电灯矩阵，初始全为关闭状态</p><p>每次操作会打开或关闭某一行/列的所有灯</p><p>问在给定的 $q$ 次操作后，共有多少盏灯亮着</p><h2 id="解题思路-5">解题思路</h2><p>这道题和某刷墙小游戏类似（）玩过的话应该不难想到做法<br><img src="/images/ACM/2023Summer_NCD04_L.jpg" alt="Img"><br>后面的行动会覆盖前面的行动，用数组记录当前行/列是否已被覆盖</p><p>从后往前遍历操作即可</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> rc[N]=&#123;<span class="number">0</span>&#125;,op[N]=&#123;<span class="number">0</span>&#125;,rowvd[N]=&#123;<span class="number">0</span>&#125;,colvd[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll x[N]=&#123;<span class="number">0</span>&#125;,cnt=<span class="number">0</span>,cntr=<span class="number">0</span>,cntc=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    string trc,top;ll t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,q)&#123;</span><br><span class="line">        cin &gt;&gt; trc &gt;&gt; t &gt;&gt; top;</span><br><span class="line">        <span class="keyword">if</span>(trc==<span class="string">&quot;row&quot;</span>) rc[i]=<span class="number">1</span>;<span class="keyword">else</span> rc[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(top==<span class="string">&quot;on&quot;</span>) op[i]=<span class="number">1</span>;<span class="keyword">else</span> op[i]=<span class="number">0</span>;</span><br><span class="line">        x[i]=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=q;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rc[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(rowvd[x[i]]==<span class="number">0</span>)&#123;</span><br><span class="line">                rowvd[x[i]]=<span class="number">1</span>;cntr++;</span><br><span class="line">                <span class="keyword">if</span>(op[i]==<span class="number">1</span>) cnt+=m-cntc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(colvd[x[i]]==<span class="number">0</span>)&#123;</span><br><span class="line">                colvd[x[i]]=<span class="number">1</span>;cntc++;</span><br><span class="line">                <span class="keyword">if</span>(op[i]==<span class="number">1</span>) cnt+=n-cntr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期杭电多校04</title>
      <link href="/posts/ACM_2023Summer_HDU04.html"/>
      <url>/posts/ACM_2023Summer_HDU04.html</url>
      
        <content type="html"><![CDATA[<h1>1003.Simple Set Problem</h1><p><strong>思维</strong></p><h2 id="题意">题意</h2><p>给定 $k$ 个非空集合，在每一个集合里选择一个数 $a_i$ ，使得这些数之中最大值与最小值之差 $d=max(a_i)-min(a_i)$ 最小，输出 $d$ 的最小值</p><h2 id="解题思路">解题思路</h2><p>不论哪一种选法，最小值一定是在全体元素中取到的<br>不妨从小到大遍历全体元素作为下界，记当前遍历元素为 $a_i$<br>在每一个集合中二分查找恰好大于等于 $a_i$ 的元素选入(遍历到 $a_i$ 所在集合的时候，一定会选入 $a_i$ )<br>找到选定元素的最大值，做差<br>直到某个集合中没有大于等于 $a_i$ 的元素为止（此时该集合最大的元素选入的情况已全部考虑过），最终在得到的值中取最小即可</p><h3 id="时间复杂度">时间复杂度</h3><p>读入： $O(n)$ ；排序： $O(n\log n)$ ；遍历二分查找： $O(n\log n)$<br>综合时间复杂度：  $O(n\log n)$<br>其中 $n$ 表示全体元素个数， $n\le 4e6$</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">sets</span>(n+<span class="number">1</span>);</span><br><span class="line">    vector&lt;ll&gt; v;</span><br><span class="line">    vector&lt;ll&gt;::iterator it;</span><br><span class="line">    ll tn,t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; tn;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,tn) &#123;cin &gt;&gt; t;sets[i].<span class="built_in">emplace_back</span>(t);v.<span class="built_in">emplace_back</span>(t);&#125;</span><br><span class="line">        <span class="built_in">SORT</span>(sets[i]);</span><br><span class="line">    &#125;<span class="built_in">SORT</span>(v);</span><br><span class="line">    ll re=INF,tre;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v)&#123;</span><br><span class="line">        tre=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            it=<span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(sets[i]),x);</span><br><span class="line">            <span class="keyword">if</span>(it==sets[i].<span class="built_in">end</span>()) &#123;tre=<span class="number">-1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            tre=<span class="built_in">max</span>(tre,*it-x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tre==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        re=<span class="built_in">min</span>(re,tre);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1006.PSO</h1><p><strong>数学题、概率论</strong></p><h2 id="题意-2">题意</h2><p>给定一个星状图（中心节点与每个其他节点之间各有一条边，其他节点之间没有边），任选两个点，求它们之间的距离的数学期望以及最大距离的长度</p><h2 id="解题思路-2">解题思路</h2><p>任选两个点的方案总数为 $C_n^2=n(n-1)/2$<br>其中一个点是中心点的方案数为 $n-1$ ，距离是 $1$<br>其余方案数为 $n(n-1)/2-(n-1)$ ，距离是 $2$<br>因此任选两个点的距离期望为：<br>$$\begin{align}<br>E&amp;={[n(n-1)/2-(n-1)]\times2+(n-1)\times1}/C_n^2 \newline<br>&amp;=[n(n-1)-(n-1)\times2+(n-1)]/C_n^2 \newline<br>&amp;=(n-1)^2/C_n^2 \newline<br>&amp;=2(n-1)/n<br>\end{align}<br>$$<br>注意控制精度</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.9lf&quot;</span>,<span class="number">2.</span>*(n<span class="number">-1</span>)/n);</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot; 2.000000000\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot; 1.000000000\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1007.Guess</h1><p><strong>莫比乌斯函数</strong></p><h2 id="题意-3">题意</h2><p>给定一个正整数 $n\le1e18$ ，求 $e^{S(n)}$</p><p>其中，$S(n)=\sum\limits_{d|n} \mu(\dfrac{n}{d})\ln(d)$ ，$e$ 是自然对数 $\ln$ 的底数，$\mu(x)$ 是莫比乌斯函数，答案取模</p><h3 id="前置知识点">前置知识点</h3><p><a href="https://baike.baidu.com/item/%E9%BB%98%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/16625781">莫比乌斯函数</a>：<br>$$<br>\mu(n)=\begin{cases}<br>1 &amp;,n=1; \newline<br>0 &amp;,n含有大于1的完全平方因子; \newline<br>(-1)^k &amp;,n为k个质数的乘积 \newline<br>\end{cases}<br>$$</p><h2 id="解题思路-3">解题思路</h2><p>对于 $n$ 的因数 $d$ ，根据 $\dfrac{n}{d}$ 与 $d$ 的轮换对称性可知：<br>$S(n)=\sum\limits_{d|n} \mu(\dfrac{n}{d})\ln(d)=\sum\limits_{d|n} \mu(d)\ln(\dfrac{n}{d})$</p><p>对 $S(n)$ 做一次莫比乌斯变换（第一形式）可得：$\ln(n)=\sum\limits_{d|n} S(d)$</p><p>两边以 $e$ 做底数得 $e^{ln(n)}={e}^{\sum\limits_{d|n} S(d)}\Rightarrow n=\prod\limits_{d|n} e^{S(d)}$</p><p>右式是一个连乘积，其连乘长度为 $n$ 的全体因数个数<br>记 $F(x)=e^{S(x)}$ ，那么答案也就是在求 $F(n)$</p><p>根据上式：</p><ol><li>$1=F(1)\Rightarrow F(1)=1$</li><li>对于任意质数 $x$ ，$x=F(1)F(x)\Rightarrow F(x)=x$</li><li>对于任意合数 $x$ ，借助 $1,2$ 递归计算出 $F(x)$</li></ol><p>经过较长时间的感性理解，想到了一种遍历求 $F(x)$ 方法的伪代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F<span class="selector-attr">[]</span>=&#123;<span class="number">0</span>&#125;</span><br><span class="line">FOR <span class="selector-tag">i</span> <span class="keyword">in</span> &#123;<span class="number">1</span>..+∞&#125;</span><br><span class="line">    FOR <span class="selector-tag">p</span> <span class="keyword">in</span> Primes</span><br><span class="line">        <span class="keyword">if</span> F<span class="selector-attr">[i*p]</span>==<span class="number">0</span> then F<span class="selector-attr">[i*p]</span>=p</span><br></pre></td></tr></table></figure><p>（其实打表也挺好的，想个一般性的方法好难qwq）</p><p>可以得到以下 $F(x)$ 的正整数序列：<br>$1,2,3,2,5,1,7,2,3,1,11,1,13,1,1,2,17,1,19,1,1,1,23\cdots$</p><p>这个序列的意义是 $x$ 对乘积 $n$ 的贡献，回到上面看那个连乘积的长度和表达形式就非常合理了</p><p>通项公式为：<br>$$\begin{align}<br>F(n)&amp;=lcm{1…n}/lcm{1…n-1} \newline<br>&amp;=\begin{cases}<br>n&amp;,n=p^i,p是素数,i\in \N_+ \newline<br>1&amp;,Otherwise<br>\end{cases}<br>\end{align}<br>$$<br>即为最终答案</p><p>面对 $n\le 1e18$ 的庞大数据，问题就落到了如何快速求出 $F(n)$ 上了。根据通项公式，只需要判断 $n$ 是否有且只有一个素数非平凡因子 $p$ 即可</p><p>Pollard-Rho算法是一种用于因数分解整数的快速随机算法，它可以实现在 $n^{\frac{1}{4}}$ 的时间下随机找到一个 $n$ 的非平凡因子<br>其中用到了Miller-Rabin 素性测试算法，是一种测试素数的快速随机算法</p><p>Pollard-Rho算法的具体实现可以参考这篇博文：<a href="https://blog.csdn.net/maxichu/article/details/45459533">大数因数分解Pollard_rho 算法详解</a></p><p>最终根据查找结果，结合通项公式判断输出即可</p><h2 id="参考代码-2">参考代码</h2><p>（Pollard_Rho算法及Miller_Rabin算法部分略）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ll fac=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">prop</span><span class="params">(ll n)</span></span>&#123;<span class="comment">//判断n==p^i</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Miller_Rabin</span>(n))&#123;</span><br><span class="line">        <span class="keyword">if</span>(fac==<span class="number">0</span>) fac=n;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(fac!=n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll p=n;</span><br><span class="line">    <span class="keyword">while</span>(p==n) p=<span class="built_in">Pollard_Rho</span>(n);</span><br><span class="line">    <span class="keyword">if</span>(prop\(p\)&amp;&amp;<span class="built_in">prop</span>(n/p)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    fac=<span class="number">0</span>;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Miller_Rabin</span>(n)) &#123;cout &lt;&lt; <span class="built_in">Get_Mod</span>(n) &lt;&lt; <span class="string">&#x27; &#x27;</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">prop</span>(n)) cout &lt;&lt; <span class="built_in">Get_Mod</span>(fac) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-3.png" alt="Alt text"></p><hr><h1>1010.Kong Ming Qi</h1><p><strong><s>猜结论题</s> 找规律题</strong></p><h2 id="题意-4">题意</h2><p>如题，游戏规则和孔明棋相似<br>在一个 $(n+2)\times(m+2)$ 大小的棋盘的中间 $n\times m$ 的格子里放置着一些棋子<br>每次行动可以选择一个有四面相邻的棋子，使其跳过相邻的棋子，并使被跳过的棋子从棋盘上被移除<br>问对于给定的 $n,m$ ，剩余棋子个数最少是多少</p><h2 id="解题思路-4">解题思路</h2><p>首先考虑只有一行/一列的情况，每次只能选择倒数第二个跳出。假设 $n=1$ ，连续模拟几次可知一定剩余 $\lceil m/2 \rceil$ 颗棋子<br><img src="/images/ACM/2023Summer_HDU04_1010_1.png" alt="Img"></p><p>对于多行多列的情况，可以考虑以下两个基础操作：</p><ol><li>每次消去 $1\times 3$ 区域的棋子(需要左下方有棋子，中间操作)<br><img src="/images/ACM/2023Summer_HDU04_1010_2.png" alt="Img"></li><li>每次消去 $2\times 3$ 区域的棋子(最终操作)<br><img src="/images/ACM/2023Summer_HDU04_1010_3.png" alt="Img"></li></ol><p>连续操作 $1$ 后操作 $2$ ，即可在行数/列数大于 $3$ 的情况下任意消除 $3$ 行/列</p><p>考虑小情况 $2\times 2,2\times 3,3\times 3,2\times 4,3\times 4$ 等，借助上述基础操作以及模拟可得，当 $m,n$ 中有一个为3时，最少剩余 $2$ 颗棋子，其他情况最少剩余 $1$ 颗棋子，依此打表</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;m) <span class="built_in">swap</span>(m,n);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) cout &lt;&lt; (m+<span class="number">1</span>)/<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!(n%<span class="number">3</span>&amp;&amp;m%<span class="number">3</span>)) cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1011.Circuit</h1><p><strong>图论-最短路-Floyd</strong></p><h2 id="题意-5">题意</h2><p>给定一个无重边、无自循环的带权有向图 $G=(V,E),|V|=n,|E|=m$<br>求 $G$ 的所有回路中最短回路的长度以及个数，个数取模</p><h2 id="解题思路-5">解题思路</h2><p>全图范围的最短路计数，考虑使用弗洛伊德算法//</p><p>为了不重不漏的计数，考虑每个最短回路仅在其最大标号处计数<br>对于一条有向回路，可以将其最大编号到下一点的有向边单独分割出来，剩余部分即为从起点到回路上最大编号点的最短路//</p><p>借助Floyd算法，在 $O(n^3)$ 的时间内，计算最短路的同时，可以进行最短路方案数的计数，这里详细阐述一下计数过程</p><p>原图 $G$ 存在有向边 $u\rightarrow v$ ，则 $u\rightarrow v$ 的初始方案数置为 $1$ ，没有边则置为 $0$</p><p>加入点 $k$ 时，过点 $k$ 的 $i\rightarrow j$ 的最短路的方案数为： $i\rightarrow k$ 的最短方案数 $\times$ $k\rightarrow j$ 的最短路方案数<br>如果发生最短路更新，则方案数一并更新//另判断如果长度一致，则方案数需相加</p><p>每次完成更新后，假设 $k$ 已经是以 $i$ 为起点的最短回路上的最大编号点了，此时原图 $G$ 中如果有 $k\rightarrow i$ 的有向边，则可以构成回路，比较计数即可//</p><p>更加具体的内容可以参考代码注释</p><p>温馨提示： $INF$ 的值需要设置到 $1e18$ ，因为两段方案数乘积最大可以为 $MOD^2 \approx 1e18$ ，补题时因为 $INF$ 的值不够大卡了两个小时左右</p><h3 id="时间复杂度-2">时间复杂度</h3><p>Floyd算法：$O(n^3)$</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> INF=<span class="number">1e18</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 505</span></span><br><span class="line">ll dist[N][N]=&#123;<span class="number">0</span>&#125;,cnt[N][N]=&#123;<span class="number">0</span>&#125;,ori[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll mindist=INF,cntmin=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RESET_G</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">        ori[i][j]=<span class="number">0</span>;</span><br><span class="line">        dist[i][j]=(i==j?<span class="number">0</span>:INF);</span><br><span class="line">        cnt[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    mindist=INF,cntmin=<span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//重置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(k,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n)&#123;<span class="comment">//Floyd</span></span><br><span class="line">                <span class="keyword">if</span>(dist[i][j]&gt;dist[i][k]+dist[k][j])&#123;</span><br><span class="line">                    dist[i][j]=dist[i][k]+dist[k][j];</span><br><span class="line">                    cnt[i][j]=<span class="built_in">mul</span>(cnt[i][k],cnt[k][j]);<span class="comment">//cnt[i][j]=cnt[i][k]*cnt[k][j]</span></span><br><span class="line">                    <span class="comment">//方案数为两段方案数的乘积，更新同步</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dist[i][j]==dist[i][k]+dist[k][j])&#123;</span><br><span class="line">                    <span class="built_in">addto</span>(cnt[i][j],<span class="built_in">mul</span>(cnt[i][k],cnt[k][j]));<span class="comment">//cnt[i][j]+=cnt[i][k]*cnt[k][j]</span></span><br><span class="line">                    <span class="comment">//相等则方案数相加</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;k&amp;&amp;ori[k][i])&#123;<span class="comment">//假设到k为以i为起点的单向环上最大点</span></span><br><span class="line">                <span class="keyword">if</span>(ori[k][i]+dist[i][k]&lt;mindist) &#123;mindist=ori[k][i]+dist[i][k];cntmin=cnt[i][k];&#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ori[k][i]+dist[i][k]==mindist) <span class="built_in">addto</span>(cntmin,cnt[i][k]);<span class="comment">//cntmin+=cnt[i][k]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">RESET_G</span>(n);</span><br><span class="line">    ll u,v,w;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        ori[u][v]=w;</span><br><span class="line">        dist[u][v]=w;</span><br><span class="line">        cnt[u][v]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Floyd</span>(n);</span><br><span class="line">    <span class="keyword">if</span>(cntmin) cout &lt;&lt; mindist &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; cntmin &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1012.a-b Problem</h1><p><strong>贪心</strong></p><h2 id="题意-6">题意</h2><p>给定一堆 $n$ 个石子，每个石子有非负值 $a_i,b_i$ ，分别代表Alice和Bob取该石子可以得到的分数<br>两人都希望自己的得分最大化，Alice执先，求最终Alice和Bob的分数差</p><h2 id="解题思路-6">解题思路</h2><p>取某石子的价值不仅在于自身得分，也在于让对手失去他那部分的分值。因此根据每颗石子的分数之和排序，从大到小依次取即可</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;pair&lt;ll,pll&gt;&gt; v;</span><br><span class="line">    pair&lt;ll,pll&gt; t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t.second.first &gt;&gt; t.second.second;</span><br><span class="line">        t.first=t.second.first+t.second.second;</span><br><span class="line">        v.<span class="built_in">emplace_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    ll A,B;A=B=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>((n<span class="number">-1</span>-i)&amp;<span class="number">1</span>) B+=v[i].second.second;</span><br><span class="line">        <span class="keyword">else</span> A+=v[i].second.first;</span><br><span class="line">    &#125;</span><br><span class="line">    ll re=A-B;</span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期杭电多校03</title>
      <link href="/posts/ACM_2023Summer_HDU03.html"/>
      <url>/posts/ACM_2023Summer_HDU03.html</url>
      
        <content type="html"><![CDATA[<h1>1011.8-bit Zoom</h1><p><strong>不那么签到的签到题、模拟题</strong></p><h2 id="题意">题意</h2><p>给定一个 $n\times n$ 大小的字符矩阵表示一张图片，每种字符代表一种颜色；并给定 $Z$ 代表缩放倍率<br>满足以下条件即可缩放：</p><ol><li>缩放后的边长 $\dfrac{nZ}{100}$ 是一个整数</li><li>每个像素可以被唯一确定（如果缩放后的像素被从超过两种颜色覆盖，则无法确定颜色）</li></ol><p>如果可以进行缩放，则输出缩放后的图片，否则输出“error”</p><h2 id="解题思路">解题思路</h2><p>模拟缩放过程</p><p>如果不满足上述条件 $1$ 则一定无法缩放</p><p>条件 $2$ 需要根据图片实际情况判断是否满足<br>记这张图片被放大了 $x=\dfrac{a}{b}$ 倍，假设此处 $a,b$ 互质，则等同于先将图片缩小 $b$ 倍，再放大 $a$ 倍<br>如果缩小的过程不会有像素无法被确定，则缩小后一定是可以放大整数倍的<br>因此只需检查每个边长为 $b$ 的像素区块（它们将被缩小至 $1$ 像素），如果有任意一块混色，则无法压缩<br>压缩成功后，边长放大至 $a$ 倍即可</p><p>根据题意，记缩放后的图片尺寸为 $sz$<br>易得此处 $a=sz/gcd(n,sz)$ ， $b=n/gcd(n,sz)$</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,Z,t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; Z;</span><br><span class="line">    string s[<span class="number">55</span>];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; s[i];</span><br><span class="line">    <span class="keyword">if</span>((n*Z)%<span class="number">100</span>) &#123;cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    ll sz=(n*Z)/<span class="number">100</span>;<span class="comment">//缩放后的图片边长</span></span><br><span class="line">    <span class="type">char</span> re[<span class="number">55</span>][<span class="number">55</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    t=<span class="built_in">gcd</span>(sz,n);</span><br><span class="line">    <span class="keyword">if</span>(n==t)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="built_in">FORLL</span>(a,<span class="number">1</span>,sz/t)&#123;</span><br><span class="line">                <span class="built_in">FORLL</span>(j,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="built_in">FORLL</span>(b,<span class="number">1</span>,sz/t)&#123;</span><br><span class="line">                        cout &lt;&lt; s[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=t;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;t;j++)&#123;</span><br><span class="line">            <span class="type">char</span> ch=s[(i<span class="number">-1</span>)*(n/t)+<span class="number">1</span>][j*(n/t)];</span><br><span class="line">            <span class="built_in">FORLL</span>(a,<span class="number">0</span>,n/t<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">FORLL</span>(b,<span class="number">0</span>,n/t<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[(i<span class="number">-1</span>)*(n/t)+<span class="number">1</span>+a][j*(n/t)+b]!=ch)&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; endl;</span><br><span class="line">                        <span class="keyword">return</span> ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            re[i<span class="number">-1</span>][j]=ch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,t<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(a,<span class="number">1</span>,sz/t)&#123;</span><br><span class="line">            <span class="built_in">FORLL</span>(j,<span class="number">0</span>,t<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">FORLL</span>(b,<span class="number">1</span>,sz/t) cout &lt;&lt; re[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期牛客多校03</title>
      <link href="/posts/ACM_2023Summer_NCD03.html"/>
      <url>/posts/ACM_2023Summer_NCD03.html</url>
      
        <content type="html"><![CDATA[<h1>A.World Fragments I</h1><p><strong>字符串、签到</strong></p><h2 id="题意">题意</h2><p>给定两个二进制数 $x,y$<br>每次可以选择 $x$ 中的一个数位 $d$ ,并可执行 $x=x+d$ 或 $x=x-d$<br>问能否通过任意次以上操作，使得 $x=y$ ，并给出最少次数</p><h2 id="解题思路">解题思路</h2><p>这两个二进制数可以视为01串<br>对于 $x=0$ ，每一位都是0，除非 $y=0$ ，否则无法达成条件<br>对于 $x\ne 0$ ，必定有一位上是 $1$ ，通过题设操作可以转化为任何数，最小次数为这两个数的差的绝对值 $|x-y|$</p><p>bitset是一种非常便于处理01串的STL数据结构，合理利用可以省去很多麻烦</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string x,y;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="function">bitset&lt;1000&gt; <span class="title">a</span><span class="params">(x)</span>,<span class="title">b</span><span class="params">(y)</span></span>;</span><br><span class="line">    ll m,n;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">none</span>()&amp;&amp;b.<span class="built_in">any</span>()) &#123;cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    m=a.<span class="built_in">to_ullong</span>();</span><br><span class="line">    n=b.<span class="built_in">to_ullong</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">abs</span>(m-n) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>D.Ama no Jaku</h1><p><strong>思维</strong></p><h2 id="题意-2">题意</h2><p>给定一个01矩阵，每次操作可以选定任意一行或一列并将其反转<br>问在操作任意次后，能否使得该矩阵 行代表的二进制数$r_i$ 与列代表的二进制数 $c_i$ ，满足 $min(r_i)\ge max(c_i)$<br>若能，输出最少操作次数，否则输出“-1”</p><h2 id="解题思路-2">解题思路</h2><p>首先考虑满足条件的矩阵的状态<br>对于 $\text O$ 矩阵，$\forall i ,r_i=c_i=0$ ，一定满足条件<br>要使 $min(r_i)&gt;0$ ，每一行都要有 $1$ 。如果在每一行都加上一个 $1$ ，会发现无论如何排列顺序，都会使得 $min(r_i)\lt max(c_i)$<br>最终当所有元素都转化为 $1$ 时，满足条件<br>综上，只有当元素全为 $0$ 或 $1$ 时满足条件</p><p>显然如果一个矩阵可以转化为全 $0$ 矩阵，那么它一定可以转化为全 $1$ 矩阵，因此考虑原矩阵是否可以转化为全 $0$ 矩阵</p><p>先将第一列全部转化为 $0$ ，后面每一列的值都必须全为 $0$ 或 $1$ 才可以满足条件<br>分别记录行和列的首位转化为0的次数，分类比较即可</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,cntr=<span class="number">0</span>,cntc=<span class="number">0</span>,re1,re2;<span class="comment">//转置为0的次数</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    bitset&lt;2005&gt; mat[<span class="number">2005</span>];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cin &gt;&gt; mat[i];</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(mat[i][<span class="number">0</span>]) &#123;mat[i].<span class="built_in">flip</span>();cntr++;&#125;</span><br><span class="line">    <span class="comment">//FORLL(i,0,n-1) &#123;FORLL(j,0,n-1) cout &lt;&lt; mat[i][j]; cout &lt;&lt; endl;&#125;</span></span><br><span class="line">    <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> b=mat[<span class="number">0</span>][j];</span><br><span class="line">        <span class="keyword">if</span>(b) cntc++;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(mat[i][j]!=b) &#123;cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    re1=cntc+(cntr&gt;=(n+<span class="number">1</span>)/<span class="number">2</span>?cntr:n-cntr);</span><br><span class="line">    re2=cntr+(cntc&gt;=(n+<span class="number">1</span>)/<span class="number">2</span>?cntc:n-cntc);</span><br><span class="line">    cout &lt;&lt; (re1&lt;re2?re1:re2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>H.Until the Blue Moon Rises</h1><p><strong>数学题</strong></p><h2 id="题意-3">题意</h2><p>对于给定的 $n$ 个数，每次操作可以使一个数 $-1$ ，另一个数 $+1$<br>可以操作任意次，问是否可以使这些数全部成为质数</p><h3 id="前置知识点">前置知识点</h3><p><a href="https://baike.baidu.com/item/%E5%93%A5%E5%BE%B7%E5%B7%B4%E8%B5%AB%E7%8C%9C%E6%83%B3/72364">哥德巴赫猜想</a>：任一大于5的整数都可写成三个质数之和，任一大于2的偶数都可写成两个素数之和</p><h2 id="解题思路-3">解题思路</h2><p>题设操作任意次的效果即：把所有数的和 $sum$ 分成 $n$ 个数<br>问是否有一种分法使得这 $n$ 个数都是质数</p><ol><li>$n$ 个数都是质数时，最小情况是所有的数全为 $2$<br>因此，当 $sum&lt;2\times n$ 时一定不可以构成</li><li>$n=1$<br>只有一个数，直接判断它是否为质数即可</li><li>$n=2$<br>如果它们的和是偶数，根据哥德巴赫猜想一定可以构成；<br>如果它们的和是奇数，分成两个数一定是一奇一偶，众嗦粥汁，偶数中只有2是质数，因此判断 $n-2$ 是否为质数即可</li><li>$n=3$<br>由于 $sum&lt;2\times n=6$ 的情况已经在 $1$ 中筛去，故根据哥德巴赫猜想一定可以构成</li><li>$n&gt;3$<br>每次分出 $2$ 直到剩余 $3$ 个数，利用上一条可知一定可以构成</li></ol><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkprime</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>||n==<span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    ll t=<span class="built_in">sqrt</span>(n)+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,t) <span class="keyword">if</span>((n/i)*i==n)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll t,sum=<span class="number">0</span>;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        sum+=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum&lt;<span class="number">2</span>*n) &#123;cout &lt;&lt; NO ;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">checkprime</span>(sum))</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; YES;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; NO ;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">checkprime</span>(sum<span class="number">-2</span>)) &#123;cout &lt;&lt; YES ;<span class="keyword">return</span>;&#125;</span><br><span class="line">            cout &lt;&lt; NO;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; YES;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>J.Fine Logic</h1><p><strong>拓扑排序</strong></p><h2 id="题意-4">题意</h2><p>对于 $n$ 个人（记为 $1-n$），给定 $m$ 对偏序关系，表示胜利关系<br>对于一组排名，位于前面的人视为赢过后面的人<br>问如何构造最少组数的排名，使得满足给定的 $m$ 对胜利关系</p><h2 id="解题思路-4">解题思路</h2><p>对于 $n$ 个人之间的所有胜利关系，构造两组排名：<br>$$<br>1,2,3,\cdots,n \newline<br>n,n-1,n-2,\cdots,1<br>$$<br>一定能满足所有胜利关系</p><p>如果 $m$ 个胜利关系构成DAG，则将它的拓扑排序列作为排名输出一组即可<br>否则输出上面两组排名</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">G</span>(n+<span class="number">1</span>),<span class="built_in">pre</span>(n+<span class="number">1</span>);</span><br><span class="line">    vector&lt;pll&gt; E;</span><br><span class="line">    vector&lt;ll&gt;::iterator it;</span><br><span class="line">    ll u,v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        E.<span class="built_in">emplace_back</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SORT</span>(E);</span><br><span class="line">    <span class="built_in">unique</span>(<span class="built_in">ALL</span>(E));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e:E)&#123;</span><br><span class="line">        G[e.first].<span class="built_in">emplace_back</span>(e.second);</span><br><span class="line">        pre[e.second].<span class="built_in">emplace_back</span>(e.first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">SORT</span>(G[i]);</span><br><span class="line">        <span class="built_in">SORT</span>(pre[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">1</span>;</span><br><span class="line">    vector&lt;ll&gt; vec;</span><br><span class="line">    bitset&lt;1000005&gt; f;</span><br><span class="line">    f.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(f[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(pre[i].<span class="built_in">size</span>()&amp;&amp;f[pre[i].<span class="built_in">back</span>()]) pre[i].<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">if</span>(f[i]==<span class="number">0</span>&amp;&amp;pre[i].<span class="built_in">empty</span>())&#123;</span><br><span class="line">                vec.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">                f[i]=<span class="number">1</span>;flag=<span class="number">1</span>;cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt==n)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(ll i=n;i&gt;<span class="number">0</span>;i--) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期牛客多校02</title>
      <link href="/posts/ACM_2023Summer_NCD02.html"/>
      <url>/posts/ACM_2023Summer_NCD02.html</url>
      
        <content type="html"><![CDATA[<h1>D.The Game of Eating</h1><p><strong>贪心</strong></p><h2 id="题意">题意</h2><p>$n$ 个人聚餐， 在 $m$ 道菜品中选择 $k$ 道，且不能重复。从1号开始，每个人轮流选择一道菜<br>每个人对于每个菜品都有一个喜爱值，第 $i$ 个人对第 $j$ 个菜品的喜爱程度记为 $a_{i,j}$<br>假设每个人都想要使 自己对最终点的 $k$ 道菜的喜爱值总和 最大，求最终选定的菜单</p><h2 id="解题思路">解题思路</h2><p>对于当前点菜的人，假设他最喜欢的菜还没有被点，但他仍然需要考虑后面是否有人选择这道菜。如果后面一定有人选择这道菜，他可以选择第二喜欢的菜品以使得自己的满意度最大化<br>基于这种情况分析，最后一个点菜的人无需考虑其他人的需求，只需要选择剩余菜品中最喜欢的那一个，即可使得自己的满意度最大化<br>假设所有菜品中他最喜欢的还没有被选取，那么就会选择这个菜品。反推到倒数第二个、第三个亦此</p><p>因此，只需要将点菜的顺序逆转，这样只要每个人选择剩余菜品中最喜欢的菜品即可，无需考虑其他人的需求。</p><h3 id="时间复杂度">时间复杂度</h3><p>$k$ 次遍历菜品： $O(km)$</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n,k,t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    vector&lt;vector&lt;pll&gt;&gt; <span class="built_in">v</span>(n+<span class="number">1</span>);</span><br><span class="line">    vector&lt;ll&gt; re;</span><br><span class="line">    vector&lt;pll&gt;::iterator it;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">chosen</span><span class="params">(m+<span class="number">1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            v[i].<span class="built_in">emplace_back</span>(t,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">SORT</span>(v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll p=(k<span class="number">-1</span>)%n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        it=v[p].<span class="built_in">end</span>();--it;</span><br><span class="line">        <span class="keyword">while</span>(chosen[(*it).second]) it--;</span><br><span class="line">        re.<span class="built_in">emplace_back</span>((*it).second);</span><br><span class="line">        chosen[(*it).second]=<span class="literal">true</span>;</span><br><span class="line">        p--;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">0</span>) p=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SORT</span>(re);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:re)&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>E.Square</h1><p><strong>数学题</strong></p><h2 id="题意-2">题意</h2><p>对于给定的整数 $x\le 10^9$ ，找到一个 $y\le 10^9$ ，使得存在一个整数 $k$，使得 $x$ 是 $y^2$ 的前 $k$ 位<br>如果不存在这样的 $y$ ，输出 $-1$</p><h2 id="解题思路-2">解题思路</h2><p>题目给定了一个定义式：$\lfloor \dfrac{y^2}{10^k} \rfloor = x$<br>可以将其化解为不等式：<br>$$\begin{align}<br>原式<br>&amp;\Rightarrow x \le \dfrac{y^2}{10^k} \lt x+1 \newline<br>&amp;\Rightarrow 10^k x \le y^2 \lt 10^k (x+1) \newline<br>&amp;\Rightarrow \sqrt{10^k x} \le y \lt \sqrt{10^k(x+1)}<br>\end{align}<br>$$<br>其中 $x$ 是确定的，只需遍历 $k$ 对应的 $y=sqrt(10^k x)+1$ ，判断即可</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    ll t=<span class="built_in">sqrt</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(t*t==x)&#123;</span><br><span class="line">        cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ll p=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        p*=<span class="number">10</span>;<span class="comment">//表示10^k</span></span><br><span class="line">        t=<span class="built_in">sqrt</span>(p*x);</span><br><span class="line">        <span class="keyword">if</span>(t*t&lt;t*n) t++;</span><br><span class="line">        <span class="keyword">if</span>(t&gt;<span class="number">1e9</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((t*t)/p==x)&#123;</span><br><span class="line">            cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>F.Link with Chess Game</h1><p><strong>二分图博弈</strong></p><h2 id="题意-3">题意</h2><p>在一行长度为 $n$ 的格子上有红绿蓝三种颜色的棋子，他们的坐标构成一个有序三元组 $(r,g,b)$ （坐标可以重复）</p><p>每次可以选择一颗棋子向左或向右移动一步，如果某次移动后的三元组 $(r_i,g_i,b_i)$ 在此前出现过，则执行移动的人失败</p><h2 id="解题思路-3">解题思路</h2><h3 id="赛时想法">赛时想法</h3><p>假设只有一颗棋子的情况<br>选定一个方向，假设棋子当前距离这个方向端点的距离为 $x$ 。不难证明 $x$ 为奇数时胜利； $x$ 为偶数时失败<br>在这种情况下，只要当前位置与两端之一的距离为奇数即可获胜<br>基于这一结论，猜想三颗棋子的条件下，每颗棋子与左、右两端的距离之和 $suml,sumr$ 与必胜态之间的关系，和一颗棋子的情况相似<br>样例满足这一猜想</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,a,b,c;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    ll l,r;</span><br><span class="line">    l=a+b+c<span class="number">-3</span>;</span><br><span class="line">    r=n*<span class="number">3</span>-a-b-c;</span><br><span class="line">    <span class="keyword">if</span>(l&amp;<span class="number">1</span>||r&amp;<span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;Alice&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Bob&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="赛后补题">赛后补题</h3><p>对于这类无向的博弈，可以考虑是否为二分图博弈<br>把三颗棋子看作是三个维度，显然所有状态组成的图是一个正方体，一定是二分图<br>在 $n$ 为偶数的情况下，最大匹配可以覆盖所有状态，即初始状态一定在某一对匹配上。这种情况下，先手一定落在匹配中的最后一个点，因此是必胜的<br>在 $n$ 为奇数的情况下，对于起始点在较小一部的状态点，一定在某一最大匹配上。这种情况下，先手一定落在匹配中的最后一个点，因此是必胜的<br>对于起始点在较大一部中的状态点的情况，一定存在一个最大匹配不包含起始点。因此在这个最大匹配上，后手一定落在匹配中的最后一个点，因此是必败的<br>赛时的思路虽然不严谨，但误打误撞结论和正解是一致的//</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,a,b,c;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>((a+b+c<span class="number">-1</span>)&amp;<span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;Alice&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Bob&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Alice&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>I.Link with Gomoku</h1><p><strong>构造</strong></p><h2 id="题意-4">题意</h2><blockquote><p>“你赢得越多，你的自信就越强。你的自信越强，你就越傲慢。你越傲慢，就越容易犯错误。你犯的错误越多，你就输的越多。所以你赢的越多，你输的就越多。”</p></blockquote><p>在一个 $n\times m$ 大小的棋盘上下五子棋，构造一个平局的棋盘局面。</p><h2 id="解题思路-4">解题思路</h2><p>构造的方法并不难想，这里给出如下两种：</p><ol><li>题目样例所示的：<br>xxxxooooxxxxoooo<br>ooooxxxxooooxxxx<br>xxxxooooxxxxoooo<br>ooooxxxxooooxxxx</li><li>我赛时所写的：<br>ooxooxooxoo<br>xxoxxoxxoxx<br>ooxooxooxoo<br>xxoxxoxxoxx</li></ol><p>易错点在于：只关注了平局的条件，没有在意黑白子之间的数量关系</p><p>如果是偶数行，按上面方案输出；<br>如果是奇数行，最后一行按xoxoxox的顺序输出即可</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> flag=n&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag) n=n<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">FORLL</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j%<span class="number">3</span>) cout &lt;&lt; <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> cout &lt;&lt; <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">FORLL</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j%<span class="number">3</span>) cout &lt;&lt; <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> cout &lt;&lt; <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">FORLL</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&amp;<span class="number">1</span>) cout &lt;&lt; <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期杭电多校02</title>
      <link href="/posts/ACM_2023Summer_HDU02.html"/>
      <url>/posts/ACM_2023Summer_HDU02.html</url>
      
        <content type="html"><![CDATA[<h1>1002.Binary Number</h1><p><strong>字符串、贪心</strong></p><h2 id="题意">题意</h2><p>给定一段长度为$n$的01串，首位保证为1<br>任选定其中任意长的一段并将其反转<br>必须执行以上操作$k$次，求操作后得到的01串表示的二进制数最大的状态并输出</p><h2 id="解题思路">解题思路</h2><p>首先考虑<strong>次数不足</strong>的情况。对于一个二进制数，高位的权重大于其所有低位权重之和。因此优先考虑将靠前的字符中的0反转为1。</p><p>接下来比较多次反转<strong>不同方案</strong>的优劣。忽略操作次数限制，考虑这个字符串：1001001001</p><ol><li>最直观的办法是直接选定第2-3,5-6,8-9位反转为1，得到全1串。</li><li>还有一种可选的优质方法:1001001001 $\Rightarrow$ 1110110111 $\Rightarrow$ 11100111 $\Rightarrow$ 1111111111</li></ol><p>上述两种方法对于同样3段的0，次数相同，并且第一种方法更便于考虑，故采取第一种策略，从左往右反转0。</p><p>接下来再考虑已经转化为全1串，<strong>次数溢出</strong>的情况。可以考虑在转换过程中做无效操作浪费次数，避免对最大结果造成影响。</p><ol><li>对于起始01串，如果有0必有前导1(首位保证为1)。因此可以在反转某段0时带上前导1一起，再消耗1次操作单独转回前导1，可以浪费1次数</li><li>对于单个1做2次反转操作，可以浪费2次数</li><li>对于连续的2个1，分两次单独反转这两个1，然后一起翻回，可以浪费3次数</li></ol><p>在以上策略的搭配下，正常情况下可以消耗任意溢出次数，并最终状态为全1</p><p>最后考虑<strong>特殊情况</strong></p><ol><li>当起始01串全为1，且$k=1$，此时只能反转末位1使损失最小</li><li>当01串长度为1，此时起始01串只能是&quot;1&quot;，其状态只由$k$的奇偶决定</li></ol><p>(P.S.)谁赛时程序中把’='写成&quot;==&quot;又不想Remake于是卡签一个半小时我不说</p><h3 id="时间复杂度">时间复杂度</h3><p>$O(n)$</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s,re;</span><br><span class="line">    ll n,k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    s.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    ll flag=<span class="number">0</span>,all1=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">0</span>&amp;&amp;k) &#123;k--;flag=<span class="number">1</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) re.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> re.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            all1=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            re.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>&amp;&amp;all1) re[n<span class="number">-1</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>((k%<span class="number">2</span>)&amp;&amp;n==<span class="number">1</span>) re[<span class="number">0</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1004.Card Game</h1><p><strong>思维题</strong></p><h2 id="题意-2">题意</h2><p>游戏规则和汉诺塔类似<br>有 $n$ 根柱子，起始在第1根柱子上从下到上摆放着编号 $k,k-1,\cdots,2,1$ 的卡牌<br>规定：每根柱子只能从下到上放编号<strong>连续且递减</strong>的卡牌<br>每次操作可以将一根柱子上的最顶端的卡牌移动到其他柱子上（且不能违反规定）<br>求对于给定的柱子根数 $n$ ，可以实现将第一根柱子上所有牌移动到第二根柱子上的最大卡牌张数 $k$</p><h2 id="解题思路-2">解题思路</h2><p>这道题可以采用逆向思维。<br>起始态和最终态同构，拆解和合并过程对称，考虑从中间关键步骤分解顺推：</p><ol><li>将最大点数的卡牌从 柱子$1$ 转移到 柱子$2$</li><li>此时有 $1$ 个空位，可以将牌数为 $2$ 的柱子（假设他们恰好是次大的）拆分合并到柱子 $2$ ，并产生一个新的空位……</li><li>每次完全合并一个柱子，就会多一个空位，空位多的状态包含了空位少的状态。考虑状态转移关系：<ol><li>记：利用 $x$ 个空位可以转移到目标柱子的最大牌数为 $f(x)$<br>显然： $f(0)=1$</li><li>假设目前有个 $x$ 空位，对于本轮要转移的柱子，可以先借用一个空位存储上半部分较小卡牌。存储数量为  $f(x-1)$ ，因为存储本身需要占用一个空位</li><li>利用剩余 $x-1$ 个空位，最多可以转移并合并 $f(x-1)$ 张卡牌到柱子 $2$</li><li>再利用剩余 $x-1$ 个空位，将存储的 $f(x-1)$ 张卡牌到柱子 $2$</li><li>综3.1-3.4，可以得到 $f(x)$ 的递推式： $f(x)=2f(x-1)$<br>并求得 $f(x)=2^n$</li></ol></li><li>第一步可以看作：利用 $0$ 个空位，将最大点数的卡牌从 柱子$1$ 转移到 柱子$2$<br>最后一步可以看作：利用 $n-2$ 个空位，将最后一堆卡牌从转移到 柱子$2$<br>中途每一步产生 $1$ 个空位<br>由此得到结果：</li></ol><p>$$\begin{align}<br>k<br>&amp;=\sum\limits_{i=0}^{n-2} f(i) \newline<br>&amp;=1+2+\cdots+2^{n-2} \newline<br>&amp;=2^{n-1}-1<br>\end{align}<br>$$</p><p>快速幂斩了</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Get_Mod</span>(<span class="built_in">qcpow</span>(<span class="number">2</span>,n<span class="number">-1</span>)<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//快速幂代码略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1>1007.foreverlasting and fried-chicken</h1><p><strong>图论、枚举</strong></p><h2 id="题意-3">题意</h2><p>给定一个无权无向图 $G=(V,E),|V|=n,|E|=m$<br>求图中包含以下子图的数量：<br><img src="/images/ACM/2023Summer_HDU02_1007.png" alt="Img"></p><h2 id="解题思路-3">解题思路</h2><p>对于这个子图，有一个度为4的点和一个度为6的点，他们有4个公共邻居。借助这个特征，在给定无向图中找点</p><p>构图，在过程中记录每个点的度数 $deg_i$</p><p>对于每个 $deg_1\ge6$ 的点 $v_1$ ，枚举 $deg_2\ge4$ 的点 $v_2$<br>计算公共邻居个数，记为 $nbr$<br>对于 $v_1,v_2$ ，其含有上述子图个数为：$C_{nbr}^4 \cdot C_{deg_1-4}^2$<br>（注意：如果  $v_1,v_2$ 相连，这条边是不允许被构入子图的，计算的度是要减去1）</p><p>计算每一对 $v_1,v_2$ 的个数之和即可</p><h3 id="时间复杂度-2">时间复杂度</h3><p>朴素的做法的时间复杂度是 $O(n^3)$ （会有人T到飞起）<br>考虑用bitset对图进行状态压缩，降低求 $nbr$ 的时间复杂度<br>最终时间复杂度为  $O(\dfrac{n^3}{\omega})$</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ll C[<span class="number">1005</span>][<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//在主函数中预处理组合数C，代码略</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    bitset&lt;1005&gt; G[<span class="number">1005</span>];</span><br><span class="line">    <span class="type">int</span> deg[<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ll u,v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].<span class="built_in">set</span>(v);</span><br><span class="line">        G[v].<span class="built_in">set</span>(u);</span><br><span class="line">        deg[u]++;deg[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll re=<span class="number">0</span>,nbr,deg1,deg2;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(deg[i]&gt;=<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,i+<span class="number">1</span>,n) <span class="keyword">if</span>(j-i&amp;&amp;deg[j]&gt;=<span class="number">4</span>)&#123;</span><br><span class="line">            deg1=deg[i]-G[i][j];</span><br><span class="line">            deg2=deg[j]-G[i][j];</span><br><span class="line">            <span class="comment">//如果vi,vj直接相连，这条边是不能构入的</span></span><br><span class="line">            nbr=(G[i]&amp;G[j]).<span class="built_in">count</span>();</span><br><span class="line">            <span class="keyword">if</span>(nbr&gt;=<span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(deg1&gt;=<span class="number">6</span>) re=<span class="built_in">add</span>(re,<span class="built_in">mul</span>(C[nbr][<span class="number">4</span>],C[deg1<span class="number">-4</span>][<span class="number">2</span>]));</span><br><span class="line">                <span class="keyword">if</span>(deg2&gt;=<span class="number">6</span>) re=<span class="built_in">add</span>(re,<span class="built_in">mul</span>(C[nbr][<span class="number">4</span>],C[deg2<span class="number">-4</span>][<span class="number">2</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1009.String Problem</h1><p><strong>字符串、签到</strong></p><h2 id="题意-4">题意</h2><p>给定一个字符串 $S$，仅包含小写字母<br>在其中选择 $S$ 的 $k$ 个回文非空子串，且它们成对不相交，可以得到等同于 所选子串的长度之和减去子串数量 的分数：$\sum\limits_{i=1}^k len(s_i) -k$<br>为了<s>让这道题成为签到题</s>《增加题目难度》，所选子串最多包含一个字符，求对于给定字符串，可以获得的最高分数</p><h2 id="解题思路-4">解题思路</h2><p>在增加难度后，<s>很难想到</s>所选的每一子串就是连续相同字符<br>答案即给定字符串长度减去连续相同字符段数</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    ll len=s.<span class="built_in">size</span>();</span><br><span class="line">    ll cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,len<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]!=s[i<span class="number">-1</span>]) &#123;cnt++;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; len-cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期杭电多校01</title>
      <link href="/posts/ACM_2023Summer_HDU01.html"/>
      <url>/posts/ACM_2023Summer_HDU01.html</url>
      
        <content type="html"><![CDATA[<h1>1002.City Upgrading</h1><p><strong>树形DP、支配集</strong></p><h2 id="题意">题意</h2><p>crazyzhk居住在一个树形城市。有一天，这个城市的网络需要升级。为了实现这一目标，需要部署路由器。<br>每个路由器可以覆盖其所在的节点及其相邻节点，在节点 $i$ 上放置一个路由器的成本是 $a_i$<br>确保每个节点都得到覆盖的情况下，成本最低是多少</p><h3 id="前置知识点">前置知识点</h3><ul><li><a href="https://oi-wiki.org/dp/tree/">树形DP</a></li><li><a href="https://baike.baidu.com/item/%E6%94%AF%E9%85%8D%E9%9B%86/3187787">支配集</a>：给定无向图 $G=(V,E)$ ，称 $V$ 的一个子集 $S$ 为支配集，当且仅当对于 $V-S$ 中任何一个点 $v$ ，都有 $S$ 中的某个点 $u$ ，使得 $(u,v) \in E$</li></ul><h2 id="解题思路">解题思路</h2><p>要实现信号全覆盖，所选取的点集必须是一个<strong>支配集</strong><br>题目求的是所有支配集中最小的cost，考虑<strong>树形DP</strong></p><p>构造DP数组<code>dp[N][3]</code>:</p><ol><li><code>dp[i][0]</code>表示点 $i$ 属于支配集合，并且以点 $i$ 为根的子树都被覆盖了的情况下，支配集中所包含最少cost</li><li><code>dp[i][1]</code>表示点 $i$ 不属于支配集合，且以 $i$ 为根的子树都被覆盖，且 $i$ 被其不少于一个子节点覆盖的情况下，支配集所包含最少cost</li><li><code>dp[i][2]</code>表示点 $i$ 不属于支配集合，且以 $i$ 为根的子树都被覆盖，且 $i$ 没被子节点覆盖（将被父节点覆盖）的情况下，支配集中所包含最少cost</li></ol><p>结合最小支配集的贪心思想，按<strong>DFS序的逆序</strong>进行DP，节点 $i$ 的子节点记为 $u$</p><p>对于第一种状态，<code>dp[i][0]</code>含义为点 $i$ 属于支配集合，那么依次取每个儿子节点三种状态中的最小值，再把取得的最小值全部加起来再加1，就是dp<code>[i][0]</code>的值了。即只要每个以 $i$ 的儿子为根的子树都被覆盖，再加上当前点 $i$ ，所需要的最少cost，DP转移方程如下：<br>$$<br>dp[i][0] = 1 + ∑min(dp[u][0], dp[u][1], dp[u][2])<br>$$<br>对于第三种状态，<code>dp[i][2]</code>含义为点 $i$ 不属于支配集合，且 $i$ 被其父节点覆盖。那么说明点 $i$ 和点 $i$ 的儿子节点都不属于支配集合，所以点 $i$ 的第三种状态之和其儿子节点的第二种状态有关，方程为：<br>$$<br>dp[i][2] =∑dp[u][1]<br>$$<br>对于第二种状态，略有些复杂。<br>首先如果点 $i$ 没有子节点那么<code>dp[i][1]</code>应该初始化为INF；否则为了保证它的每个以 $i$ 的儿子为根的子树被覆盖，那么要取每个儿子节点的前两种状态的最小值之和，因为此时点 $i$ 不属于支配集，不能支配其子节点，所以子节点必须已经被支配，与子节点的第三种状态无关。<br>如果当前所选状态中每个儿子都没被选择进入支配集，即在每个儿子的前两种状态中，第一种状态都不是所需点最小的，那么为了满足第二种状态的定义(因为点 $i$ 的第二种状态必须被其子节点覆盖，即其子节点必须有一个属于支配集，如果此时没有，就必须强制使一个子节点的状态为状态一)，需要重新选择点 $i$ 的一个儿子节点为第一种状态，这时取花费最少的一个点，即取<code>min(dp[u][0] - dp[u][1])</code>的儿子节点 $u$ ，强制取其第一种状态，其他的儿子节点取第二种状态，DP转移方程为:<br>$$dp[i][1] = \begin{cases}<br>INF ，i没有子节点 \newline<br>∑min(dp[u][0], dp[u][1]) + inc ，Otherwise \newline<br>\end{cases} \newline<br>$$<br>$$<br>其中，inc = \begin{cases}<br>0 ，上式的Otherwise中至少选择了一次状态一的子节点 \newline<br>min(dp[u][0] - dp[u][1]) ，Otherwise<br>\end{cases} \newline<br>$$</p><p>结果为根节点三个状态中的最小值</p><h3 id="时间复杂度">时间复杂度</h3><p>$O(nlogn)$</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 2005</span></span><br><span class="line">vector&lt;vector&lt;ll&gt;&gt; T;</span><br><span class="line">vector&lt;ll&gt; cost;</span><br><span class="line">vector&lt;ll&gt; DFS_vec;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(ll node)</span></span>&#123;</span><br><span class="line">    DFS_vec.<span class="built_in">emplace_back</span>(node);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:T[node]) <span class="built_in">DFS</span>(i);</span><br><span class="line">&#125;<span class="comment">//获取DFS遍历序列</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    T.<span class="built_in">clear</span>();T.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    cost.<span class="built_in">clear</span>();cost.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; cost[i];</span><br><span class="line">    ll u,v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        T[u].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    DFS_vec.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">ALL</span>(DFS_vec));<span class="comment">//逆序</span></span><br><span class="line">    <span class="comment">//print_vec(DFS_vec);</span></span><br><span class="line">    </span><br><span class="line">    ll dp[N][<span class="number">3</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:DFS_vec)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=cost[i];</span><br><span class="line">        dp[i][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[i][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:T[i])</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]+=<span class="built_in">min</span>(&#123;dp[j][<span class="number">0</span>],dp[j][<span class="number">1</span>],dp[j][<span class="number">2</span>]&#125;);</span><br><span class="line">            dp[i][<span class="number">2</span>]+=dp[j][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(T[i].<span class="built_in">empty</span>()) dp[i][<span class="number">1</span>]=INF;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> flag=<span class="number">1</span>;ll inc=INF;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j:T[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j][<span class="number">0</span>]&lt;=dp[j][<span class="number">1</span>]) &#123;dp[i][<span class="number">1</span>]+=dp[j][<span class="number">0</span>];flag=<span class="number">0</span>;&#125;</span><br><span class="line">                <span class="keyword">else</span> dp[i][<span class="number">1</span>]+=dp[j][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> j:T[i]) inc=<span class="built_in">min</span>(&#123;inc,dp[u][<span class="number">0</span>]-dp[u][<span class="number">1</span>]&#125;);</span><br><span class="line">                dp[i][<span class="number">1</span>]+=inc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll re=<span class="built_in">min</span>(&#123;dp[<span class="number">1</span>][<span class="number">0</span>],dp[<span class="number">1</span>][<span class="number">1</span>]&#125;);</span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1005.Cyclically Isomorphic</h1><p><strong>字符串匹配</strong></p><h2 id="题意-2">题意</h2><p>对于两个字符串 $s_1$ , $s_2$ ，如果存在一个整数 $k$ 使得 $s_1$ 循环右移k位与 $s_2$ 相同，则称他们是&quot;cyclically right-shifted&quot;。<br>每组数据给出 $n$ 个长度为 $m$ 的字符串， $Q$ 次询问两个字符串是否&quot;cyclically right-shifted&quot;。</p><h2 id="解题思路-2">解题思路</h2><p>对于每一字符串，找到其字典序最小的状态储存，每次询问时直接比较即可。<br>主要是时间复杂度难以证明</p><h3 id="时间复杂度-2">时间复杂度</h3><p>找最小态储存 $n \times m^2$ ，比较 $Q \times m$<br>$Q \le \dfrac{1}{2} n(n-1) \Rightarrow$ 比较 $m \times n^2$<br>总复杂度： $O(mn \times (m+n))$ ，<br>$mn \le 10^5$ 下<s>数据不变态的话</s>就能卡过去</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s[N],s1,s2;</span><br><span class="line">    <span class="type">char</span> t;</span><br><span class="line">    ll n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s1;</span><br><span class="line">        s2=s1;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,m)</span><br><span class="line">        &#123;</span><br><span class="line">            t=s2.<span class="built_in">front</span>();</span><br><span class="line">            s2.<span class="built_in">erase</span>(s2.<span class="built_in">begin</span>());</span><br><span class="line">            s2.<span class="built_in">push_back</span>(t);</span><br><span class="line">            <span class="keyword">if</span>(s1.<span class="built_in">compare</span>(s2)&gt;<span class="number">0</span>) s1=s2;</span><br><span class="line">        &#125;</span><br><span class="line">        s[i]=s1;</span><br><span class="line">    &#125;</span><br><span class="line">    ll Q;cin &gt;&gt; Q;</span><br><span class="line">    <span class="keyword">while</span>(Q--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">if</span>(s[n].<span class="built_in">compare</span>(s[m])==<span class="number">0</span>) cout &lt;&lt; YES;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; NO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1009.Assertion</h1><p><strong>签到题</strong></p><h2 id="题意-3">题意</h2><p>多组数据<br>给定m件物品，分成n组<br>问：是否无论怎么分都至少有一组个数超过d</p><h2 id="解题思路-3">解题思路</h2><p>平均分组，找最大那个组的个数和d比较</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n,d;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;</span><br><span class="line">    <span class="keyword">if</span>((m<span class="number">-1</span>)/n+<span class="number">1</span>&gt;=d) cout &lt;&lt; YES;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; NO;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期牛客多校01</title>
      <link href="/posts/ACM_2023Summer_NCD01.html"/>
      <url>/posts/ACM_2023Summer_NCD01.html</url>
      
        <content type="html"><![CDATA[<h1>D.Chocolate</h1><p><strong>博弈题</strong></p><h2 id="题意">题意</h2><p>有一块大小为n*m的巧克力，起始坐标为(1,1)</p><p>每次操作可以选择一个坐标(a,b)，并吃掉(1,1):(a,b)中的所有巧克力</p><p>每次操作必须吃掉至少一块巧克力，吃掉最后一块巧克力的玩家输</p><h2 id="解题思路">解题思路</h2><p><strong>1*1</strong>：显然先行必输</p><p><strong>其他</strong>：对于总数m*n。若总数为奇数，则先行开局吃偶数个，若总数为偶数，则先行开局吃奇数个。<br>然后剩余个数变为奇数个，后续每一步，先行者都保证吃完后剩余奇数个巧克力且行数/列数多于1,或1*1（可以证明在任何状态下，一定有一种这样的操作）。</p><p>先行必胜</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>&amp;&amp;m==<span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;Walk Alone&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Kelin&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>H.Matches</h1><p><strong>二分、包络</strong></p><h2 id="题意-2">题意</h2><p>给定两个长度为 $n$ 的序列 $a,b$ ，定义他们之间的距离为对应元素差的绝对值之和，即：<br>$$<br>\sum\limits_{i=1}^n |a_i-b_i|<br>$$<br>可以对其中一个序列交换两个数，问至多操作一次后的最小距离。</p><h2 id="解题思路-2">解题思路</h2><p>绝对值的本质就是数轴上区间的大小，把每一对元素看作一个区间，就能将问题转化。</p><p>对于某一个区间， $a_i,b_i$ 决定它自身的正反序</p><p>对于某两个区间：<br>覆盖区域有 相交、包络、不交 三种相对关系<br>正反序有 正序、反序 两种相对关系<br>组合之下便有6种相对关系</p><p>针对两个区间的相对关系的转换，展开以下分类讨论<br>1.正序相交 $\rightleftarrows$ 正序包络<img src="/images/ACM/2023Summer_NCD01_H_1.png" alt="Img"><br>2.正序不交 $\rightleftarrows$ 反序包络<img src="/images/ACM/2023Summer_NCD01_H_2.png" alt="Img"><br>3.反序不交 $\rightleftarrows$ 反序相交<img src="/images/ACM/2023Summer_NCD01_H_3.png" alt="Img"></p><p>可以看到绝对值减小的情况只有两种：<br>1.反序相交 $\Rightarrow$ 反序不交<br>2.反序包络 $\Rightarrow$ 正序不交<br>它们对距离的减少量都是重叠区间大小的两倍</p><p>综上所述，只需要找出反序相交和反序包络的情况中，重叠区间最大的情况，即可得到答案。</p><p>对于输入数据，可以先按照 $a_i,b_i$ 的相对大小，将正序区间和反序区间分别存入两个容器，记为 $S,T$ ，并算出初始值 $sum$<br>对 $S$ 进行预处理，按照区间起点排序，去除被正序包络的区间（不难证明，被正序包络的区间对答案的贡献一定不大于正序包络它的区间）<br>对于 $T$ 中的每个区间，二分查找 $S$ 中与它有交集的区间，求出重叠区间大小的最大值 $dif$</p><p>最终答案为 $sum-2\times dif$</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,sum=<span class="number">0</span>,dif=<span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;pll&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cin &gt;&gt; v[i].first;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cin &gt;&gt; v[i].second;</span><br><span class="line">    vector&lt;pll&gt; S,T;</span><br><span class="line">    vector&lt;ll&gt; Sx,Sy,len;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [a,b]:v)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=<span class="built_in">abs</span>(a-b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a&lt;b) S.<span class="built_in">emplace_back</span>(a,b);</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b) T.<span class="built_in">emplace_back</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SORT</span>(S);</span><br><span class="line">    ll r=-INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p:S)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p.second&lt;=r) <span class="keyword">continue</span>;</span><br><span class="line">        r=p.second;</span><br><span class="line">        Sx.<span class="built_in">emplace_back</span>(p.first);</span><br><span class="line">        Sy.<span class="built_in">emplace_back</span>(p.second);</span><br><span class="line">        len.<span class="built_in">emplace_back</span>(p.second-p.first);</span><br><span class="line">    &#125;<span class="comment">//消除S中被正向包络的区间。算法决定Sy递增。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> finddif=[&amp;](ll x,ll y)&#123;<span class="comment">//对于给定的区间</span></span><br><span class="line">        ll m=Sx.<span class="built_in">size</span>(),re=<span class="number">0</span>;</span><br><span class="line">        ll l=<span class="built_in">upper_bound</span>(<span class="built_in">ALL</span>(Sx),x)-Sx.<span class="built_in">begin</span>();</span><br><span class="line">        ll r=<span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(Sy),y)-Sy.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="comment">//查找该区间在S中的位置</span></span><br><span class="line">        <span class="keyword">if</span>(l&gt;<span class="number">0</span>) re=<span class="built_in">max</span>(re,<span class="built_in">min</span>(Sy[l<span class="number">-1</span>],y)-x);<span class="comment">//反序相交1</span></span><br><span class="line">        <span class="keyword">if</span>(r&lt;m) re=<span class="built_in">max</span>(re,y-<span class="built_in">max</span>(Sx[r],x));<span class="comment">//反序相交2</span></span><br><span class="line">        <span class="keyword">if</span>(r&gt;l) re=<span class="built_in">max</span>(re,*<span class="built_in">max_element</span>(len.<span class="built_in">begin</span>()+l,len.<span class="built_in">begin</span>()+r));<span class="comment">//反序包络</span></span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [x,y]:T) dif=<span class="built_in">max</span>(dif,<span class="built_in">finddif</span>(x,y));</span><br><span class="line">    cout &lt;&lt; sum-dif*<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1>J.Roulette</h1><p><strong>数学题</strong></p><h2 id="题意-3">题意</h2><p>初始有 $n$ 元钱，目标为赢得 $m$ 元钱（即共 $n+m$ 元钱）<br>每次投注 $x$ 元，有50%的概率输掉，50%的概率赢得 $2x$ 元<br>第一局投注 $1$ 元，接下来的每局按下述策略投注：<br>$$\begin{cases}<br>x_i=1 , \text{ 上一局赢了} \newline<br>x_i=2 \times x_{i−1} ， \text{ 上一局输了}<br>\end{cases}$$<br>如果某局剩下的钱不足以按上述策略投注，则失败退场<br>问达成目标的概率有多大</p><h2 id="解题思路-3">解题思路</h2><p>投注采用的是<strong>倍投法</strong>，考虑每一轮投注为：输若干局直到赢一局</p><ol><li>第一局就赢了，则获得 $1$ 元</li><li>第 $n$ 局赢了，则获得 $2^{n-1} - (2^{n-2}+2^{n-3}+\cdots+2+1)=1$ 元</li></ol><p>综上，<strong>每一轮赢取的钱数固定为 $1$ 元</strong></p><p>根据题意，直到输到无法投注才失败，则对于每轮投注</p><ol><li>失败的概率为： $\dfrac{1}{2^a}$</li><li>成功的概率为： $1-\dfrac{1}{2^a}$</li></ol><p>其中 $a$ 是这轮投注的局数<br>那么对于整个投注过程，成功的概率为：$\prod\limits_{i=n}^{n+m-1} (1-\dfrac{1}{2^{a_i}})$</p><p>考虑本金与可以进行的投注轮数的关系，进行第a轮至少需要的本金为：<br>$1+2+\cdots+2^{a-1}=2^a-1$<br>以此为边界对集合 ${n,n+1,\cdots,m+n-1}$ 做划分（划分内投注轮数相同，成功率相同），分别计算每个划分的成功率，再相乘得到结果</p><h3 id="时间复杂度">时间复杂度</h3><p>划分数 $\log n$，快速幂等操作 $\log n$，总复杂度 $O(\log^2n)$</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">998244353</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Get_Mod(x) ((x)%MOD)</span></span><br><span class="line"><span class="function">ll <span class="title">QuickPow</span><span class="params">(ll x,ll y)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=<span class="built_in">Get_Mod</span>(x*ans);</span><br><span class="line">        x=<span class="built_in">Get_Mod</span>(x*x);</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Get_Inv</span><span class="params">(ll a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QuickPow</span>(a,MOD<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ll a,b,c;</span><br><span class="line">    ll base=<span class="number">0</span>,t=(n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//base存储当前划分的投注轮数</span></span><br><span class="line">    <span class="keyword">while</span>(t)&#123;</span><br><span class="line">        base++;</span><br><span class="line">        t&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll l=n,r=<span class="built_in">pow</span>(<span class="number">2</span>,base+<span class="number">1</span>)<span class="number">-2</span>;</span><br><span class="line">    <span class="comment">//l,r分别记录当前划分的左右边界</span></span><br><span class="line">    ll re=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(m+n&lt;=r)<span class="comment">//所有操作数都在一个划分中，则m+n-1作为右边界</span></span><br><span class="line">    &#123;</span><br><span class="line">        a=<span class="built_in">QuickPow</span>(<span class="number">2</span>,base);</span><br><span class="line">        b=<span class="built_in">Get_Mod</span>(<span class="built_in">Get_Mod</span>(a+MOD<span class="number">-1</span>)*<span class="built_in">Get_Inv</span>(a));</span><br><span class="line">        <span class="comment">//b为等比数列求和</span></span><br><span class="line">        c=<span class="built_in">QuickPow</span>(b,m);<span class="comment">//这个划分共m局游戏</span></span><br><span class="line">        re=<span class="built_in">Get_Mod</span>(re*c);</span><br><span class="line">        base++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;=m+n<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a=<span class="built_in">QuickPow</span>(<span class="number">2</span>,base);</span><br><span class="line">            b=<span class="built_in">Get_Mod</span>(<span class="built_in">Get_Mod</span>(a+MOD<span class="number">-1</span>)*<span class="built_in">Get_Inv</span>(a));</span><br><span class="line">            c=<span class="built_in">QuickPow</span>(b,r-l+<span class="number">1</span>);<span class="comment">//完全的划分共r-l+1局游戏</span></span><br><span class="line">            re=<span class="built_in">Get_Mod</span>(re*c);</span><br><span class="line"></span><br><span class="line">            base++;</span><br><span class="line">            l=<span class="built_in">pow</span>(<span class="number">2</span>,base)<span class="number">-1</span>;</span><br><span class="line">            r=<span class="built_in">pow</span>(<span class="number">2</span>,base+<span class="number">1</span>)<span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;m+n)</span><br><span class="line">        &#123;</span><br><span class="line">            a=<span class="built_in">QuickPow</span>(<span class="number">2</span>,base);</span><br><span class="line">            b=<span class="built_in">Get_Mod</span>(<span class="built_in">Get_Mod</span>(a+MOD<span class="number">-1</span>)*<span class="built_in">Get_Inv</span>(a));</span><br><span class="line">            c=<span class="built_in">QuickPow</span>(b,m+n-l);<span class="comment">//最后一个的划分共m+n-l局游戏</span></span><br><span class="line">            re=<span class="built_in">Get_Mod</span>(re*c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>K.Subdivision</h1><p><strong>图论-BFS最短路</strong></p><h2 id="题意-4">题意</h2><p>给定一个无权无向图 $G=(V,E),|V|=n,|E|=m$</p><p>每次操作可以选定一条边，在其中插入一个点使其分裂成两条边</p><p>问操作任意次数后，与点 $v_1$ 距离不大于 $k$ 的点至多有多少个</p><h2 id="解题思路-4">解题思路</h2><p>对于无向图 $G$ ，以点 $v_1$ 为根，用BFS确定最短路，刻画BFS树</p><p>可以很容易得到以下结论：<br>1.不在BFS树上的边可以无限分裂，对BFS树上点的距离无影响<br>2.分裂操作对答案有贡献的情况是：这条边至少有一个端点的距离 $dist_i$ 小于 $k$ 。从端点的角度，分裂这条边的最大贡献是 $k-dist_i$</p><p>那么可以对BFS树上的点进行分类讨论：<br>1.在图上具有除父节点外的其他邻节点：分裂以它为端点的树边，或导致其它邻节点到根的距离增大，对答案有损失。故只允许它在非树上的有效边上分裂<br>2.在图上没有除父节点外的其他邻节点：允许其在回溯的树边上分裂，对答案没有损失，只有贡献</p><p>我赛时写的程序和标程其实差不多，只是后面想歪了写了个图存储BFS树然后卡死在那了//<br>所以本篇参考程序后半部分<s>照抄</s>借鉴了标程，并加入了对BFS的优化：<br>由于距离 $dist_i$ 大于 $k$ 的点 $v_i$ 上一定没有对答案有贡献的边（这是最短路的特性决定的，不难证明），BFS只需搜索完 $dist_i$ 小于等于 $k$ 的点并加入BFS树即可，在 $k&lt;&lt;n$ 的情况下可以大幅减少BFS时间</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">G</span>(n+<span class="number">1</span>);</span><br><span class="line">    ll u,v; pll tpll;</span><br><span class="line">    vector&lt;ll&gt;::iterator it;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">        G[v].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;ll&gt; q;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">dist</span><span class="params">(n+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;<span class="comment">//记录最短路长度</span></span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">pre</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;<span class="comment">//记录BFS树上点的前驱</span></span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">leaf</span><span class="params">(n + <span class="number">1</span>,<span class="number">0</span>)</span></span>;<span class="comment">//0表示叶子节点（无子节点）</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//BFS最短路</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()&amp;&amp;dist[q.<span class="built_in">front</span>()]&lt;k)<span class="comment">//优化</span></span><br><span class="line">    &#123;</span><br><span class="line">        u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v: G[u])&#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[v]!=<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(v);</span><br><span class="line">            dist[v]=dist[u]+<span class="number">1</span>;</span><br><span class="line">            pre[v]=u;</span><br><span class="line">            leaf[u]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll re=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dist[i]==<span class="number">-1</span>||dist[i]&gt;k) <span class="keyword">continue</span>;</span><br><span class="line">        ll cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:G[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(p==pre[i]||i==pre[p]) <span class="keyword">continue</span>;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;<span class="comment">//对于非叶子节点，在非树上的有效边上分裂</span></span><br><span class="line">        <span class="keyword">if</span> (!leaf[i]) cnt = <span class="built_in">max</span>(cnt, <span class="number">1ll</span>);</span><br><span class="line">        <span class="comment">//对于叶子节点，如果没有其他邻节点(cnt==0)，允许其在回溯的树边上分裂</span></span><br><span class="line">        re+=(k-dist[i])*cnt+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SYの算法竞赛宏定义</title>
      <link href="/posts/Model_CPP_Head.html"/>
      <url>/posts/Model_CPP_Head.html</url>
      
        <content type="html"><![CDATA[<h1>CPP-Head</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------Consts----------*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> INF=<span class="number">0x3fffffffffffffff</span>;</span><br><span class="line"><span class="comment">/*----------Consts----------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt; pll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> DEFINITION</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> scanfll(a) scanf(<span class="string">&quot;%lld&quot;</span>,&amp;a)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> ALL(A) (A).begin(),(A).end()</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SORT(A) sort(ALL(A))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SORT_REV(A) sort((A).rbegin(),(A).rend())</span></span><br><span class="line">    <span class="comment">//SORT BEFORE UNIQUE!!</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UNIQUE(A) A.erase(unique(ALL(A)),A.end())</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> Presentation(i,r) <span class="string">&quot; \n&quot;</span>[i==r]</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> FORLL(i,l,r) for(ll i=l;i&lt;=r;i++)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> FORLL_rev(i,r,l) for(ll i=r;i&gt;=l;i--)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> NO cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> YES cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span> <span class="comment">//交互题不启用！</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> CCLIB</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> create_vec(v,n) vector<span class="string">&lt;ll&gt;</span> v(n);for(auto &amp;x:v) cin &gt;&gt; x;</span></span><br><span class="line">    ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> pair&lt;ll,ll&gt; &amp;p) &#123;out &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; p.first &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; p.second &lt;&lt; <span class="string">&#x27;)&#x27;</span>;<span class="keyword">return</span> out;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩欧返回d=gcd(a,b);x,y对应ax+by=d的解;通解为x=x0+k*b/d,y=y0-k*a/d;</span></span><br><span class="line">    <span class="function">ll <span class="title">Exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span> </span>&#123;<span class="keyword">if</span>(a==<span class="number">0</span>&amp;&amp;b==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="keyword">if</span>(b==<span class="number">0</span>) &#123;x=<span class="number">1</span>;y=<span class="number">0</span>;<span class="keyword">return</span> a;&#125; ll d=<span class="built_in">Exgcd</span>(b,a%b,y,x); y-=a/b*x; <span class="keyword">return</span> d;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">chmax</span><span class="params">(T &amp;a,T b)</span></span>&#123;<span class="keyword">if</span>(a&lt;b) a=b;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">chmin</span><span class="params">(T &amp;a,T b)</span></span>&#123;<span class="keyword">if</span>(a&gt;b) a=b;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">print_vec</span><span class="params">(<span class="type">const</span> T &amp;A)</span></span>&#123;<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:A) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;cout &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">print_float</span><span class="params">(T value,<span class="type">int</span> digit=<span class="number">10</span>)</span></span>&#123;cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(digit) &lt;&lt; value;&#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;ll&gt; snums;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Get_Nums</span><span class="params">(string s)</span></span>&#123; snums.<span class="built_in">clear</span>(); ll n=s.<span class="built_in">length</span>();ll t=<span class="number">0</span>;<span class="type">int</span> flag=<span class="number">0</span>; <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(s[i]&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;s[i]&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;t*=<span class="number">10</span>;t+=s[i]-<span class="string">&#x27;0&#x27;</span>;flag++;&#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag)&#123;snums.<span class="built_in">emplace_back</span>(t);t=<span class="number">0</span>;flag=<span class="number">0</span>;&#125; <span class="keyword">if</span>(flag)&#123;snums.<span class="built_in">emplace_back</span>(t);t=<span class="number">0</span>;flag=<span class="number">0</span>;&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MODULE</span><br><span class="line">&#123;</span><br><span class="line">    ll MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">Get_Mod</span><span class="params">(ll x,ll mod=MOD)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> x-x/mod*mod+mod;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x-x/mod*mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">qcpow</span><span class="params">(ll a,ll b,ll p=MOD)</span></span>&#123;ll ret=<span class="number">1</span>;a=<span class="built_in">Get_Mod</span>(a);<span class="keyword">for</span> (;b;b&gt;&gt;=<span class="number">1</span>,a=a*a%p) <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret=ret*a%p;<span class="keyword">return</span> ret;&#125;</span><br><span class="line">    <span class="function">ll <span class="title">inv</span><span class="params">(ll a,ll p=MOD)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">qcpow</span>(a,p<span class="number">-2</span>,p);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">add</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">Get_Mod</span>(a+b);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">sub</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">Get_Mod</span>(a-b);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">mul</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">Get_Mod</span>(a*b);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addto</span><span class="params">(ll &amp;a,ll b)</span></span>&#123;a=<span class="built_in">Get_Mod</span>(a+b);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">subto</span><span class="params">(ll &amp;a,ll b)</span></span>&#123;a=<span class="built_in">Get_Mod</span>(a-b);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">multo</span><span class="params">(ll &amp;a,ll b)</span></span>&#123;a=<span class="built_in">Get_Mod</span>(a*b);&#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; C;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Prepare_Combination</span><span class="params">(ll n)</span></span>&#123; C.<span class="built_in">clear</span>(); C.<span class="built_in">resize</span>(n+<span class="number">1</span>); C[<span class="number">0</span>].<span class="built_in">emplace_back</span>(<span class="number">1</span>); <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123; C[i].<span class="built_in">emplace_back</span>(<span class="number">1</span>); <span class="built_in">FORLL</span>(j,<span class="number">1</span>,i<span class="number">-1</span>) C[i].<span class="built_in">emplace_back</span>(<span class="built_in">add</span>(C[i<span class="number">-1</span>][j<span class="number">-1</span>],C[i<span class="number">-1</span>][j])); C[i].<span class="built_in">emplace_back</span>(<span class="number">1</span>); &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> DEFINITION;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> CCLIB;</span><br><span class="line"><span class="comment">// using namespace MODULE;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAST_IO</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUTIPLE_JUDGE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------Code Area----------*/</span></span><br><span class="line"><span class="type">const</span> ll N = <span class="number">200005</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Prepare_Combination(5005);</span></span><br><span class="line">    <span class="comment">// MOD = 1e9+7;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*----------Code Area----------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="type">clock_t</span> clk = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;1.in&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;1.out&quot;</span>)</span></span>;</span><br><span class="line">    streambuf *cinbackup;</span><br><span class="line">    cinbackup = cin.<span class="built_in">rdbuf</span>(ifs.<span class="built_in">rdbuf</span>());</span><br><span class="line">    streambuf *coutbackup;</span><br><span class="line">    coutbackup = cout.<span class="built_in">rdbuf</span>(ofs.<span class="built_in">rdbuf</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> FAST_IO</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>); cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MUTIPLE_JUDGE</span></span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="built_in">prepare</span>();</span><br><span class="line"><span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    cin.<span class="built_in">rdbuf</span>(cinbackup);</span><br><span class="line">    cout.<span class="built_in">rdbuf</span>(coutbackup);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">clock</span>() - clk &lt;&lt; <span class="string">&quot; ms\n&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码/模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法与外挂标签写法汇总</title>
      <link href="/posts/Tutor_Markdown.html"/>
      <url>/posts/Tutor_Markdown.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://www.fomal.cc/posts/2013454d.html">https://www.fomal.cc/posts/2013454d.html</a></p></blockquote><h1>1.Markdown语法自带格式</h1><div class="note info flat"><p>参考：<a href="https://blog.csdn.net/u014061630/article/details/81359144">Markdown语法图文全面详解(10分钟学会)</a></p></div><div class="note warning flat"><p>注意：此页面偶尔会存在CSS冲突问题!</p></div><h2 id="1-1-代码块">1.1 代码块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\```shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br><span class="line">\```</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-2-多级标题">1.2 多级标题</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>见本文章标题!</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-3-文字样式">1.3 文字样式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线演示<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">文字<span class="strong">**加粗**</span>演示</span><br><span class="line"></span><br><span class="line">文字<span class="emphasis">*斜体*</span>演示</span><br><span class="line"></span><br><span class="line">文本<span class="code">`高亮`</span>演示</span><br><span class="line"></span><br><span class="line">文本~~删除~~线演示</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">5</span>&gt;</span></span>5号字<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>黑体<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span></span>蓝色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">MistyRose</span>&gt;</span></span>这里的背景色是：MistyRosen，此处输入任意想输入的内容<span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><u>下划线演示</u></p><p>文字<strong>加粗</strong>演示</p><p>文字<em>斜体</em>演示</p><p>文本<code>高亮</code>演示</p><p>文本<s>删除</s>线演示</p><p><font size = 5>5号字</font><br><font face="黑体">黑体</font><br><font color=blue>蓝色</font></p><table><tr><td bgcolor=MistyRose>这里的背景色是：MistyRosen，此处输入任意想输入的内容</td></tr></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="note info flat"><p>上述要点可参考:<a href="https://blog.csdn.net/qq_43732429/article/details/108034518">【Markdown语法】字体颜色大小及文字底色设置</a></p></div><h2 id="1-4-引用">1.4 引用</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt;  Java</span></span><br><span class="line"><span class="quote">&gt; 二级引用演示</span></span><br><span class="line"><span class="quote">&gt; MySQL</span></span><br><span class="line"><span class="quote">&gt; &gt;外键</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;事务</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;<span class="strong">**行级锁**</span>(引用内部一样可以用格式)</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; ....</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><blockquote><p>Java<br>二级引用演示<br>MySQL</p><blockquote><p>外键</p><p>事务</p><p><strong>行级锁</strong>(引用内部一样可以用格式)</p></blockquote><p>…</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-5-分割线">1.5 分割线</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><hr><hr><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-6-列表-跟空格都可以">1.6 列表(*,+,-跟空格都可以)</h2><h3 id="1-6-1-无序列表">1.6.1 无序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> Java</span><br><span class="line"><span class="bullet">*</span> Python</span><br><span class="line"><span class="bullet">*</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> Java</span><br><span class="line"><span class="bullet">+</span> Python</span><br><span class="line"><span class="bullet">+</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Java</span><br><span class="line"><span class="bullet">-</span> Python</span><br><span class="line"><span class="bullet">-</span> ...</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-6-2-有序列表">1.6.2 有序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 注意后面有空格</span></span><br><span class="line"><span class="bullet">1.</span> </span><br><span class="line"><span class="bullet">2.</span> </span><br><span class="line"><span class="bullet">3.</span> </span><br><span class="line"><span class="bullet">4.</span> </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li></li><li></li><li></li><li></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-7-图片">1.7 图片</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 本地图片</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/pusheencode.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="section"># 在线图片</span></span><br><span class="line">![<span class="string">code</span>](<span class="link">https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>本地图片:<br><img src="/assets/pusheencode.webp" alt="示例图片" style="zoom:50%;" /><br>在线图片:<br><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png" alt="code"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-8-表格">1.8 表格</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目标号 | 资金     | 备注 |</span><br><span class="line">| -------- | -------- | ---- |</span><br><span class="line">| 1        | 100，000 | 无   |</span><br><span class="line">| 2        | 200，000 | 无   |</span><br><span class="line">| 3        | 300,600  | 重要 |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th>项目标号</th><th>资金</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>100，000</td><td>无</td></tr><tr><td>2</td><td>200，000</td><td>无</td></tr><tr><td>3</td><td>300,600</td><td>重要</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-9-公式">1.9 公式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z)=\int<span class="emphasis">_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt.</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>$$<br>\Gamma(z)=\int_0^\infty t^{z-1}e^{-t}dt.<br>$$</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1>2.Butterfly外挂标签</h1><div class="note info flat"><p>这部分参考安知鱼:<a href="https://anzhiy.cn/posts/7d58.html">基于Butterfly的外挂标签引入</a></p></div><h2 id="2-1-行内文本样式-text">2.1 行内文本样式 text</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% u 文本内容 %&#125;</span><br><span class="line">&#123;% emp 文本内容 %&#125;</span><br><span class="line">&#123;% wavy 文本内容 %&#125;</span><br><span class="line">&#123;% del 文本内容 %&#125;</span><br><span class="line">&#123;% kbd 文本内容 %&#125;</span><br><span class="line">&#123;% psw 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 带 &#123;% u 下划线 %&#125; 的文本</span><br><span class="line"><span class="bullet">2.</span> 带 &#123;% emp 着重号 %&#125; 的文本</span><br><span class="line"><span class="bullet">3.</span> 带 &#123;% wavy 波浪线 %&#125; 的文本</span><br><span class="line"><span class="bullet">4.</span> 带 &#123;% del 删除线 %&#125; 的文本</span><br><span class="line"><span class="bullet">5.</span> 键盘样式的文本 &#123;% kbd command %&#125; + &#123;% kbd D %&#125;</span><br><span class="line"><span class="bullet">6.</span> 密码样式的文本：&#123;% psw 这里没有验证码 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><ol><li>带 <u>下划线</u> 的文本</li><li>带 <emp>着重号</emp> 的文本</li><li>带 <wavy>波浪线</wavy> 的文本</li><li>带 <del>删除线</del> 的文本</li><li>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></li><li>密码样式的文本：<psw>这里没有验证码</psw></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-2-行内文本-span">2.2 行内文本 span</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% span 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% span red, 红色 %&#125;、&#123;% span yellow, 黄色 %&#125;、&#123;% span green, 绿色 %&#125;、&#123;% span cyan, 青色 %&#125;、&#123;% span blue, 蓝色 %&#125;、&#123;% span gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% span center logo large, Volantis %&#125;</span><br><span class="line">&#123;% span center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<span class='p red'>红色</span>、<span class='p yellow'>黄色</span>、<span class='p green'>绿色</span>、<span class='p cyan'>青色</span>、<span class='p blue'>蓝色</span>、<span class='p gray'>灰色</span>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<br><span class='p center logo large'>Volantis</span><br><span class='p center small'>A Wonderful Theme for Hexo</span></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-3-段落文本-p">2.3 段落文本 p</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% p 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% p red, 红色 %&#125;、&#123;% p yellow, 黄色 %&#125;、&#123;% p green, 绿色 %&#125;、&#123;% p cyan, 青色 %&#125;、&#123;% p blue, 蓝色 %&#125;、&#123;% p gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% p center logo large, Volantis %&#125;</span><br><span class="line">&#123;% p center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<p class='p red'>红色</p>、<p class='p yellow'>黄色</p>、<p class='p green'>绿色</p>、<p class='p cyan'>青色</p>、<p class='p blue'>蓝色</p>、<p class='p gray'>灰色</p>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。</li></ul><p class='p center logo large'>Volantis</p><p class='p center small'>A Wonderful Theme for Hexo</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-4-引用note">2.4 引用note</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">通用配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">语法格式</button></li><li class="tab"><button type="button" data-href="#分栏-3">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-4">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-5">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: simple</span><br><span class="line">  icons: false</span><br><span class="line">  border<span class="emphasis">_radius: 3</span></span><br><span class="line"><span class="emphasis">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line"><span class="emphasis">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line"><span class="emphasis">  light_</span>bg<span class="emphasis">_offset: 0</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 自带icon</span></span><br><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"><span class="section"># 外部icon</span></span><br><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.自带icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / primary / success / info / warning / danger ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】不显示 icon</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><p>2.外部icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / blue / pink / red / purple / orange / green ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note modern %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note disabled %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default no-icon %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success no-icon %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info no-icon %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning no-icon %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger no-icon %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; simple%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; simple %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; simple %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; modern%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; flat%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; disabled %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; disabled %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; disabled %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; disabled %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; disabled %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue no-icon %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink no-icon %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red no-icon %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple no-icon %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green no-icon %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-5"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note simple"><p>默认 提示块标签</p></div><div class="note default simple"><p>default 提示块标签</p></div><div class="note primary simple"><p>primary 提示块标签</p></div><div class="note success simple"><p>success 提示块标签</p></div><div class="note info simple"><p>info 提示块标签</p></div><div class="note warning simple"><p>warning 提示块标签</p></div><div class="note danger simple"><p>danger 提示块标签</p></div>2.`modern`样式<div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div><p>3.<code>flat</code>样式</p><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><p>4.<code>disabled</code>样式</p><div class="note disabled"><p>默认 提示块标签</p></div><div class="note default disabled"><p>default 提示块标签</p></div><div class="note primary disabled"><p>primary 提示块标签</p></div><div class="note success disabled"><p>success 提示块标签</p></div><div class="note info disabled"><p>info 提示块标签</p></div><div class="note warning disabled"><p>warning 提示块标签</p></div><div class="note danger disabled"><p>danger 提示块标签</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>默认 提示块标签</p></div><div class="note default no-icon flat"><p>default 提示块标签</p></div><div class="note primary no-icon flat"><p>primary 提示块标签</p></div><div class="note success no-icon flat"><p>success 提示块标签</p></div><div class="note info no-icon flat"><p>info 提示块标签</p></div><div class="note warning no-icon flat"><p>warning 提示块标签</p></div><div class="note danger no-icon flat"><p>danger 提示块标签</p></div>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note icon-padding simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding simple"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding simple"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding simple"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding simple"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>2.<code>modern</code>样式</p><div class="note icon-padding modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding modern"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding modern"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>3.<code>flat</code>样式</p><div class="note icon-padding flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>4.<code>disabled</code>样式</p><div class="note icon-padding disabled"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding disabled"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding disabled"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding disabled"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding disabled"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding disabled"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding disabled"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue no-icon flat"><p>2021年快到了…</p></div><div class="note pink no-icon flat"><p>小心开车 安全至上</p></div><div class="note red no-icon flat"><p>这是三片呢？还是四片？</p></div><div class="note orange no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple no-icon flat"><p>剪刀石头布</p></div><div class="note green no-icon flat"><p>前端最讨厌的浏览器</p></div>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-5-上标标签-tip">2.5 上标标签 tip</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: success,error,warning,bolt,ban,home,sync,cogs,key,bell</li><li><code>自定义图标</code>: 支持fontawesome。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip %&#125;default&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip info %&#125;info&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip success %&#125;success&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip error %&#125;error&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip warning %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bolt %&#125;bolt&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban %&#125;ban&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip home %&#125;home&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip sync %&#125;sync&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip cogs %&#125;cogs&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip key %&#125;key&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bell %&#125;bell&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip fa-atom %&#125;自定义font awesome图标&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="tip "><p>default</p></div><div class="tip info"><p>info</p></div><div class="tip success"><p>success</p></div><div class="tip error"><p>error</p></div><div class="tip warning"><p>warning</p></div><div class="tip bolt"><p>bolt</p></div><div class="tip ban"><p>ban</p></div><div class="tip home"><p>home</p></div><div class="tip sync"><p>sync</p></div><div class="tip cogs"><p>cogs</p></div><div class="tip key"><p>key</p></div><div class="tip bell"><p>bell</p></div><div class="tip fa-atom"><p>自定义font awesome图标</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-6-动态标签-anima">2.6 动态标签 anima</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><div class="note info flat"><ol><li>将所需的CSS类添加到图标（或DOM中的任何元素）。</li><li>对于父级悬停样式，需要给目标元素添加指定CSS类，同时还要给目标元素的父级元素添加CSS类<code>faa-parent animated-hover</code>。（详情见示例及示例源码）<br>You can regulate the speed of the animation by adding the CSS class or . faa-fastfaa-slow</li><li>可以通过给目标元素添加CSS类<code>faa-fast</code>或<code>faa-slow</code>来控制动画快慢。</li></ol></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.On DOM load（当页面加载时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>2.调整动画速度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated faa-fast %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated faa-slow %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>3.On hover（当鼠标悬停时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated-hover %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated-hover %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>4.On parent hover（当鼠标悬停在父级元素时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-horizontal&quot;</span>&gt;</span></span>warning<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-flash&quot;</span>&gt;</span></span>ban<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.On DOM load（当页面加载时显示动画）</p><div class="tip warning faa-horizontal animated"><p>warning</p></div><div class="tip ban faa-flash animated"><p>ban</p></div>2.调整动画速度<div class="tip warning faa-horizontal animated faa-fast"><p>warning</p></div><div class="tip ban faa-flash animated faa-slow"><p>ban</p></div>3.On hover（当鼠标悬停时显示动画）<div class="tip warning faa-horizontal animated-hover"><p>warning</p></div><div class="tip ban faa-flash animated-hover"><p>ban</p></div>4.On parent hover（当鼠标悬停在父级元素时显示动画）<div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">warning</p></div><div class="tip ban faa-parent animated-hover"><p class="faa-flash">ban</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-7-复选列表-checkbox">2.7 复选列表 checkbox</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: plus, minus, times</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 纯文本测试 %&#125;</span><br><span class="line">&#123;% checkbox checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% checkbox red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox plus green checked, 增加 %&#125;</span><br><span class="line">&#123;% checkbox minus yellow checked, 减少 %&#125;</span><br><span class="line">&#123;% checkbox times red checked, 叉 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="checkbox" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>支持自定义颜色</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>绿色 + 默认选中</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>黄色 + 默认选中</p>            </div><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>青色 + 默认选中</p>            </div><div class='checkbox blue checked'><input type="checkbox" checked="checked"/>            <p>蓝色 + 默认选中</p>            </div><div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>            <p>增加</p>            </div><div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>            <p>减少</p>            </div><div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p>叉</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-8-单选列表-radio">2.8 单选列表 radio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 纯文本测试 %&#125;</span><br><span class="line">&#123;% radio checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% radio red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% radio green, 绿色 %&#125;</span><br><span class="line">&#123;% radio yellow, 黄色 %&#125;</span><br><span class="line">&#123;% radio cyan, 青色 %&#125;</span><br><span class="line">&#123;% radio blue, 蓝色 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="radio" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="radio" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="radio" />            <p>支持自定义颜色</p>            </div><div class='checkbox green'><input type="radio" />            <p>绿色</p>            </div><div class='checkbox yellow'><input type="radio" />            <p>黄色</p>            </div><div class='checkbox cyan'><input type="radio" />            <p>青色</p>            </div><div class='checkbox blue'><input type="radio" />            <p>蓝色</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-9-时间轴-timeline">2.9 时间轴 timeline</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间线标题（可选）[,color] %&#125;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>title</code>:标题/时间线</li><li><code>color</code>:<code>timeline</code>颜色:default(留空) / blue / pink / red / purple / orange / green</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间轴样式,blue %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-07-24 [<span class="string">2.6.6 -&gt; 3.0</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 如果有 <span class="code">`hexo-lazyload-image`</span> 插件，需要删除并重新安装最新版本，设置 <span class="code">`lazyload.isSPA: true`</span>。</span><br><span class="line"><span class="bullet">2.</span> 2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <span class="code">`use_cdn: true`</span> 则需要删除。</span><br><span class="line"><span class="bullet">3.</span> 2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</span><br><span class="line"><span class="bullet">4.</span> 2.x 版本的置顶 <span class="code">`top: true`</span> 改为了 <span class="code">`pin: true`</span>，并且同样适用于 <span class="code">`layout: page`</span> 的页面。</span><br><span class="line"><span class="bullet">5.</span> 如果使用了 <span class="code">`hexo-offline`</span> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-05-15 [<span class="string">2.6.3 -&gt; 2.6.6</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6</span>) --&gt;</span><br><span class="line"></span><br><span class="line">不需要额外处理。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-04-20 [<span class="string">2.6.2 -&gt; 2.6.3</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 全局搜索 <span class="code">`seotitle`</span> 并替换为 <span class="code">`seo_title`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的索引规则有变，使用 group 组件的文章内，<span class="code">`group: group_name`</span> 对应的组件名必须是 <span class="code">`group_name`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的列表名优先显示文章的 <span class="code">`short_title`</span> 其次是 <span class="code">`title`</span>。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴样式</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></div></div><div class='timeline-item-content'><ol><li>如果有 <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>。</li><li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除。</li><li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li><li>2.x 版本的置顶 <code>top: true</code> 改为了 <code>pin: true</code>，并且同样适用于 <code>layout: page</code> 的页面。</li><li>如果使用了 <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></div></div><div class='timeline-item-content'><p>不需要额外处理。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p></div></div><div class='timeline-item-content'><ol><li>全局搜索 <code>seotitle</code> 并替换为 <code>seo_title</code>。</li><li>group 组件的索引规则有变，使用 group 组件的文章内，<code>group: group_name</code> 对应的组件名必须是 <code>group_name</code>。</li><li>group 组件的列表名优先显示文章的 <code>short_title</code> 其次是 <code>title</code>。</li></ol></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-10-链接卡片-link">2.10 链接卡片 link</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 标题, 链接, 图片链接（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 糖果屋教程贴, https://akilar.top/posts/615e2dec/, https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="tag link"><a class="link-card" title="糖果屋教程贴" href="https://akilar.top/posts/615e2dec/"><div class="left"><img src="https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico"/></div><div class="right"><p class="text">糖果屋教程贴</p><p class="url">https://akilar.top/posts/615e2dec/</p></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-11-按钮-btns">2.11 按钮 btns</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns 样式参数 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>圆角样式：rounded, circle</li><li>增加文字样式：可以在容器内增加 <code>&lt;b&gt;</code>标题<code>&lt;/b&gt;</code>和<code>&lt;p&gt;</code>描述文字<code>&lt;/p&gt;</code></li><li>布局方式：<br>默认为自动宽度，适合视野内只有一两个的情况。</li></ol><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>wide</td><td>宽一点的按钮</td></tr><tr><td>fill</td><td>填充布局，自动铺满至少一行，多了会换行</td></tr><tr><td>center</td><td>居中，按钮之间是固定间距</td></tr><tr><td>around</td><td>居中分散</td></tr><tr><td>grid2</td><td>等宽最多2列，屏幕变窄会适当减少列数</td></tr><tr><td>grid3</td><td>等宽最多3列，屏幕变窄会适当减少列数</td></tr><tr><td>grid4</td><td>等宽最多4列，屏幕变窄会适当减少列数</td></tr><tr><td>grid5</td><td>等宽最多5列，屏幕变窄会适当减少列数</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle grid5 %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>2.或者含有图标的按钮</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns rounded grid5 %&#125;</span><br><span class="line">&#123;% cell 下载源码, /, fas fa-download %&#125;</span><br><span class="line">&#123;% cell 查看文档, /, fas fa-book-open %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle center grid5 %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p red, 专业版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p green, 免费版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><div class="btns circle grid5">            <a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a>          </div>2.或者含有图标的按钮<div class="btns rounded grid5">            <a class="button" href='/' title='下载源码'><i class='fas fa-download'></i>下载源码</a><a class="button" href='/' title='查看文档'><i class='fas fa-book-open'></i>查看文档</a>          </div>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中<div class="btns circle center grid5">            <a href='https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p red'>专业版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png'></a><a href='https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p green'>免费版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png'></a>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-12-github卡片-ghcard">2.12 github卡片 ghcard</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% ghcard 用户名, 其它参数（可选） %&#125;</span><br><span class="line">&#123;% ghcard 用户名/仓库, 其它参数（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>使用<code>,</code>分割各个参数。写法为：<code>参数名=参数值</code><br>以下只写几个常用参数值。</p><table><thead><tr><th><strong>参数名</strong></th><th>取值</th><th>释义</th></tr></thead><tbody><tr><td>hide</td><td>stars,commits,prs,issues,contribs</td><td>隐藏指定统计</td></tr><tr><td>count_private</td><td>true</td><td>将私人项目贡献添加到总提交计数中</td></tr><tr><td>show_icons</td><td>true</td><td>显示图标</td></tr><tr><td>theme</td><td>查阅:<a href="https://github.com/anuraghazra/github-readme-stats/blob/master/themes/README.md">Available Themes</a></td><td>主题</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.用户信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard fomalhaut1998 %&#125; | &#123;% ghcard fomalhaut1998, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=buefy %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=onedark %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=algolia %&#125; | &#123;% ghcard fomalhaut1998, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><p>2.仓库信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=buefy %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=onedark %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=algolia %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.用户信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=calm&show_owner=true"/></a></td></tr></tbody></table><p>2.仓库信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=calm&show_owner=true"/></a></td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-13-github徽标-ghbdage">2.13 github徽标 ghbdage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage [right],[left],[logo]||[color],[link],[title]||[option] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>left</code>：徽标左边的信息，必选参数。</li><li><code>right</code>: 徽标右边的信息，必选参数，</li><li><code>logo</code>：徽标图标，图标名称详见<a href="https://simpleicons.org/">simpleicons</a>，可选参数。</li><li><code>color</code>：徽标右边的颜色，可选参数。</li><li><code>link</code>：指向的链接，可选参数。</li><li><code>title</code>：徽标的额外信息，可选参数。主要用于优化SEO，但<code>object</code>标签不会像<code>a</code>标签一样在鼠标悬停显示<code>title</code>信息。</li><li><code>option</code>：自定义参数，支持<a href="https://shields.io/">shields.io</a>的全部API参数支持，具体参数可以参看上文中的拓展写法示例。形式为<code>name1=value2&amp;name2=value2</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.基本参数,定义徽标左右文字和图标</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Theme,Butterfly %&#125;</span><br><span class="line">&#123;% bdage Frame,Hexo,hexo %&#125;</span><br></pre></td></tr></table></figure><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage CDN,JsDelivr,jsDelivr||abcdef,https://metroui.org.ua/index.html,本站使用JsDelivr为静态资源提供CDN加速 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割</span><br><span class="line">&#123;% bdage Source,GitHub,GitHub||,https://github.com/ %&#125;</span><br></pre></td></tr></table></figure><p>3.拓展参数，支持shields的API的全部参数内容</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Hosted,Vercel,Vercel||brightgreen,https://vercel.com/,本站采用双线部署，默认线路托管于Vercel||style=social&amp;logoWidth=20 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割</span><br><span class="line">&#123;% bdage Hosted,Vercel,Vercel||||style=social&amp;logoWidth=20&amp;logoColor=violet %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.基本参数,定义徽标左右文字和图标</p><p><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Butterfly-Theme-orange?logo=&color=orange&link=&"></object><br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Hexo-Frame-orange?logo=hexo&color=orange&link=&"></object></p><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><p><object class="ghbdage" style="margin-inline:5px" title="本站使用JsDelivr为静态资源提供CDN加速" standby="loading..." data="https://img.shields.io/badge/JsDelivr-CDN-orange?logo=jsDelivr&color=abcdef&link=https://metroui.org.ua/index.html&"></object><br>//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/GitHub-Source-orange?logo=GitHub&color=orange&link=https://github.com/&"></object></p><p>3.拓展参数，支持shields的API的全部参数内容</p><p><object class="ghbdage" style="margin-inline:5px" title="本站采用双线部署，默认线路托管于Vercel" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=brightgreen&link=https://vercel.com/&style=social&logoWidth=20"></object><br>//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=orange&link=&style=social&logoWidth=20&logoColor=violet"></object></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-14-网站卡片-sites">2.14 网站卡片 sites</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site xaoxuu, url=https://xaoxuu.com, screenshot=https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg, avatar=https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png, description=简约风格 %&#125;</span><br><span class="line">&#123;% site inkss, url=https://inkss.cn, screenshot=https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg, avatar=https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site MHuiG, url=https://blog.mhuig.top, screenshot=https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png, avatar=https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Colsrch, url=https://colsrch.top, screenshot=https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png, avatar=https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Linhk1606, url=https://linhk1606.github.io, screenshot=https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png, avatar=https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="site-card-group"><a class="site-card" href="https://fomalhaut1998.com"><div class="img"><img src="https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png"/><span class="title">fomalhaut1998</span><span class="desc">简约风格</span></div></a><a class="site-card" href="https://inkss.cn"><div class="img"><img src="https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg"/><span class="title">inkss</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://blog.mhuig.top"><div class="img"><img src="https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png"/><span class="title">MHuiG</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://colsrch.top"><div class="img"><img src="https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg"/><span class="title">Colsrch</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://linhk1606.github.io"><div class="img"><img src="https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png"/></div><div class="info"><img src="https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png"/><span class="title">Linhk1606</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-15-行内图片-inlineimage">2.15 行内图片 inlineimage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% inlineimage 图片链接, height=高度（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>高度</code>：height=20px</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif %&#125; 一段话。</span><br><span class="line"></span><br><span class="line">这又是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif, height=40px %&#125; 一段话。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>这是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif" style="height:1.5em"/> 一段话。</p><p>这又是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif" style="height:40px;"/> 一段话。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-16-单张图片-image">2.16 单张图片 image</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image 链接, width=宽度（可选）, height=高度（可选）, alt=描述（可选）, bg=占位颜色（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>图片宽度高度：width=300px, height=32px</li><li>图片描述：alt=图片描述（butterfly需要在主题配置文件中开启图片描述）</li><li>占位背景色：bg=#f2f2f2</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>2.指定宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px %&#125;</span><br></pre></td></tr></table></figure><p>3.指定宽度并添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>4.设置占位背景色：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, bg=#1D0C04, alt=优化不同宽度浏览的观感 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.添加描述：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>2..指定宽度<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" style="width:400px;"/></div></div>3.指定宽度并添加描述：<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。" style="width:400px;"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>4.设置占位背景色：<div class="img-wrap"><div class="img-bg" style="background:#1D0C04"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="优化不同宽度浏览的观感" style="width:400px;"/></div><span class="image-caption">优化不同宽度浏览的观感</span></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-17-音频-audio">2.17 音频 audio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio 音频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="audio"><audio controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-18-视频-video">2.18 视频 video</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video 视频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>对齐方向</code>：left, center, right</li><li><code>列数</code>：逗号后面直接写列数，支持 1 ～ 4 列。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.100%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br></pre></td></tr></table></figure><p>2.50%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 2 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><p>3.25%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 4 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.100%宽度</p><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>2.50%宽度<div class="videos" col='2'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div>3.25%宽度<div class="videos" col='4'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-19-相册-gallery">2.19 相册 gallery</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 圖片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>gallerygroup 相册图库</li></ul><table><thead><tr><th>参数名</th><th>释义</th></tr></thead><tbody><tr><td>name</td><td>图库名字</td></tr><tr><td>description</td><td>图库描述</td></tr><tr><td>link</td><td>链接到对应相册的地址</td></tr><tr><td>img-url</td><td>图库封面</td></tr></tbody></table><ul><li><p>gallery 相册</p><p>区别于旧版的Gallery相册,新的Gallery相册会自动根据图片长度进行排版，书写也更加方便，与markdown格式一样。可根据需要插入到相应的md。无需再自己配置长宽。<strong>建议在粘贴时故意使用长短、大小、横竖不一的图片</strong>，会有更好的效果。（尺寸完全相同的图片只会平铺输出，效果很糟糕）</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup MC 在Rikkaの六花服务器里留下的足迹 &#x27;/gallery/MC/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg %&#125;</span><br><span class="line">&#123;% galleryGroup Gundam 哦咧哇gundam哒！ &#x27;/gallery/Gundam/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png %&#125;</span><br><span class="line">&#123;% galleryGroup I-am-Akilar 某种意义上也算自拍吧 &#x27;/gallery/I-am-Akilar/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg</span>)</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg</span>)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.gallerygroup 相册图库</p><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">MC</div>  <p>在Rikkaの六花服务器里留下的足迹</p>  <a href='/gallery/MC/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">Gundam</div>  <p>哦咧哇gundam哒！</p>  <a href='/gallery/Gundam/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">I-am-Akilar</div>  <p>某种意义上也算自拍吧</p>  <a href='/gallery/I-am-Akilar/'></a>  </figcaption>  </figure></div>2.gallery 相册<div class="fj-gallery"><p><img src="https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg" alt=""></p>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-20-折叠框-folding">2.20 折叠框 folding</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 参数（可选）, 标题 %&#125;</span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><!-- tab 参数配置 --><ol><li><p><code>颜色</code>：blue, cyan, green, yellow, red</p></li><li><p><code>状态</code>：状态填写 open 代表默认打开。</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 查看图片测试 %&#125;</span><br><span class="line"></span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding cyan open, 查看默认打开的折叠框 %&#125;</span><br><span class="line"></span><br><span class="line">这是一个默认打开的折叠框。</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding green, 查看代码测试 %&#125;</span><br><span class="line">假装这里有代码块（代码块没法嵌套代码块）</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding yellow, 查看列表测试 %&#125;</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> haha</span><br><span class="line"><span class="bullet">-</span> hehe</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding red, 查看嵌套测试 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding blue, 查看嵌套测试2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding 查看嵌套测试3 %&#125;</span><br><span class="line"></span><br><span class="line">hahaha <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;height:24px&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><details class="folding-tag" ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg" alt=""></p>              </div>            </details><details class="folding-tag" cyan open><summary> 查看默认打开的折叠框 </summary>              <div class='content'>              <p>这是一个默认打开的折叠框。</p>              </div>            </details><details class="folding-tag" green><summary> 查看代码测试 </summary>              <div class='content'>              <p>假装这里有代码块（代码块没法嵌套代码块）</p>              </div>            </details><details class="folding-tag" yellow><summary> 查看列表测试 </summary>              <div class='content'>              <ul><li>haha</li><li>hehe</li></ul>              </div>            </details><details class="folding-tag" red><summary> 查看嵌套测试 </summary>              <div class='content'>              <details class="folding-tag" blue><summary> 查看嵌套测试2 </summary>              <div class='content'>              <details class="folding-tag" ><summary> 查看嵌套测试3 </summary>              <div class='content'>              <p>hahaha <span><img src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png' style='height:24px'></span></p>              </div>            </details>              </div>            </details>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-21-分栏-tab">2.21 分栏 tab</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>Unique name :</p><ul><li><p>选项卡块标签的唯一名称，不带逗号。</p></li><li><p>将在#id中用作每个标签及其索引号的前缀。</p></li><li><p>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</p></li><li><p>仅当前帖子/页面的URL必须是唯一的！</p></li></ul></li><li><p>[index]:</p><ul><li><p>活动选项卡的索引号。</p></li><li><p>如果未指定，将选择第一个标签（1）。</p></li><li><p>如果index为-1，则不会选择任何选项卡。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[Tab caption]:</p><ul><li><p>当前选项卡的标题。</p></li><li><p>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</p></li><li><p>如果未指定标题，但指定了图标，则标题将为空。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[@icon]:</p><ul><li><p>FontAwesome图标名称（全名，看起来像“ fas fa-font”）</p></li><li><p>可以指定带空格或不带空格；</p></li><li><p>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</p></li><li><p>可选参数。</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.Demo 1 - 预设选择第一个【默认】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>2.Demo 2 - 预设选择tabs</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test2, 3 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>3.Demo 3 - 没有预设值</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test3, -1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.Demo 1 - 预设选择第一个【默认】</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>2.Demo 2 - 预设选择tabs</p><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>3.Demo 3 - 没有预设值</p><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test3-1">test3 1</button></li><li class="tab"><button type="button" data-href="#test3-2">test3 2</button></li><li class="tab"><button type="button" data-href="#test3-3">test3 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test3-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-22-诗词标签-poem">2.22 诗词标签 poem</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><ol><li><code>title</code>：诗词标题</li><li><code>author</code>：作者，可以不写</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% poem 水调歌头,苏轼 %&#125;</span><br><span class="line">丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。</span><br><span class="line">明月几时有？把酒问青天。</span><br><span class="line">不知天上宫阙，今夕是何年？</span><br><span class="line">我欲乘风归去，又恐琼楼玉宇，高处不胜寒。</span><br><span class="line">起舞弄清影，何似在人间？</span><br><span class="line"></span><br><span class="line">转朱阁，低绮户，照无眠。</span><br><span class="line">不应有恨，何事长向别时圆？</span><br><span class="line">人有悲欢离合，月有阴晴圆缺，此事古难全。</span><br><span class="line">但愿人长久，千里共婵娟。</span><br><span class="line">&#123;% endpoem %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class='poem'><div class='poem-title'>水调歌头</div><div class='poem-author'>苏轼</div><p>丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。<br>明月几时有？把酒问青天。<br>不知天上宫阙，今夕是何年？<br>我欲乘风归去，又恐琼楼玉宇，高处不胜寒。<br>起舞弄清影，何似在人间？</p><p>转朱阁，低绮户，照无眠。<br>不应有恨，何事长向别时圆？<br>人有悲欢离合，月有阴晴圆缺，此事古难全。<br>但愿人长久，千里共婵娟。</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-23-阿里图标-icon">2.23 阿里图标 icon</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon [icon-xxxx],[font-size] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>icon-xxxx</code>：表示图标<code>font-class</code>,可以在自己的阿里矢量图标库项目的<code>font-class</code>引用方案内查询并复制。</li><li><code>font-size</code>：表示图标大小，直接填写数字即可，单位为<code>em</code>。图标大小默认值为<code>1em</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon icon-rat<span class="emphasis">_zi %&#125;&#123;% icon icon-rat,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-ox_</span>chou,3 %&#125;&#123;% icon icon-ox,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-tiger<span class="emphasis">_yin,5 %&#125;&#123;% icon icon-tiger,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rabbit_</span>mao,1 %&#125;&#123;% icon icon-rabbit,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dragon<span class="emphasis">_chen,3 %&#125;&#123;% icon icon-dragon,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-snake_</span>si,5 %&#125;&#123;% icon icon-snake,6 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-horse<span class="emphasis">_wu %&#125;&#123;% icon icon-horse,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-goat_</span>wei,3 %&#125;&#123;% icon icon-goat,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-monkey<span class="emphasis">_shen,5 %&#125;&#123;% icon icon-monkey,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rooster_</span>you %&#125;&#123;% icon icon-rooster,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dog<span class="emphasis">_xu,3 %&#125;&#123;% icon icon-dog,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-boar_</span>hai,5 %&#125;&#123;% icon icon-boar,6 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rat_zi"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rat"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-ox_chou"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-ox"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-tiger_yin"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-tiger"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rabbit_mao"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rabbit"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dragon_chen"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dragon"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-snake_si"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-snake"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-horse_wu"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-horse"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-goat_wei"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-goat"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-monkey_shen"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-monkey"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rooster_you"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rooster"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dog_xu"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dog"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-boar_hai"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-boar"></use></svg></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-24-特效标签wow">2.24 特效标签wow</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow [animete],[duration],[delay],[offset],[iteration] %&#125;</span><br><span class="line">内容</span><br><span class="line">&#123;% endwow %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>animate</code>: 动画样式，效果详见<a href="https://animate.style/">animate.css参考文档</a></li><li><code>duration</code>: 选填项，动画持续时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>delay</code>: 选填项，动画开始的延迟时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>offset</code>: 选填项，开始动画的距离（相对浏览器底部）</li><li><code>iteration</code>: 选填项，动画重复的次数</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.flip动画效果。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>3.slideInRight动画效果，持续5s，延时5s</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__slideInRight,5s,5s %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note orange &#x27;fas fa-car&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`slideInRight`动画效果，持续`5s`，延时`5s`。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__heartBeat,,5s,,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note red &#x27;fas fa-battery-half&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`heartBeat`动画效果，延时`5s`，重复`10`次。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.flip动画效果。</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>3.slideInRight动画效果，持续5s，延时5s</p><div class='wow animate__slideInRight' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='' ><div class="note orange icon-padding modern"><i class="note-icon fas fa-car"></i><p><code>slideInRight</code>动画效果，持续<code>5s</code>，延时<code>5s</code>。</p></div></div><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><div class='wow animate__heartBeat' data-wow-duration='' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='10' ><div class="note red icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p><code>heartBeat</code>动画效果，延时<code>5s</code>，重复<code>10</code>次。</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-25-进度条-progress">2.25  进度条 progress</h2><div class="note info flat"><p>进度条标签参考<a href="https://rongbuqiu.com/jdt.html">沂佰孜猫-给HEXO文章添加彩色进度条</a>。<br>源样式提取自<a href="https://zwying0814.gitbook.io/cuteen/">Cuteen</a>主题。</p></div><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress [width] [color] [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>width</code>: 0到100的阿拉伯数字</li><li><code>color</code>: 颜色，取值有red,yellow,green,cyan,blue,gray</li><li><code>text</code>:进度条上的文字内容</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress 10 red 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 30 yellow 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 50 green 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 70 cyan 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 90 blue 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 100 gray 进度条样式预览 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-red"  style="width: 10%" aria-valuenow="10" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-yellow"  style="width: 30%" aria-valuenow="30" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-green"  style="width: 50%" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-cyan"  style="width: 70%" aria-valuenow="70" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-blue"  style="width: 90%" aria-valuenow="90" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-gray"  style="width: 100%" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-26-注释-notation">2.26 注释 notation</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota [label] , [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p><code>label</code>: 注释词汇</p></li><li><p><code>text</code>: 悬停显示的注解内容</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota 把鼠标移动到我上面试试 ,可以看到注解内容出现在顶栏 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><span class='nota' data-nota='可以看到注解内容出现在顶栏'>把鼠标移动到我上面试试</span></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-27-气泡注释-bubble">2.27 气泡注释 bubble</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bubble [content] , [notation] ,[background-color] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>content</code>: 注释词汇</li><li><code>notation</code>: 悬停显示的注解内容</li><li><code>background-color</code>: 可选，气泡背景色。默认为“#71a4e3”</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的&#123;% bubble 兄弟相邻选择器,&quot;例如 h1 + p &#123;margin-top:50px;&#125;&quot; %&#125;，&#123;% bubble flex布局,&quot;Flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;,&quot;#ec5830&quot; %&#125;，&#123;% bubble transform变换,&quot;transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。&quot;,&quot;#1db675&quot; %&#125;，animation的&#123;% bubble 贝塞尔速度曲线,&quot;贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋&quot;,&quot;#de4489&quot; %&#125;写法，还有今天刚看到的&#123;% bubble clip-path,&quot;clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。&quot;,&quot;#868fd7&quot; %&#125;属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的<span class="bubble-content">兄弟相邻选择器</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#71a4e3;">例如 h1 + p {margin-top:50px;}</span></span>，<span class="bubble-content">flex布局</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#ec5830;">Flex 是 Flexible Box 的缩写，意为弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;</span></span>，<span class="bubble-content">transform变换</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#1db675;">transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。</span></span>，animation的<span class="bubble-content">贝塞尔速度曲线</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#de4489;">贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋</span></span>写法，还有今天刚看到的<span class="bubble-content">clip-path</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#868fd7;">clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。</span></span>属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-28-引用文献-reference">2.28 引用文献 reference</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% referto [id] , [literature] %&#125;</span><br><span class="line">&#123;% referfrom [id] , [literature] , [url] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>referto 引用上标</p><ul><li><p><code>id</code>: 上标序号内容，需与referfrom标签的id对应才能实现跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li></ul></li><li><p>referfrom 引用出处</p><ul><li><p><code>id</code>: 序号内容，需与referto标签的id对应才能实现 跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li><li><p><code>url</code>: 引用的参考文献链接，可省略</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Akilarの糖果屋(akilar.top)是一个私人性质的博客&#123;% referto &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27; %&#125;，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架&#123;% referto &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27; %&#125;，Butterfly主题&#123;% referto &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">本项目参考了Volantis&#123;% referto &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27; %&#125;的标签样式。引入<span class="code">`[tag].js`</span>，并针对<span class="code">`butterfly`</span>主题修改了相应的<span class="code">`[tag].styl`</span>。在此鸣谢<span class="code">`Volantis`</span>主题众开发者。</span><br><span class="line">主要参考内容包括各个volantis的内置标签插件文档&#123;% referto &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27; %&#125;</span><br><span class="line">Butterfly主题的各个衍生魔改&#123;% referto &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27; %&#125;&#123;% referto &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27; %&#125;&#123;% referto &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27; %&#125;&#123;% referto &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% referfrom &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27;,&#x27;https://jq.qq.com/?<span class="emphasis">_wv=1027&amp;k=pGLB2C0N&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27;,&#x27;https://hexo.io/zh-cn/docs/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27;,&#x27;https://butterfly.js.org/posts/21cfbf15/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27;,&#x27;https://volantis.js.org/v5/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27;,&#x27;https://volantis.js.org/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27;,&#x27;https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27;,&#x27;https://lovelijunyi.gitee.io/posts/c898.html&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27;,&#x27;https://github.com/l-lin/font-awesome-animation&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27;,&#x27;https://www.antmoe.com/posts/3b43914f/&#x27; %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>Akilarの糖果屋(akilar.top)是一个私人性质的博客<span class="hidden-anchor" id="referto_[1]"></span><sup class="reference"><a href="#referfrom_[1]">[1]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Akilarの糖果屋群聊简介</span><span class="reference-title">参考资料</span></span></span>，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架<span class="hidden-anchor" id="referto_[2]"></span><sup class="reference"><a href="#referfrom_[2]">[2]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Hexo中文文档</span><span class="reference-title">参考资料</span></span></span>，Butterfly主题<span class="hidden-anchor" id="referto_[3]"></span><sup class="reference"><a href="#referfrom_[3]">[3]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档(一) 快速开始</span><span class="reference-title">参考资料</span></span></span></p><p>本项目参考了Volantis<span class="hidden-anchor" id="referto_[4]"></span><sup class="reference"><a href="#referfrom_[4]">[4]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">hexo-theme-volantis 标签插件</span><span class="reference-title">参考资料</span></span></span>的标签样式。引入<code>[tag].js</code>，并针对<code>butterfly</code>主题修改了相应的<code>[tag].styl</code>。在此鸣谢<code>Volantis</code>主题众开发者。<br>主要参考内容包括各个volantis的内置标签插件文档<span class="hidden-anchor" id="referto_[5]"></span><sup class="reference"><a href="#referfrom_[5]">[5]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Volantis文档:内置标签插件</span><span class="reference-title">参考资料</span></span></span><br>Butterfly主题的各个衍生魔改<span class="hidden-anchor" id="referto_[6]"></span><sup class="reference"><a href="#referfrom_[6]">[6]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档:标签外挂（Tag Plugins</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[7]"></span><sup class="reference"><a href="#referfrom_[7]">[7]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小弋の生活馆全样式预览</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[8]"></span><sup class="reference"><a href="#referfrom_[8]">[8]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">l-lin-font-awesome-animation</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[9]"></span><sup class="reference"><a href="#referfrom_[9]">[9]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小康的butterfly主题使用文档</span><span class="reference-title">参考资料</span></span></span></p><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://jq.qq.com/?_wv=1027&k=pGLB2C0N">Akilarの糖果屋群聊简介</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://hexo.io/zh-cn/docs/">Hexo中文文档</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[3]"></span><a class="reference-anchor" href="#referto_[3]">[3]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安装文档(一) 快速开始</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[4]"></span><a class="reference-anchor" href="#referto_[4]">[4]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/v5/tag-plugins/">hexo-theme-volantis 标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[5]"></span><a class="reference-anchor" href="#referto_[5]">[5]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/tag-plugins/">Volantis文档:内置标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[6]"></span><a class="reference-anchor" href="#referto_[6]">[6]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89">Butterfly 安装文档:标签外挂（Tag Plugins</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[7]"></span><a class="reference-anchor" href="#referto_[7]">[7]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://lovelijunyi.gitee.io/posts/c898.html">小弋の生活馆全样式预览</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[8]"></span><a class="reference-anchor" href="#referto_[8]">[8]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/l-lin/font-awesome-animation">l-lin-font-awesome-animation</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[9]"></span><a class="reference-anchor" href="#referto_[9]">[9]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://www.antmoe.com/posts/3b43914f/">小康的butterfly主题使用文档</a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-29-PDF展示">2.29 PDF展示</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf 文件路径 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>文件路径</code>: 可以是相对路径或者是在线链接</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.本地文件:在md文件路径下创建一个同名文件夹，其内放pdf文件名为xxx.pdf的文件</span></span><br><span class="line">&#123;% pdf xxx.pdf %&#125;</span><br><span class="line"><span class="section"># 2.在线链接</span></span><br><span class="line">&#123;% pdf https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>2.在线链接(要放到最外层才能起作用)</p><pre><code>&lt;div class=&quot;row&quot;&gt;&lt;embed src=&quot;https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;application/pdf&quot;&gt;&lt;/div&gt;</code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-30-Hexo-tag-map-插件">2.30 Hexo-tag-map 插件</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% + 标签值 + 经度 + 纬度 + 文本 + 缩放等级 + 宽 + 高 + 默认图层 + %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th style="text-align:center">地图名</th><th style="text-align:center">标签值 &lt;必填&gt;</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">缩放等级 (默认 14)</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">默认图层 (默认 1)</th></tr></thead><tbody><tr><td style="text-align:center">混合地图</td><td style="text-align:center">map</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~7</td></tr><tr><td style="text-align:center">谷歌地图</td><td style="text-align:center">googleMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~20</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">高德地图</td><td style="text-align:center">gaodeMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">百度地图</td><td style="text-align:center">baiduMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 4~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~2</td></tr><tr><td style="text-align:center">Geoq 地图</td><td style="text-align:center">geoqMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~5</td></tr><tr><td style="text-align:center">openstreet 地图</td><td style="text-align:center">openstreetMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">不支持此参数</td></tr></tbody></table><ol><li>参数之间，用英文逗号相隔</li><li>参数必须按上述事例顺序输入，不得为空</li><li>同一个页面，同一组经纬度值，只能插入一个相同标签值的地图 (若有需要，可以将第二个地图上，经度或纬度末尾删除一两个数)</li><li>参数取值必须在上述范围内</li><li>默认图层：即地图叠加层的值，默认常规地图还是卫星地图，可按地图显示顺序取值</li><li>缩放等级，数字越大，地图比例尺越小，显示的越精细</li><li>除标签值外，其他参数选填，但 每个参数的左边的参数必填</li><li>谷歌地图需要外网才能加载查看</li></ol><p>坐标获取：<a href="https://lbs.amap.com/tools/picker">高德地图坐标拾取系统</a> 、<a href="https://api.map.baidu.com/lbsapi/getpoint/index.html">百度地图坐标拾取系统</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% map 120.101101,30.239119 %&#125;</span><br><span class="line">&#123;% googleMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！ %&#125;</span><br><span class="line">&#123;% geoqMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！, 13, 90%, 320px, 3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="map-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'});routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1,attribution:'Google Maps'});var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:21,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"智图地图":normalm1,"谷歌地图":normalMap,"高德卫星地图":imgm,"谷歌卫星地图":satelliteMap,"高德卫星标注":image,"谷歌卫星标注":routeMap};var mymap=L.map('map-120.101101-30.239119',{center:[30.239119,120.101101],zoom:14,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);</script><br><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="googleMap-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:22,minZoom:1,attribution:'Google Maps'});var baseLayers={"谷歌地图":normalMap,"谷歌卫星图":satelliteMap,"谷歌卫星标注": routeMap};var overlayLayers={};var mymap=L.map("googleMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:14,layers:[normalMap],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="geoqMap-120.101101-30.239119" style="max-width:90%; height:320px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm2=L.tileLayer.chinaProvider('Geoq.Normal.PurplishBlue',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm3=L.tileLayer.chinaProvider('Geoq.Normal.Gray',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm4=L.tileLayer.chinaProvider('Geoq.Normal.Warm',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm5=L.tileLayer.chinaProvider('Geoq.Theme.Hydro',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm1,normalm2,normalm3,normalm4,normalm5]);var baseLayers={"智图地图":normalm1,"午夜蓝":normalm2,"灰色":normalm3,"暖色":normalm4,"水系":normalm5};var mymap=L.map("geoqMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:13,layers:[normalm3],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-31-隐藏块">2.31 隐藏块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>content：要隐藏的内容</li><li>display：展示前按钮显示的文字（可选）</li><li>bg：按钮的背景颜色（可选）</li><li>color：按钮显示的文字的颜色（可选）</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock 点我预览, blue %&#125;</span><br><span class="line">这里有张图片：</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image (1)&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:67%;&quot;</span> /&gt;</span></span></span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="hide-block"><button type="button" class="hide-button" style="background-color:  blue;">点我预览    </button><div class="hide-content"><p>这里有张图片：<br><img src="https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb" alt="image (1)" style="zoom:67%;" /></p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 外挂标签 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
