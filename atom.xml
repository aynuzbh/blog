<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CCLMSY💫</title>
  
  
  <link href="http://www.cclmsy.cc/atom.xml" rel="self"/>
  
  <link href="http://www.cclmsy.cc/"/>
  <updated>2024-02-05T10:55:25.204Z</updated>
  <id>http://www.cclmsy.cc/</id>
  
  <author>
    <name>深翼💫</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>题解|2024牛客寒假02</title>
    <link href="http://www.cclmsy.cc/posts/f0bacdb9.html"/>
    <id>http://www.cclmsy.cc/posts/f0bacdb9.html</id>
    <published>2024-02-01T16:00:00.000Z</published>
    <updated>2024-02-05T10:55:25.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A"><a href="#A" class="headerlink" title="A."></a>A.</h1>]]></content>
    
    
    <summary type="html">题解|2024牛客寒假02</summary>
    
    
    
    <category term="算法竞赛" scheme="http://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024牛客寒假" scheme="http://www.cclmsy.cc/tags/2024%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024牛客寒假01</title>
    <link href="http://www.cclmsy.cc/posts/e5822278.html"/>
    <id>http://www.cclmsy.cc/posts/e5822278.html</id>
    <published>2024-02-01T16:00:00.000Z</published>
    <updated>2024-02-03T06:47:14.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-DFS搜索"><a href="#A-DFS搜索" class="headerlink" title="A.DFS搜索"></a>A.DFS搜索</h1><p><strong>1签</strong></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>题目字面意思，问能不能在长度为 $n$ 的字符串 $s$ 中找到子序列”DFS”和”dfs”；</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接暴力搜索<br>时间复杂度 $O(n)$</p><h2 id="参考程序"><a href="#参考程序" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s,s1,s2;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    s1=<span class="string">&quot;DFS&quot;</span>;s2=<span class="string">&quot;dfs&quot;</span>;</span><br><span class="line">    <span class="type">int</span> cnt1,cnt2;cnt1=cnt2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt1&lt;<span class="number">3</span>&amp;&amp;c==s1[cnt1]) cnt1++;</span><br><span class="line">        <span class="keyword">if</span>(cnt2&lt;<span class="number">3</span>&amp;&amp;c==s2[cnt2]) cnt2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt1&gt;=<span class="number">3</span>) cout &lt;&lt; <span class="number">1</span>; <span class="keyword">else</span> cout &lt;&lt; <span class="number">0</span>; cout &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(cnt2&gt;=<span class="number">3</span>) cout &lt;&lt; <span class="number">1</span>; <span class="keyword">else</span> cout &lt;&lt; <span class="number">0</span>; cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-关鸡"><a href="#B-关鸡" class="headerlink" title="B.关鸡"></a>B.关鸡</h1><p><strong>模拟</strong></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>有一条宽为$2$，长为$2*10^9+1$的管道，每个格子的坐标标记为$(x,y)$，$x\in[-10^9,10^9],y\in [1,2]$<br>管道内有$n$个障碍，给定障碍的坐标<br>鸡哥在$(0,1)$处，可以上下左右移动，但不能穿过障碍<br>求最少还需多少个障碍物才能使鸡哥被困在管道内无法到达管道两端</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>将管道两排看作两侧，如果某处有障碍（下图红），只要它的另一侧相邻的位置中有一个有障碍（下图黄）即可堵住管道：<br><img src="/images/ACM/2024Winter_NCD01_B.png" alt="alt text"><br>换个角度，从管道左端到右端，对于每个障碍，check它对面且与它的$x$距离不大于$1$的位置是否有障碍，即可确定是否堵住管道。</p><p>要把鸡哥困在管道内，需要把鸡哥两侧管道全都堵住。</p><p>对于鸡哥的一侧管道，如果：<br>  没有堵住，没有障碍，则需放置$2$个障碍；<br>  没有堵住，至少有$1$个障碍，则需放置$1$个障碍；<br>  已经堵住，则不需要放置障碍。</p><p>特别的，和鸡哥直接相邻的3个位置如果都有障碍，鸡哥就直接被困住了。</p><h2 id="参考程序-1"><a href="#参考程序-1" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;pll&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">int</span> f,fl,fr; f=fl=fr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:v)&#123;</span><br><span class="line">        cin &gt;&gt; x.second &gt;&gt; x.first; <span class="comment">// 为了方便排序，将x轴坐标放在前面</span></span><br><span class="line">        <span class="keyword">if</span>(x.first==<span class="number">-1</span>&amp;&amp;x.second==<span class="number">1</span>) f++;</span><br><span class="line">        <span class="keyword">if</span>(x.first==<span class="number">0</span>&amp;&amp;x.second==<span class="number">2</span>) f++;</span><br><span class="line">        <span class="keyword">if</span>(x.first==<span class="number">1</span>&amp;&amp;x.second==<span class="number">1</span>) f++;<span class="comment">//和鸡哥直接相邻的障碍数</span></span><br><span class="line">        <span class="keyword">if</span>(x.first&lt;=<span class="number">0</span>) fl=<span class="number">1</span>;<span class="comment">//鸡哥左侧有障碍</span></span><br><span class="line">        <span class="keyword">if</span>(x.first&gt;=<span class="number">0</span>) fr=<span class="number">1</span>;<span class="comment">//鸡哥右侧有障碍</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    <span class="type">int</span> ffl,ffr;ffl=ffr=<span class="number">0</span>;<span class="comment">//记录左右两侧是否被堵住</span></span><br><span class="line">    deque&lt;pll&gt; dq;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(dq.<span class="built_in">size</span>()&amp;&amp;v[i].first-dq.<span class="built_in">front</span>().first&gt;<span class="number">1</span>) dq.<span class="built_in">pop_front</span>();<span class="comment">//dq只保存[x-1,x]内的障碍</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:dq)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x.second!=v[i].second)&#123;<span class="comment">//如果有不同侧的障碍即堵住管道</span></span><br><span class="line">                <span class="keyword">if</span>(v[i].first&lt;=<span class="number">0</span>) ffl=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> ffr=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;dq.<span class="built_in">push_back</span>(v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">3</span>-f;<span class="comment">//直接围堵鸡哥</span></span><br><span class="line">    <span class="keyword">if</span>(ffl&amp;&amp;ffr) ans=<span class="built_in">min</span>(ans,<span class="number">0ll</span>);<span class="comment">//左右两侧都被堵住，无需添加</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ffl&amp;&amp;fr||fl&amp;ffr) ans=<span class="built_in">min</span>(ans,<span class="number">1ll</span>);<span class="comment">//一侧被堵住，另一侧有障碍，需要添加1个</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ffl||ffr) ans=<span class="built_in">min</span>(ans,<span class="number">2ll</span>);<span class="comment">//一侧被堵住，另一侧无障碍，需要添加2个</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(fl&amp;&amp;fr) ans=<span class="built_in">min</span>(ans,<span class="number">2ll</span>);<span class="comment">//两侧没被堵住，但有障碍，需要添加2个</span></span><br><span class="line">    <span class="comment">//其余情况不如直接围堵鸡哥</span></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-按闹分配"><a href="#C-按闹分配" class="headerlink" title="C.按闹分配"></a>C.按闹分配</h1><p><strong>贪心</strong></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>$n$个人在$1$个窗口前排队办事，第$i$个人办事需要时间$t_i$<br>开始为$0$时刻，每个人的不满意度$D_i$为其办完事的时刻$D_i$<br>工作人员安排队伍顺序使得所有人的不满意度之和 $S=\sum D_i$ 最小</p><p>你也来办事，需要时间$t_c$。你可以插队，但是因此增加的不满意度之和不能超过$M$<br>问你最早什么时候能办完事</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据贪心的思想，初始使得不满意度之和最小的排序是按照$t_i$从小到大排序<br>你插队导致的不满意度之和的增量为：你插队的位置之后的人数*你的办事时间<br>因此你后面的人数不得超过 $M/t_c$ 个<br>在这个约束下计算前缀和即可</p><h2 id="参考程序-2"><a href="#参考程序-2" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,Q,tc,M;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; Q &gt;&gt; tc;</span><br><span class="line">    <span class="built_in">create_vec</span>(t,n);</span><br><span class="line">    <span class="built_in">SORT</span>(t);</span><br><span class="line">    vector&lt;ll&gt; St;</span><br><span class="line">    St.<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) St.<span class="built_in">pb</span>(St.<span class="built_in">back</span>()+t[i]);</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        cin &gt;&gt; M;</span><br><span class="line">        ll x=M/tc;</span><br><span class="line">        ll pl=<span class="built_in">max</span>(<span class="number">0ll</span>,n-x);</span><br><span class="line">        cout &lt;&lt; St[pl]+tc &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-本题又主要考察了贪心"><a href="#E-本题又主要考察了贪心" class="headerlink" title="E.本题又主要考察了贪心"></a>E.本题又主要考察了贪心</h1><p><strong>DFS、诈骗</strong></p><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>$n$个人参加比赛，当前第$i$个人已经得到了$a_i$分，接下来还有$m$轮比赛<br>每轮两个人PK,赢的人$+3$分；平局则每人$+1$分<br>给定$m$轮比赛的名单，问$1$号选手能取得的最高名次</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接贪心很难贪（反正我是贪不出来）<br>由于人数和局数很少，直接DFS到每种结局，找到最优解即可<br>时间复杂度：$O(3^m)$</p><h2 id="参考程序-3"><a href="#参考程序-3" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pll&gt; q; <span class="comment">//记录每轮比赛的参赛选手</span></span><br><span class="line">ll n,m,ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(vector&lt;ll&gt; a,ll i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==m)&#123;</span><br><span class="line">        ll cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:a) <span class="keyword">if</span>(x&gt;a[<span class="number">0</span>]) cnt++;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,cnt);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;ll&gt; aa=a,ab=a,ac=a;</span><br><span class="line">    aa[q[i].first<span class="number">-1</span>]+=<span class="number">3</span>;<span class="comment">//a赢</span></span><br><span class="line">    <span class="built_in">DFS</span>(aa,i+<span class="number">1</span>);</span><br><span class="line">    ab[q[i].second<span class="number">-1</span>]+=<span class="number">3</span>;<span class="comment">//b赢</span></span><br><span class="line">    <span class="built_in">DFS</span>(ab,i+<span class="number">1</span>);</span><br><span class="line">    ac[q[i].first<span class="number">-1</span>]+=<span class="number">1</span>;<span class="comment">//平局</span></span><br><span class="line">    ac[q[i].second<span class="number">-1</span>]+=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">DFS</span>(ac,i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ans=INF;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a) cin &gt;&gt; x;</span><br><span class="line">    q.<span class="built_in">clear</span>();</span><br><span class="line">    ll u,v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;v) <span class="built_in">swap</span>(u,v);</span><br><span class="line">        q.<span class="built_in">pb</span>(&#123;u,v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DFS</span>(a,<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F-鸡数题！"><a href="#F-鸡数题！" class="headerlink" title="F.鸡数题！"></a>F.鸡数题！</h1><p><strong>概率论-排列组合</strong></p><h2 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h2><p>将$n$位的最大二进制数$111\cdots 1$（n个1）的每一位$1$分配给$m$个数，且每个数都不为$0$，问有多少种分配方案</p><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>$n$个不同的球放入$m$个不同的盒子，每个盒子至少一个球，有多少种放法<br>答案为第二类斯特林数$S(n,m)$<br>通项公式：$S(n,m)=\sum\limits_{i=0}^m\dfrac{(-1)^{m-i}\times i^n}{i!\times (m-i)!}$</p><h2 id="参考程序-4"><a href="#参考程序-4" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ll pown[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;m) &#123;cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">        pown[i]=<span class="built_in">qcpow</span>(i,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Prepare_Factorium</span>(m);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">        ll t=<span class="built_in">mul</span>(pown[i],<span class="built_in">mul</span>(Fac_inv[i],Fac_inv[m-i]));</span><br><span class="line">        <span class="keyword">if</span>((m-i)&amp;<span class="number">1</span>) t=MOD-t;</span><br><span class="line">        <span class="built_in">addto</span>(ans,t);</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="G-why买外卖"><a href="#G-why买外卖" class="headerlink" title="G.why买外卖"></a>G.why买外卖</h1><p><strong>贪心</strong></p><h2 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h2><p>有$n$张外卖券，第$i$张满$a_i$减$b_i$，$a_i$为餐品原价。<br>所有券可以叠加使用，你手上有$m$元，问你最多可以购买到原价为多少的餐品</p><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>假设餐品原价为$x$，则所有$a_i&lt;x$的券都可以使用。<br>根据使用门槛$a_i$对券排序，对减免部分做前缀和。<br>在每个门槛处计算：该门槛需支付的价格$x$（或溢出的优惠）=当前门槛-减免金额<br>如果$x$小于$m$，则更新答案，当前门槛下最高餐品价格为$m+减免金额$</p><h2 id="参考程序-5"><a href="#参考程序-5" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;pll&gt; <span class="title">vp</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:vp) cin &gt;&gt; x.first &gt;&gt; x.second;</span><br><span class="line">    <span class="built_in">SORT</span>(vp);</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">S</span><span class="params">(n+<span class="number">1</span>)</span></span>;S[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) S[i]=S[i<span class="number">-1</span>]+vp[i<span class="number">-1</span>].second;</span><br><span class="line">    ll ans=m;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vp[i<span class="number">-1</span>].first-S[i]&lt;=m)&#123;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,S[i]+m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="I-It’s-bertrand-paradox-Again"><a href="#I-It’s-bertrand-paradox-Again" class="headerlink" title="I.It’s bertrand paradox. Again!"></a>I.It’s bertrand paradox. Again!</h1><p><strong>概率论</strong></p><h2 id="题目大意-6"><a href="#题目大意-6" class="headerlink" title="题目大意"></a>题目大意</h2><p>现在有两种在$x\in [-100,100],y\in [-100,100]$平面范围内生成（圆心在整点上且半径为整数的）圆形的算法（仅第3步不同）：</p><ol><li>均匀随机生成一个 $(-100,100)$ 内的整点 $(x,y)$</li><li>均匀随机生成一个 $[1,100]$ 内的整数半径 $r$</li></ol><p>bit的检验：不满足在范围内，返回第2步，即仅重新生成$r$<br>buaa的检验：不满足在范围内，返回第1步，即重新生成一个圆</p><p>现在给出其中某个算法的生成 $10^5$ 个圆的结果，问是由哪个算法生成的</p><h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>两种算法下，生成结果的圆心和半径的分布是不同的。<br>明显bit的方法圆心是均匀分布在平面内的，而buaa的方法不是。</p><p>根据抽样分布原理，大量独立同分布随机变量和的极限分布是正态分布。因此对圆心</p>]]></content>
    
    
    <summary type="html">题解|2024牛客寒假01</summary>
    
    
    
    <category term="算法竞赛" scheme="http://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024牛客寒假" scheme="http://www.cclmsy.cc/tags/2024%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87/"/>
    
  </entry>
  
  <entry>
    <title>《数据库原理》期末复习笔记</title>
    <link href="http://www.cclmsy.cc/posts/6b396687.html"/>
    <id>http://www.cclmsy.cc/posts/6b396687.html</id>
    <published>2024-01-15T20:55:00.000Z</published>
    <updated>2024-01-27T02:08:28.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库原理"><a href="#数据库原理" class="headerlink" title="数据库原理"></a>数据库原理</h1><h2 id="一、概述（理解、记忆）"><a href="#一、概述（理解、记忆）" class="headerlink" title="一、概述（理解、记忆）"></a>一、概述（理解、记忆）</h2><h3 id="1-2-基本知识"><a href="#1-2-基本知识" class="headerlink" title="1.2. 基本知识"></a>1.2. 基本知识</h3><h4 id="1-数据、数据库"><a href="#1-数据、数据库" class="headerlink" title="1. 数据、数据库"></a>1. 数据、数据库</h4><ul><li>数据：表示客观事物的符号。</li><li>数据类型：文本、图形、图像、声音等。</li><li>数据库：<strong>长期存储</strong>在计算机内、<strong>有组织</strong>的、<strong>可共享</strong>的大量数据的集合。<h4 id="2-数据的特征"><a href="#2-数据的特征" class="headerlink" title="2. 数据的特征"></a>2. 数据的特征</h4>静态特征：数据结构、数据联系、数据约束</li></ul><p>动态特征：数据操作</p><h4 id="2-数据库的特点"><a href="#2-数据库的特点" class="headerlink" title="2. 数据库的特点"></a>2. 数据库的特点</h4><p>1.长期存储 2.有组织 3.可共享</p><h4 id="3-数据库管理系统（DBMS）"><a href="#3-数据库管理系统（DBMS）" class="headerlink" title="3. 数据库管理系统（DBMS）"></a>3. 数据库管理系统（DBMS）</h4><ul><li>定义：提供给用户，并帮助用户建立、使用和管理数据库的软件系统。</li><li><strong>是数据库系统（DBS）的核心</strong>。</li><li>建立在操作系统之上，位于操作系统与用户之间。<h4 id="4-数据库的主要功能（和SQL语言相对应）"><a href="#4-数据库的主要功能（和SQL语言相对应）" class="headerlink" title="4. 数据库的主要功能（和SQL语言相对应）"></a>4. 数据库的主要功能（和SQL语言相对应）</h4></li><li>数据定义：数据定义语言（DDL），定义数据库的数据对象及其关系</li><li>数据操纵：数据操纵语言（DML），增删改查</li><li>事务和运行管理：数据控制语言（DCL），对数据库的安全性、完整性、并发性和恢复性进行保护控制</li><li>组织、存储和管理数据</li><li>数据库的建立和维护</li></ul><div style="page-break-after: always;"></div><h4 id="5-数据库系统（DBS）的结构"><a href="#5-数据库系统（DBS）的结构" class="headerlink" title="5. 数据库系统（DBS）的结构"></a>5. 数据库系统（DBS）的结构</h4><ul><li>硬件：计算机硬件和数据库专用硬件</li><li>软件：操作系统（OS）、数据库管理系统（DBMS）（核心）、开发工具（数据库专用工具、程序设计语言）和应用系统</li><li>人员：数据库管理员（DBA）、数据库设计人员、应用程序员和最终用户<h4 id="6-数据库管理员（DBA）的主要职责"><a href="#6-数据库管理员（DBA）的主要职责" class="headerlink" title="6. 数据库管理员（DBA）的主要职责"></a>6. 数据库管理员（DBA）的主要职责</h4></li><li>决定数据库的信息内容和结构</li><li>决定数据库的存储结构和存取策略</li><li>定义数据库的安全性要求和完整性约束<h4 id="7-数据管理技术的3个阶段"><a href="#7-数据管理技术的3个阶段" class="headerlink" title="7. 数据管理技术的3个阶段"></a>7. 数据管理技术的3个阶段</h4></li><li>人工管理阶段<br>数据不保存、没有结构化、不独立、不共享、冗余度高</li><li>文件管理阶段<br>文件系统：数据<strong>可长期保存</strong>但没有结构化、独立性低、共享性低、冗余度高</li><li><strong>数据库系统阶段</strong><br>数据库系统：<strong>数据结构化、独立性高、共享性高、冗余度低</strong><h3 id="1-3-数据模型"><a href="#1-3-数据模型" class="headerlink" title="1.3. 数据模型"></a>1.3. 数据模型</h3><h4 id="1-数据模型的组成"><a href="#1-数据模型的组成" class="headerlink" title="1. 数据模型的组成"></a>1. 数据模型的组成</h4>1.数据结构 2.数据操作（增删改查） 3.数据的完整性约束<h4 id="2-数据模型"><a href="#2-数据模型" class="headerlink" title="2. 数据模型"></a>2. 数据模型</h4>（实际问题） $\Rightarrow$ 概念模型（高层） $\Rightarrow$ 逻辑模型 $\Rightarrow$ 物理模型（底层）<h4 id="3-概念模型"><a href="#3-概念模型" class="headerlink" title="3. 概念模型"></a>3. 概念模型</h4></li></ul><ol><li>概念模型：数据及其关系的图形表示。如：实体-联系图（<strong>E-R图</strong>）</li><li>要求：简单、清晰、易于理解，<strong>独立于DBMS</strong></li><li>名词解释</li></ol><ul><li>表（实体集、关系）：同一类实体的集合</li><li>元组（行、记录、实体）：客观存在且相互区别的事物</li><li>属性（列、字段、数据项）：实体所具有的特性</li><li>域（值域）：属性的取值范围</li><li>码/键：唯一标识实体的属性或属性组</li><li>候选键：唯一标识实体的最小属性组</li><li>主属性：包含在任一候选键中的属性</li><li>主键：用户选定的候选键</li><li>外键：一个实体集的属性集，它是另一个实体集的主键</li><li>超键：在键中删除一个或多个属性后，仍然能唯一标识实体的属性或属性组</li><li>全键：包含所有属性的候选键</li><li>联系：实体集之间或内部的关联。类型：一对一、一对多、多对多</li><li>元/度：表中属性的个数</li></ul><div style="page-break-after: always;"></div><h4 id="4-逻辑模型"><a href="#4-逻辑模型" class="headerlink" title="4. 逻辑模型"></a>4. 逻辑模型</h4><ul><li>定义：概念模型的DBMS表示</li><li>分类：层次模型、网状模型、<strong>关系模型</strong>、面向对象模型等</li><li>关系模型</li></ul><ol><li>关系（表）</li><li>关系模式（表头）：关系的结构描述</li><li>关系模型的特点：满足1NF、属性和元组不重复且无序。</li><li>关系数据库：支持关系模型的数据库</li><li>关系模式的数学表达：<br>$R(U,F),U={A_1,A_2,\cdots,A_n},F={A_i\rightarrow A_j,\cdots}$</li></ol><h3 id="1-4-数据库系统结构"><a href="#1-4-数据库系统结构" class="headerlink" title="1.4. 数据库系统结构"></a>1.4. 数据库系统结构</h3><h4 id="1-数据库系统的模式结构"><a href="#1-数据库系统的模式结构" class="headerlink" title="1. 数据库系统的模式结构"></a>1. 数据库系统的模式结构</h4><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数据库系统</span><br><span class="line">|<span class="string">---应用（一个外模式可以有多个应用）</span></span><br><span class="line"><span class="string"></span>|<span class="string">---DBMS</span></span><br><span class="line"><span class="string"></span>|<span class="string">   </span>|<span class="string">---外模式（一个DBMS可以有多个外模式）</span></span><br><span class="line"><span class="string"></span>|<span class="string">   </span>|<span class="string">---模式（一个）</span></span><br><span class="line"><span class="string"></span>|<span class="string">   </span>|<span class="string">---内模式（一个）</span></span><br><span class="line"><span class="string"></span>|<span class="string">---数据库</span></span><br></pre></td></tr></table></figure><h4 id="2-数据库系统的三级模式结构"><a href="#2-数据库系统的三级模式结构" class="headerlink" title="2. 数据库系统的三级模式结构"></a>2. 数据库系统的三级模式结构</h4><ol><li>外模式（子模式、用户模式）：面向用户的局部数据的逻辑结构和特征的描述，数据库用户的数据视图</li></ol><ul><li>一个数据库可以有多个外模式</li><li>一个外模式可以对应多个应用，一个应用只能对应一个外模式</li></ul><ol><li>模式（结构模式、逻辑模式）：数据库中全体数据的逻辑结构和特征的描述</li></ol><ul><li>一个数据库只有一个模式</li><li>DBMS的核心</li></ul><ol><li>内模式（存储模式、物理模式）：数据库在计算机内部的表示方式和数据存储方式<h4 id="3-数据库系统的二级映像"><a href="#3-数据库系统的二级映像" class="headerlink" title="3. 数据库系统的二级映像"></a>3. 数据库系统的二级映像</h4></li><li>外模式/模式映像：保证了数据库的逻辑独立性</li><li>模式/内模式映像：保证了数据库的物理独立性</li><li>逻辑独立性和物理独立性合称数据独立性</li></ol><h3 id="1-5-数据库系统的体系结构"><a href="#1-5-数据库系统的体系结构" class="headerlink" title="1.5. 数据库系统的体系结构"></a>1.5. 数据库系统的体系结构</h3><ol><li>C/S结构：客户/服务器结构</li><li>B/S结构：浏览器/服务器结构</li></ol><p>外部网络（表示层）$\Leftrightarrow$ 应用服务器（处理层）$\Leftrightarrow$ 内部网络（数据层）</p><div style="page-break-after: always;"></div><h2 id="二、关系运算"><a href="#二、关系运算" class="headerlink" title="二、关系运算"></a>二、关系运算</h2><h3 id="2-1-关系数据语言"><a href="#2-1-关系数据语言" class="headerlink" title="2.1. 关系数据语言"></a>2.1. 关系数据语言</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">关系数据语言</span><br><span class="line">|<span class="string">---关系演算语言</span></span><br><span class="line"><span class="string"></span>|<span class="string">   </span>|<span class="string">---关系代数语言（如ISBL）</span></span><br><span class="line"><span class="string"></span>|<span class="string">   </span>|<span class="string">---元组关系演算语言（如ALPHA）</span></span><br><span class="line"><span class="string"></span>|<span class="string">   </span>|<span class="string">---域关系演算语言（如QBE）</span></span><br><span class="line"><span class="string"></span>|<span class="string">---关系代数/演算双重语言：结构化查询语言（SQL）</span></span><br></pre></td></tr></table></figure><h3 id="2-2-关系代数语言"><a href="#2-2-关系代数语言" class="headerlink" title="2.2. 关系代数语言"></a>2.2. 关系代数语言</h3><h4 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h4><p>并$\cup$、差$-$、积$\times$、选择$\sigma$、投影$\pi$（注意：投影需要去重，即运算后记录数量可能变少）</p><h4 id="导出运算"><a href="#导出运算" class="headerlink" title="导出运算"></a>导出运算</h4><p>交$\cap$、除$\div$、连接$\Join$</p><h4 id="核心运算"><a href="#核心运算" class="headerlink" title="核心运算"></a>核心运算</h4><p>选择$\sigma$、投影$\pi$、连接$\Join$</p><h3 id="2-3-基于关系代数语言的更新运算"><a href="#2-3-基于关系代数语言的更新运算" class="headerlink" title="2.3. 基于关系代数语言的更新运算"></a>2.3. 基于关系代数语言的更新运算</h3><h4 id="1-插入运算"><a href="#1-插入运算" class="headerlink" title="1. 插入运算"></a>1. 插入运算</h4><p>建立一个与原表$R$具有相同属性的临时关系$T$，计算$R\cup T$</p><h4 id="2-删除运算"><a href="#2-删除运算" class="headerlink" title="2. 删除运算"></a>2. 删除运算</h4><p>建立一个与原表$R$具有相同属性的临时关系$T$，计算$R-T$</p><h4 id="3-修改运算"><a href="#3-修改运算" class="headerlink" title="3. 修改运算"></a>3. 修改运算</h4><p>先删除，再插入</p><h3 id="2-4-查询优化"><a href="#2-4-查询优化" class="headerlink" title="2.4. 查询优化"></a>2.4. 查询优化</h3><p>在做笛卡尔积前先尽可能地进行选择和投影，以减少计算量。</p><h3 id="寄巧"><a href="#寄巧" class="headerlink" title="*寄巧"></a>*寄巧</h3><p>查询不满足某条件的元组（如不能提供A的供应商）：$\pi<em>{SNO}(S)-\pi</em>{SNO}(S\Join\sigma_{PNAME=A} (P))$</p><p>查询满足多重条件的元组（如同时提供A和B的供应商）：<br>$\pi<em>{SNO}(S\Join\sigma</em>{PNAME=A} (P))\cap\pi<em>{SNO}(S\Join\sigma</em>{PNAME=B} (P))$</p><div style="page-break-after: always;"></div><h2 id="三、数据完整性"><a href="#三、数据完整性" class="headerlink" title="三、数据完整性"></a>三、数据完整性</h2><p>数据完整性是指：数据的正确性、相容性和一致性</p><h4 id="1-实体完整性"><a href="#1-实体完整性" class="headerlink" title="1. 实体完整性"></a>1. 实体完整性</h4><ul><li>定义：主属性A的值不能为空值（Not Null）</li><li>关键词：主键（Primary Key）<h4 id="2-参照完整性"><a href="#2-参照完整性" class="headerlink" title="2. 参照完整性"></a>2. 参照完整性</h4></li><li>定义：外键列的值必须是其参照表的主键列的值或空值</li><li>关键词：外键（Foreign Key）<h4 id="3-用户自定义完整性"><a href="#3-用户自定义完整性" class="headerlink" title="3. 用户自定义完整性"></a>3. 用户自定义完整性</h4></li><li>定义：用户根据应用的需要定义的完整性约束</li><li>关键词：默认值（Default）、检查（Check）、非空（Not Null）、唯一（Unique）</li></ul><h3 id="3-4-完整性控制机制"><a href="#3-4-完整性控制机制" class="headerlink" title="3.4. 完整性控制机制"></a>3.4. 完整性控制机制</h3><h4 id="1-完整性控制3个层面"><a href="#1-完整性控制3个层面" class="headerlink" title="1. 完整性控制3个层面"></a>1. 完整性控制3个层面</h4><ul><li>属性级（列级）：对特定属性（列）的条件约束</li><li>元组级（行级）：元组各个属性之间的约束（如售价必须大于进价）</li><li>关系级（表级）：不同元组、不同表之间的约束（如外键）<h4 id="2-完整性控制机制具备的功能"><a href="#2-完整性控制机制具备的功能" class="headerlink" title="2. 完整性控制机制具备的功能"></a>2. 完整性控制机制具备的功能</h4>定义功能、检查功能、违约处理<h4 id="3-定义功能"><a href="#3-定义功能" class="headerlink" title="3. 定义功能"></a>3. 定义功能</h4>提供完善的定义完整性约束的功能<h4 id="4-检查功能"><a href="#4-检查功能" class="headerlink" title="4. 检查功能"></a>4. 检查功能</h4>对于增删改的更新操作，提供检查完整性约束违约的功能</li></ul><p>两种检查方式：立即检查（单语句）、延迟检查（多语句）</p><h4 id="5-违约处理"><a href="#5-违约处理" class="headerlink" title="5. 违约处理"></a>5. 违约处理</h4><p>对于破坏完整性约束的更新操作，提供相应的违约处理功能</p><ol><li>拒绝更新：主键、非空、外键</li><li>置空：非主属性、外键</li><li>级联更新：把违约的更新转化为非违约更新，然后接受更新</li></ol><h2 id="四、SQL-Server"><a href="#四、SQL-Server" class="headerlink" title="四、SQL Server"></a>四、SQL Server</h2><h3 id="结构化查询语言（SQL-Structured-Query-Language）"><a href="#结构化查询语言（SQL-Structured-Query-Language）" class="headerlink" title="结构化查询语言（SQL, Structured Query Language）"></a>结构化查询语言（SQL, Structured Query Language）</h3><h3 id="1-数据定义语言（DDL-Data-Definition-Language）"><a href="#1-数据定义语言（DDL-Data-Definition-Language）" class="headerlink" title="1. 数据定义语言（DDL, Data Definition Language）"></a>1. 数据定义语言（DDL, Data Definition Language）</h3><ul><li>相关功能：定义数据的关系及完整性约束</li><li>关键词：Create、Alter、Drop<h3 id="2-数据操纵语言（DML-Data-Manipulation-Language）"><a href="#2-数据操纵语言（DML-Data-Manipulation-Language）" class="headerlink" title="2. 数据操纵语言（DML, Data Manipulation Language）"></a>2. 数据操纵语言（DML, Data Manipulation Language）</h3></li><li>相关功能：操纵数据（增删改查）</li><li>关键词：Insert、Delete、Update、Select（对应增删改查）<h3 id="3-数据控制语言（DCL-Data-Control-Language）"><a href="#3-数据控制语言（DCL-Data-Control-Language）" class="headerlink" title="3. 数据控制语言（DCL, Data Control Language）"></a>3. 数据控制语言（DCL, Data Control Language）</h3></li><li>相关功能：控制数据库的安全性、完整性、并发性和恢复性</li><li>关键词：Grant、Revoke、Deny、Check</li></ul><div style="page-break-after: always;"></div><h2 id="四（一）、数据定义语言（DDL）与完整性约束实现"><a href="#四（一）、数据定义语言（DDL）与完整性约束实现" class="headerlink" title="四（一）、数据定义语言（DDL）与完整性约束实现"></a>四（一）、数据定义语言（DDL）与完整性约束实现</h2><h3 id="3-1-数据定义语言（DDL）"><a href="#3-1-数据定义语言（DDL）" class="headerlink" title="3.1. 数据定义语言（DDL）"></a>3.1. 数据定义语言（DDL）</h3><ul><li>操作：创建Create、修改ALTER、删除DROP</li><li>对象：数据库Database、表Table、视图View、索引Index、登录Login、数据库用户User、数据库角色Role、触发器Trigger、断言Assertion、过程Procedure</li><li>数据库（存储文件）属于内模式，表属于模式，视图属于外模式，索引隶属于表。</li><li>数据库和断言没有修改操作</li></ul><h3 id="3-2-数据库和表的定义"><a href="#3-2-数据库和表的定义" class="headerlink" title="3.2. 数据库和表的定义"></a>3.2. 数据库和表的定义</h3><h4 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1. 创建数据库"></a>1. 创建数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> Database EBook<span class="operator">&lt;</span>数据库名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">On</span>(Name <span class="operator">=</span> <span class="string">&#x27;EBook&#x27;</span><span class="operator">&lt;</span>数据库逻辑名称<span class="operator">&gt;</span>,</span><br><span class="line">    FileName <span class="operator">=</span> <span class="string">&#x27;D:\DataBases\EBook.mdf&#x27;</span><span class="operator">&lt;</span>数据库物理名称<span class="operator">&gt;</span>,</span><br><span class="line">    <span class="comment">-- 创建前需要先创建文件夹</span></span><br><span class="line">    Size <span class="operator">=</span> <span class="number">5</span>MB<span class="operator">&lt;</span>初始大小<span class="operator">&gt;</span>,</span><br><span class="line">    FileGrowth <span class="operator">=</span> <span class="number">1</span>MB<span class="operator">&lt;</span>增长大小<span class="operator">&gt;</span>,</span><br><span class="line">    MaxSize <span class="operator">=</span> <span class="number">100</span>MB<span class="operator">&lt;</span>最大大小<span class="operator">&gt;</span>)]</span><br><span class="line">[Log <span class="keyword">On</span>(Name <span class="operator">=</span> <span class="string">&#x27;EBook_log&#x27;</span><span class="operator">&lt;</span>日志逻辑名称<span class="operator">&gt;</span>,</span><br><span class="line">    FileName <span class="operator">=</span> <span class="string">&#x27;D:\DataBases\EBook_log.ldf&#x27;</span><span class="operator">&lt;</span>日志物理名称<span class="operator">&gt;</span>,</span><br><span class="line">    Size <span class="operator">=</span> <span class="number">1</span>MB<span class="operator">&lt;</span>初始大小<span class="operator">&gt;</span>,</span><br><span class="line">    FileGrowth <span class="operator">=</span> <span class="number">5</span><span class="operator">%</span><span class="operator">&lt;</span>增长大小(可以是百分比)<span class="operator">&gt;</span>,</span><br><span class="line">    MaxSize <span class="operator">=</span> Unlimited<span class="operator">&lt;</span>最大大小(可以是无限)<span class="operator">&gt;</span>)]</span><br></pre></td></tr></table></figure><h4 id="2-删除数据库"><a href="#2-删除数据库" class="headerlink" title="2. 删除数据库"></a>2. 删除数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Drop</span> Database EBook</span><br></pre></td></tr></table></figure><h4 id="3-创建表"><a href="#3-创建表" class="headerlink" title="3. 创建表"></a>3. 创建表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Use EBook</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Table</span> SyT<span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">(</span><br><span class="line">    <span class="comment">-- 格式：&lt;列名&gt; &lt;数据类型&gt; [属性级完整性约束条件],</span></span><br><span class="line">    <span class="keyword">No</span> <span class="type">int</span>,</span><br><span class="line">    Name <span class="type">char</span>(<span class="number">8</span>) <span class="keyword">Unique</span>,</span><br><span class="line">    Code <span class="type">char</span>(<span class="number">6</span>) <span class="keyword">Check</span>(Code <span class="keyword">like</span> <span class="string">&#x27;Sy[0-9][0-9][0-9][0-9]&#x27;</span>),</span><br><span class="line">    <span class="comment">-- [表级完整性约束条件]</span></span><br><span class="line">    <span class="keyword">Constraint</span> PK_SyT <span class="keyword">Primary</span> Key(<span class="keyword">No</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><div style="page-break-after: always;"></div><h4 id="4-修改表（修改表的结构，属于DDL）"><a href="#4-修改表（修改表的结构，属于DDL）" class="headerlink" title="4. 修改表（修改表的结构，属于DDL）"></a>4. 修改表（修改表的结构，属于DDL）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Use EBook</span><br><span class="line"><span class="comment">-- 添加属性：Add &lt;列名&gt; &lt;数据类型&gt; [属性级完整性约束条件]</span></span><br><span class="line"><span class="keyword">Alter</span> <span class="keyword">Table</span> SyT</span><br><span class="line">    <span class="keyword">Add</span> Age <span class="type">int</span> <span class="keyword">Not</span> <span class="keyword">Null</span></span><br><span class="line"><span class="comment">-- 修改属性：Alter Column &lt;列名&gt; &lt;新数据类型&gt;</span></span><br><span class="line"><span class="keyword">Alter</span> <span class="keyword">Table</span> SyT</span><br><span class="line">    <span class="keyword">Alter</span> <span class="keyword">Column</span> Name <span class="type">char</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment">-- 删除属性：Drop Column &lt;列名&gt;</span></span><br><span class="line"><span class="keyword">Alter</span> <span class="keyword">Table</span> SyT</span><br><span class="line">    <span class="keyword">Drop</span> <span class="keyword">Column</span> Age</span><br></pre></td></tr></table></figure><h4 id="5-删除表"><a href="#5-删除表" class="headerlink" title="5. 删除表"></a>5. 删除表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Use EBook</span><br><span class="line"><span class="keyword">Drop</span> <span class="keyword">Table</span> SyT</span><br></pre></td></tr></table></figure><h4 id="6-数据类型"><a href="#6-数据类型" class="headerlink" title="6. 数据类型"></a>6. 数据类型</h4><ul><li>数值型：int、float</li><li>字符型：char(n)</li><li>日期型：date</li><li>图片型：image</li></ul><div style="page-break-after: always;"></div><h3 id="3-3-完整性约束实现"><a href="#3-3-完整性约束实现" class="headerlink" title="3.3. 完整性约束实现"></a>3.3. 完整性约束实现</h3><h4 id="1-实体完整性（主键）"><a href="#1-实体完整性（主键）" class="headerlink" title="1. 实体完整性（主键）"></a>1. 实体完整性（主键）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--建表时，属性级</span></span><br><span class="line"><span class="keyword">No</span> <span class="type">int</span> [<span class="keyword">Constraint</span> PK_No] <span class="keyword">Primary</span> Key</span><br><span class="line"><span class="comment">--建表时，关系级,可以是属性组</span></span><br><span class="line">[<span class="keyword">Constraint</span> PK_No] <span class="keyword">Primary</span> Key(<span class="keyword">No</span>,Name)</span><br><span class="line"><span class="comment">--修改表时，关系级（Primary Key要求属性已为NOT NULL）</span></span><br><span class="line"><span class="keyword">Alter</span> <span class="keyword">Table</span> SyT</span><br><span class="line">    <span class="keyword">Add</span> [<span class="keyword">Constraint</span> PK_No] <span class="keyword">Primary</span> Key(<span class="keyword">No</span>,Name)</span><br></pre></td></tr></table></figure><h4 id="2-参照完整性（外键）"><a href="#2-参照完整性（外键）" class="headerlink" title="2. 参照完整性（外键）"></a>2. 参照完整性（外键）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--建表时，关系级</span></span><br><span class="line"><span class="keyword">No</span> <span class="type">int</span> [<span class="keyword">Constraint</span> FK_No] <span class="keyword">References</span> CCT(<span class="keyword">No</span>)</span><br><span class="line"><span class="comment">--建表时，关系级</span></span><br><span class="line">[<span class="keyword">Constraint</span> FK_No] <span class="keyword">Foreign</span> Key(<span class="keyword">No</span>) <span class="keyword">References</span> CCT(<span class="keyword">No</span>)</span><br><span class="line"><span class="comment">--修改表时，关系级，级联更新</span></span><br><span class="line"><span class="keyword">Alter</span> <span class="keyword">Table</span> SyT</span><br><span class="line">    <span class="keyword">Add</span> [<span class="keyword">Constraint</span> FK_No] <span class="keyword">Foreign</span> Key(<span class="keyword">No</span>) <span class="keyword">References</span> CCT(<span class="keyword">No</span>)</span><br><span class="line">    <span class="keyword">On</span> <span class="keyword">Update</span> Cascade <span class="keyword">On</span> <span class="keyword">Delete</span> Cascade</span><br></pre></td></tr></table></figure><h4 id="3-用户自定义完整性（默认值、检查、非空、唯一）"><a href="#3-用户自定义完整性（默认值、检查、非空、唯一）" class="headerlink" title="3. 用户自定义完整性（默认值、检查、非空、唯一）"></a>3. 用户自定义完整性（默认值、检查、非空、唯一）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--建表时，属性级（NOT NULL只能在建表时定义）</span></span><br><span class="line"><span class="keyword">No</span> <span class="type">int</span> [<span class="keyword">Constraint</span> NN_No] <span class="keyword">Not</span> <span class="keyword">Null</span></span><br><span class="line">Name <span class="type">char</span>(<span class="number">8</span>) [<span class="keyword">Constraint</span> UQ_Name] <span class="keyword">Unique</span></span><br><span class="line"><span class="comment">--建表时，元组级</span></span><br><span class="line">[<span class="keyword">Constraint</span> SP] <span class="keyword">Check</span>(SPrice<span class="operator">&gt;</span>PPrice)</span><br><span class="line"><span class="comment">--修改表时，属性级</span></span><br><span class="line"><span class="keyword">Alter</span> <span class="keyword">Table</span> SyT</span><br><span class="line">    <span class="keyword">Add</span> [<span class="keyword">Constraint</span> CK_Code] <span class="keyword">Check</span>(Code <span class="keyword">like</span> <span class="string">&#x27;Sy[0-9][0-9][0-9][0-9]&#x27;</span>)</span><br><span class="line"><span class="comment">--修改表时，属性级，默认值</span></span><br><span class="line"><span class="keyword">Alter</span> <span class="keyword">Table</span> SyT</span><br><span class="line">    <span class="keyword">Add</span> [<span class="keyword">Constraint</span> DF_No] <span class="keyword">Default</span> <span class="number">0</span> <span class="keyword">For</span> Age</span><br></pre></td></tr></table></figure><p>like：模糊查询，%表示任意多个字符，_表示一个字符，[]表示一个字符集合，[a-z]表示a到z的任意一个字符，<sup><a href="#fn_a-z" id="reffn_a-z">a-z</a></sup>表示非a到z的任意一个字符</p><h4 id="4-删除完整性约束"><a href="#4-删除完整性约束" class="headerlink" title="4. 删除完整性约束"></a>4. 删除完整性约束</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Alter</span> <span class="keyword">Table</span> SyT</span><br><span class="line">    <span class="keyword">Drop</span> <span class="keyword">Constraint</span> DF_No</span><br></pre></td></tr></table></figure><div style="page-break-after: always;"></div><h2 id="四（二）、数据操纵语言（DML）与数据查询"><a href="#四（二）、数据操纵语言（DML）与数据查询" class="headerlink" title="四（二）、数据操纵语言（DML）与数据查询"></a>四（二）、数据操纵语言（DML）与数据查询</h2><h3 id="4-1-数据操纵语言（DML）"><a href="#4-1-数据操纵语言（DML）" class="headerlink" title="4.1. 数据操纵语言（DML）"></a>4.1. 数据操纵语言（DML）</h3><ul><li>操作：增Insert、删Delete、改Update、查Select</li><li>对象：表Table、视图View</li></ul><h3 id="4-2-添加记录"><a href="#4-2-添加记录" class="headerlink" title="4.2. 添加记录"></a>4.2. 添加记录</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Use EBook</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT[(<span class="keyword">No</span>,Name,Code)] <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;Sy0001&#x27;</span>)</span><br><span class="line"><span class="comment">-- 一句只能添加一条记录</span></span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;Sy0002&#x27;</span>)</span><br><span class="line"><span class="comment">-- 不指定列名，列名和值一一对应</span></span><br></pre></td></tr></table></figure><h3 id="4-3-删除记录"><a href="#4-3-删除记录" class="headerlink" title="4.3. 删除记录"></a>4.3. 删除记录</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Use EBook</span><br><span class="line"><span class="keyword">Delete</span> <span class="keyword">From</span> SyT [<span class="keyword">Where</span> <span class="keyword">No</span><span class="operator">=</span><span class="number">1</span><span class="operator">&lt;</span>条件<span class="operator">&gt;</span>]</span><br><span class="line"><span class="comment">-- 不加条件，删除所有记录</span></span><br></pre></td></tr></table></figure><h3 id="4-4-修改记录"><a href="#4-4-修改记录" class="headerlink" title="4.4. 修改记录"></a>4.4. 修改记录</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Use EBook</span><br><span class="line"><span class="keyword">Update</span> SyT <span class="keyword">Set</span> Name<span class="operator">=</span><span class="string">&#x27;王五&#x27;</span> [<span class="keyword">Where</span> <span class="keyword">No</span><span class="operator">=</span><span class="number">2</span><span class="operator">&lt;</span>条件<span class="operator">&gt;</span>]</span><br><span class="line"><span class="comment">-- 不加条件，修改所有记录</span></span><br></pre></td></tr></table></figure><div style="page-break-after: always;"></div><h3 id="4-5-查询记录"><a href="#4-5-查询记录" class="headerlink" title="4.5. 查询记录"></a>4.5. 查询记录</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Use EBook</span><br><span class="line"><span class="keyword">Select</span> [<span class="operator">&lt;</span>行：<span class="keyword">All</span><span class="operator">/</span><span class="keyword">Distinct</span><span class="operator">/</span>Top n<span class="operator">&gt;</span>] <span class="operator">&lt;</span>列：<span class="operator">*</span><span class="operator">/</span><span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span> <span class="operator">&lt;</span>显示名<span class="number">1</span><span class="operator">&gt;</span>,<span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span> <span class="operator">&lt;</span>显示名<span class="number">2</span><span class="operator">&gt;</span>,...<span class="operator">&gt;</span> <span class="comment">--行：选择/列：投影</span></span><br><span class="line"><span class="keyword">From</span> SyT [<span class="keyword">Join</span> CCT <span class="keyword">On</span>(SyT.A<span class="operator">=</span>CCT.B)] <span class="comment">--连接</span></span><br><span class="line">[<span class="keyword">Where</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>] <span class="comment">--选择</span></span><br><span class="line">[<span class="keyword">Group</span> <span class="keyword">By</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [<span class="keyword">Having</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>]] <span class="comment">--分组、筛选分组</span></span><br><span class="line">[<span class="keyword">Order</span> <span class="keyword">By</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [<span class="keyword">Asc</span><span class="operator">/</span><span class="keyword">Desc</span>]] <span class="comment">--排序</span></span><br></pre></td></tr></table></figure><ol><li>笛卡尔积：<code>Select * From SyT,CCT</code></li><li>并集：<code>Select * From SyT Union Select * From CCT</code></li><li>交集：<code>Select * From SyT Intersect Select * From CCT</code></li><li>差集：<code>Select * From SyT Except Select * From CCT</code></li><li>条件表达式：<ul><li>区间：<code>Where No Between 1 And 3</code></li><li>列表：<code>Where No In(1,3)</code></li><li>匹配：<code>Where Name Like &#39;张%&#39;</code></li><li>空值：<code>Where Name Is Null</code></li><li>取反：<code>Where Not No=1</code></li></ul></li><li>统计（需要分组，除被统计量外，其他列必须在Group By中）：<ul><li>Count：<code>Select Count(*) From SyT</code></li><li>Sum：<code>Select Sum(No) From SyT</code></li><li>Avg：<code>Select Avg(No) From SyT</code></li><li>Max：<code>Select Max(No) From SyT</code></li><li>Min：<code>Select Min(No) From SyT</code></li></ul></li><li>嵌套查询：<code>Select … From SyT Where No In(Select No From CCT Where …)</code></li><li>Having子句：<code>Select … From SyT Group By HNo Having Count(*)&gt;1</code>，筛选满足特定条件的分组</li></ol><div style="page-break-after: always;"></div><h2 id="专：SQL例题"><a href="#专：SQL例题" class="headerlink" title="专：SQL例题"></a>专：SQL例题</h2><h3 id="1-创建数据库-1"><a href="#1-创建数据库-1" class="headerlink" title="1. 创建数据库"></a>1. 创建数据库</h3><p>创建一个名为<code>EBook</code>的数据库，数据库文件存放在<code>D:\DataBases</code>文件夹下，数据库文件名为<code>EBook.mdf</code>，日志文件名为<code>EBook_log.ldf</code>，数据库文件初始大小为<code>5MB</code>，增长大小为<code>1MB</code>，最大大小为<code>100MB</code>，日志文件初始大小为<code>1MB</code>，增长大小为<code>5%</code>，最大大小为<code>无限</code>。</p><h3 id="2-创建表"><a href="#2-创建表" class="headerlink" title="2. 创建表"></a>2. 创建表</h3><p>创建一个名为<code>SyT</code>的表，表中包含<code>No</code>、<code>Name</code>、<code>Code</code>三个属性，其中<code>No</code>为整型，<code>Name</code>为长度为<code>8</code>的字符型，<code>Code</code>为长度为<code>6</code>的字符型，<code>No</code>和<code>Name</code>不能为空，<code>Code</code>以<code>Sy</code>开头，后面跟着<code>4</code>位数字。</p><h3 id="3-添加记录"><a href="#3-添加记录" class="headerlink" title="3. 添加记录"></a>3. 添加记录</h3><p>向<code>SyT</code>表中添加一条记录，<code>No</code>为<code>1</code>，<code>Name</code>为<code>张三</code>，<code>Code</code>为<code>Sy0001</code>。</p><h3 id="4-删除记录"><a href="#4-删除记录" class="headerlink" title="4. 删除记录"></a>4. 删除记录</h3><p>删除<code>SyT</code>表中<code>No</code>为<code>1</code>的记录。</p><h3 id="5-添加属性"><a href="#5-添加属性" class="headerlink" title="5. 添加属性"></a>5. 添加属性</h3><p>向<code>SyT</code>表中添加一个名为<code>Age</code>的属性，属性类型为整型，属性值不能为空。</p><h3 id="6-修改属性"><a href="#6-修改属性" class="headerlink" title="6. 修改属性"></a>6. 修改属性</h3><p>将<code>SyT</code>表中<code>Name</code>属性的长度改为<code>10</code>。</p><h3 id="7-准备数据"><a href="#7-准备数据" class="headerlink" title="7*. 准备数据"></a>7*. 准备数据</h3><p>利用以下语句创建名为<code>CCT</code>的表，并向其中添加记录。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">Table</span> CCT</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">No</span> <span class="type">int</span> <span class="keyword">Not</span> <span class="keyword">Null</span>,</span><br><span class="line">    Name <span class="type">char</span>(<span class="number">8</span>) <span class="keyword">Unique</span>,</span><br><span class="line">    Code <span class="type">char</span>(<span class="number">6</span>) <span class="keyword">Primary</span> Key</span><br><span class="line">)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> CCT <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;Sy0001&#x27;</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> CCT <span class="keyword">Values</span>(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;Sy0002&#x27;</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> CCT <span class="keyword">Values</span>(<span class="number">3</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;Sy0003&#x27;</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> CCT <span class="keyword">Values</span>(<span class="number">4</span>,<span class="string">&#x27;赵六&#x27;</span>,<span class="string">&#x27;Sy0004&#x27;</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> CCT <span class="keyword">Values</span>(<span class="number">5</span>,<span class="string">&#x27;孙七&#x27;</span>,<span class="string">&#x27;Sy0005&#x27;</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> CCT <span class="keyword">Values</span>(<span class="number">6</span>,<span class="string">&#x27;周八&#x27;</span>,<span class="string">&#x27;Sy0006&#x27;</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> CCT <span class="keyword">Values</span>(<span class="number">7</span>,<span class="string">&#x27;吴九&#x27;</span>,<span class="string">&#x27;Sy0007&#x27;</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> CCT <span class="keyword">Values</span>(<span class="number">8</span>,<span class="string">&#x27;郑十&#x27;</span>,<span class="string">&#x27;Sy0008&#x27;</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;Sy0001&#x27;</span>,<span class="number">20</span>)</span><br></pre></td></tr></table></figure></p><h3 id="7-实体完整性"><a href="#7-实体完整性" class="headerlink" title="7. 实体完整性"></a>7. 实体完整性</h3><p>将<code>SyT</code>表中<code>No</code>、<code>Name</code>属性组设为主键。</p><h3 id="8-参照完整性"><a href="#8-参照完整性" class="headerlink" title="8. 参照完整性"></a>8. 参照完整性</h3><p>将<code>SyT</code>表中<code>Code</code>属性修改为外键，参照<code>CCT</code>表中<code>Code</code>属性，级联更新。</p><h3 id="9-用户自定义完整性"><a href="#9-用户自定义完整性" class="headerlink" title="9. 用户自定义完整性"></a>9. 用户自定义完整性</h3><p>将<code>SyT</code>表中<code>Age</code>属性的默认值设为<code>0</code>。</p><h3 id="10-准备数据"><a href="#10-准备数据" class="headerlink" title="10*.准备数据"></a>10*.准备数据</h3><p>利用以下语句在<code>SyT</code>表中添加记录。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;Sy0002&#x27;</span>,<span class="number">21</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;Sy0003&#x27;</span>,<span class="number">22</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;赵六&#x27;</span>,<span class="string">&#x27;Sy0004&#x27;</span>,<span class="number">23</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;孙七&#x27;</span>,<span class="string">&#x27;Sy0005&#x27;</span>,<span class="number">24</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;周八&#x27;</span>,<span class="string">&#x27;Sy0006&#x27;</span>,<span class="number">25</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;吴九&#x27;</span>,<span class="string">&#x27;Sy0007&#x27;</span>,<span class="number">26</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;郑十&#x27;</span>,<span class="string">&#x27;Sy0008&#x27;</span>,<span class="number">27</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">2</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;Sy0001&#x27;</span>,<span class="number">21</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;Sy0002&#x27;</span>,<span class="number">22</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">2</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;Sy0003&#x27;</span>,<span class="number">23</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">2</span>,<span class="string">&#x27;赵六&#x27;</span>,<span class="string">&#x27;Sy0004&#x27;</span>,<span class="number">24</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">2</span>,<span class="string">&#x27;孙七&#x27;</span>,<span class="string">&#x27;Sy0005&#x27;</span>,<span class="number">25</span>)</span><br></pre></td></tr></table></figure></p><h3 id="10-查询记录"><a href="#10-查询记录" class="headerlink" title="10. 查询记录"></a>10. 查询记录</h3><ol><li>查询<code>SyT</code>表中年龄前5名的学生的序号、姓名、年龄。</li><li>统计<code>SyT</code>表中名为<code>张三</code>的学生的人数。</li><li>查询名字在<code>CCT</code>表中出现且在<code>SyT</code>表中未出现的学生的序号、姓名、编码。</li></ol><div style="page-break-after: always;"></div><h2 id="五、概念模型和逻辑模型"><a href="#五、概念模型和逻辑模型" class="headerlink" title="五、概念模型和逻辑模型"></a>五、概念模型和逻辑模型</h2><h3 id="5-1-概念模型（E-R图）"><a href="#5-1-概念模型（E-R图）" class="headerlink" title="5.1. 概念模型（E-R图）"></a>5.1. 概念模型（E-R图）</h3><p>1.实体：方框<br>2.属性：椭圆（主键用下划线标注）<br>3.关系：菱形</p><p>4.联系：线（实体与属性、实体与关系（标注1对1/1对n））<br><img src="ER.png" alt=""></p><h3 id="5-2-逻辑模型（关系模型）"><a href="#5-2-逻辑模型（关系模型）" class="headerlink" title="5.2. 逻辑模型（关系模型）"></a>5.2. 逻辑模型（关系模型）</h3><p>主键用下划线标注，外键用波浪线标注</p><p>上图的逻辑模型：</p><p>实体：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">供应商（商号（主键）、商名、城市、电话）</span><br><span class="line">项目（项目号（主键）、项目名、单位、负责人）</span><br><span class="line">零件（零件号（主键）、名称、规格、单价）</span><br><span class="line">仓库（仓库号（主键）、面积、电话）</span><br><span class="line">职工（工号（主键）、姓名、性别、职称）</span><br></pre></td></tr></table></figure><br>关系：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">供应（商号（主键、外键）、项目号（主键、外键）、供应量）</span><br><span class="line">库存（零件号（主键、外键）、仓库号（主键、外键）、库存量）</span><br><span class="line">工作（工号（主键、外键）、仓库号（主键、外键）、合同）</span><br><span class="line">领导（工号（主键、外键）、工号（主键、外键）、职补）</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h2 id="六、关系规范化"><a href="#六、关系规范化" class="headerlink" title="六、关系规范化"></a>六、关系规范化</h2><h3 id="6-1-函数依赖"><a href="#6-1-函数依赖" class="headerlink" title="6.1. 函数依赖"></a>6.1. 函数依赖</h3><ul><li>函数依赖：$X\rightarrow Y$，$X$决定$Y$，$Y$依赖于$X$</li><li>非平凡函数依赖：$X\rightarrow Y$，Y不是X的子集</li><li>完全函数依赖：$X\rightarrow Y$，$Y$不依赖于$X$的任何真子集，只依赖于$X$，记作$X -F\rightarrow Y$ </li><li>部分函数依赖：$X\rightarrow Y$，$Y$依赖于$X$的某个真子集，记作$X -P\rightarrow Y$</li><li>传递函数依赖：$X\rightarrow Y$，$Y\rightarrow Z$，$Z$依赖于$X$，且$Y$不依赖于$X$，记作$X -T\rightarrow Z$<h3 id="6-2-范式与关系规范化"><a href="#6-2-范式与关系规范化" class="headerlink" title="6.2. 范式与关系规范化"></a>6.2. 范式与关系规范化</h3><h4 id="1-第一范式（1NF）"><a href="#1-第一范式（1NF）" class="headerlink" title="1. 第一范式（1NF）"></a>1. 第一范式（1NF）</h4></li><li>定义：所有属性都是不可分的基本数据项</li></ul><h4 id="2-第二范式（2NF）"><a href="#2-第二范式（2NF）" class="headerlink" title="2. 第二范式（2NF）"></a>2. 第二范式（2NF）</h4><ul><li>定义：满足1NF，且每个非主属性完全函数依赖于候选键（消除部分函数依赖）</li></ul><h4 id="3-第三范式（3NF）"><a href="#3-第三范式（3NF）" class="headerlink" title="3. 第三范式（3NF）"></a>3. 第三范式（3NF）</h4><ul><li>定义：满足2NF，且每个非主属性不传递函数依赖于候选键</li></ul><h4 id="4-BC范式（BCNF）"><a href="#4-BC范式（BCNF）" class="headerlink" title="4. BC范式（BCNF）"></a>4. BC范式（BCNF）</h4><ul><li>定义：满足3NF，且任意函数依赖，$X\rightarrow Y$，$X$必包含候选键</li></ul><h4 id="5-第四范式（4NF）：不存在多值依赖"><a href="#5-第四范式（4NF）：不存在多值依赖" class="headerlink" title="5. *第四范式（4NF）：不存在多值依赖"></a>5. *第四范式（4NF）：不存在多值依赖</h4><h4 id="6-第五范式（5NF）：消除连接依赖"><a href="#6-第五范式（5NF）：消除连接依赖" class="headerlink" title="6. *第五范式（5NF）：消除连接依赖"></a>6. *第五范式（5NF）：消除连接依赖</h4><h3 id="6-3-关系规范化"><a href="#6-3-关系规范化" class="headerlink" title="6.3. 关系规范化"></a>6.3. 关系规范化</h3><h4 id="1-Amstrong公理"><a href="#1-Amstrong公理" class="headerlink" title="1. Amstrong公理"></a>1. Amstrong公理</h4><ul><li>自反律：$Y\subseteq X\Rightarrow X\rightarrow Y$</li><li>增广律：$X\rightarrow Y\Rightarrow XZ\rightarrow YZ$</li><li>传递律：$X\rightarrow Y,Y\rightarrow Z\Rightarrow X\rightarrow Z$</li><li>合成律：$X\rightarrow Y,Y\rightarrow Z\Rightarrow X\rightarrow YZ$</li><li>分解律：$X\rightarrow YZ\Rightarrow X\rightarrow Y,X\rightarrow Z$</li><li>伪传递律：$X\rightarrow Y,YW\rightarrow Z\Rightarrow XW\rightarrow YZ$</li></ul><h4 id="2-函数依赖集闭包-F"><a href="#2-函数依赖集闭包-F" class="headerlink" title="2. *函数依赖集闭包$F^+$"></a>2. *函数依赖集闭包$F^+$</h4><h4 id="3-属性集闭包-X-F"><a href="#3-属性集闭包-X-F" class="headerlink" title="3. 属性集闭包$X^+_F$"></a>3. 属性集闭包$X^+_F$</h4><ul><li>已知$X$，利用函数依赖集可以计算出的最大属性集<h4 id="4-最小函数依赖集-F-min"><a href="#4-最小函数依赖集-F-min" class="headerlink" title="4. 最小函数依赖集$F_{min}$"></a>4. 最小函数依赖集$F_{min}$</h4></li><li>从函数依赖集中删除冗余的函数依赖<h4 id="5-求所有候选键"><a href="#5-求所有候选键" class="headerlink" title="5. 求所有候选键"></a>5. 求所有候选键</h4></li><li>只在左边出现：一定属于每个候选键</li><li>只在右边出现：一定不属于任何候选键</li><li>左右都出现：可能属于候选键，闭包计算</li><li>左右都不出现：一定属于每个候选键（否则无法得到它本身）</li></ul><h2 id="七、数据安全"><a href="#七、数据安全" class="headerlink" title="七、数据安全"></a>七、数据安全</h2><h3 id="7-1-数据保护"><a href="#7-1-数据保护" class="headerlink" title="7.1. 数据保护"></a>7.1. 数据保护</h3><p>主要包括：数据安全、数据完整、数据并发和数据恢复</p><h3 id="7-2-安全标准"><a href="#7-2-安全标准" class="headerlink" title="7.2. 安全标准"></a>7.2. 安全标准</h3><p>4组7个等级：$D,C_1,C_2,B_1,B_2,B_3,A_1$</p><h3 id="7-3-数据安全"><a href="#7-3-数据安全" class="headerlink" title="7.3. 数据安全"></a>7.3. 数据安全</h3><p>包括：用户鉴别、数据存取控制、视图、审计与数据加密</p><h4 id="1-用户鉴别"><a href="#1-用户鉴别" class="headerlink" title="1. 用户鉴别"></a>1. 用户鉴别</h4><p>鉴别方式：静态鉴别（用户名和密码）和动态鉴别（验证码）等</p><h4 id="2-数据存取控制（SQL的DCL）"><a href="#2-数据存取控制（SQL的DCL）" class="headerlink" title="2. 数据存取控制（SQL的DCL）"></a>2. 数据存取控制（SQL的DCL）</h4><ul><li>Grant：授权</li><li>Revoke：撤销</li><li>Deny：拒绝</li></ul><h4 id="3-视图"><a href="#3-视图" class="headerlink" title="3. 视图"></a>3. 视图</h4><ul><li>定义：从一个或多个基本表中导出的虚表，局部数据的临时体现</li><li>作用<br>（1）简化用户操作<br>（2）清晰表达查询<br>（3）同一数据可以以不同形式提供给不同用户<br>（4）在一定程度上确保了数据安全<br>（5）在一定程度上提供了逻辑独立性</li><li>数据操纵与表一致，关键词由<code>Table</code>改为<code>View</code></li><li>更新视图：（表内数据同步更新）</li></ul><h4 id="4-审计"><a href="#4-审计" class="headerlink" title="4. 审计"></a>4. 审计</h4><h4 id="5-数据加密"><a href="#5-数据加密" class="headerlink" title="5. 数据加密"></a>5. 数据加密</h4><p>常用的加密方法：替换方法、置换方法和混合方法等。</p><div style="page-break-after: always;"></div><h2 id="八、并发控制"><a href="#八、并发控制" class="headerlink" title="八、并发控制"></a>八、并发控制</h2><h3 id="8-1-事务"><a href="#8-1-事务" class="headerlink" title="8.1. 事务"></a>8.1. 事务</h3><ul><li>用户定义的一个数据操作序列，这些操作可作为一个完整的工作单元，要么全部执行，要么全部不执行，是一个不可分割的工作单位。</li><li>事务中的操作一般是对数据的更新操作，包括增、删、改。</li><li>以<code>BEGIN TRANSACTION</code>语句开始，以<code>COMMIT</code>语句（正常）或<code>ROLLBACK</code>语句（异常）结束</li><li>特征：原子性、一致性、隔离性、持久性<h3 id="8-2-并发控制错误"><a href="#8-2-并发控制错误" class="headerlink" title="8.2. 并发控制错误"></a>8.2. 并发控制错误</h3><h4 id="1-丢失修改"><a href="#1-丢失修改" class="headerlink" title="1. 丢失修改"></a>1. 丢失修改</h4>事务T1,T2同时读入同一数据并加以修改，T2的提交结果会破坏T1提交的结果<h4 id="2-读脏数据"><a href="#2-读脏数据" class="headerlink" title="2. 读脏数据"></a>2. 读脏数据</h4>事务T1修改数据后撤销，使得T2读取的数据与数据库中不一致<h4 id="3-不可重复读"><a href="#3-不可重复读" class="headerlink" title="3. 不可重复读"></a>3. 不可重复读</h4>事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果<h3 id="8-3-封锁：最常用的并发控制方法"><a href="#8-3-封锁：最常用的并发控制方法" class="headerlink" title="8.3. 封锁：最常用的并发控制方法"></a>8.3. 封锁：最常用的并发控制方法</h3></li></ul><ol><li>排他锁（X锁），用于写操作，其他事务不允许读写，也不允许加锁</li><li>共享锁（S锁），用于读操作，其他事务允许读，不允许写，允许加S锁，不允许加X锁</li></ol><h3 id="8-4-封锁协议"><a href="#8-4-封锁协议" class="headerlink" title="8.4. 封锁协议"></a>8.4. 封锁协议</h3><h4 id="1-一级封锁协议"><a href="#1-一级封锁协议" class="headerlink" title="1. 一级封锁协议"></a>1. 一级封锁协议</h4><p>T1,T2都加X锁（解决丢失修改）</p><h4 id="2-二级封锁协议"><a href="#2-二级封锁协议" class="headerlink" title="2. 二级封锁协议"></a>2. 二级封锁协议</h4><p>T1加X锁，T2加S锁（解决丢失修改和不可重复读）</p><h4 id="3-三级封锁协议"><a href="#3-三级封锁协议" class="headerlink" title="3. 三级封锁协议"></a>3. 三级封锁协议</h4><p>T1加S锁，T2加X锁（解决丢失修改、不可重复读和读脏数据）</p><h3 id="8-5-两段锁协议和可串行化"><a href="#8-5-两段锁协议和可串行化" class="headerlink" title="8.5. 两段锁协议和可串行化"></a>8.5. 两段锁协议和可串行化</h3><p>满足两段锁协议一定可串行化，不满足两段锁协议也可能可串行化。</p><h3 id="8-6-封锁粒度"><a href="#8-6-封锁粒度" class="headerlink" title="8.6. 封锁粒度"></a>8.6. 封锁粒度</h3><p>粒度越细，软件复杂性和系统开销也就越小</p><h3 id="8-7-活锁"><a href="#8-7-活锁" class="headerlink" title="8.7. 活锁"></a>8.7. 活锁</h3><ul><li>由于授权封锁的随机性，导致事务T的封锁请求一直处于等待状态的封锁。即：T封锁一个数据对象时，T始终处于等待状态。</li><li>解决方法：采用先来先服务的授权策略。并发事务请求封锁数据对象时，按照请求封锁的先后次序依次进行授权。</li></ul><h3 id="8-8-死锁"><a href="#8-8-死锁" class="headerlink" title="8.8. 死锁"></a>8.8. 死锁</h3><ul><li>两个或两个以上事务在执行过程中，因争夺资源而造成的一种互相等待的现象。</li><li>预防：一次封锁、顺序封锁</li><li>诊断：超时法、等待图法</li></ul><h2 id="九、数据库恢复"><a href="#九、数据库恢复" class="headerlink" title="九、数据库恢复"></a>九、数据库恢复</h2><h3 id="9-1-故障管理"><a href="#9-1-故障管理" class="headerlink" title="9.1.  故障管理"></a>9.1.  故障管理</h3><ul><li>事务故障：运行的事务T遭到强行终止，使T非正常结束。破坏了原子性。</li><li>系统故障：导致系统停止运转的任何事件。系统故障需要重新启动系统。</li><li>介质故障：导致外存储设备故障的任何事件。</li><li>病毒故障<h3 id="9-2-建立冗余数据"><a href="#9-2-建立冗余数据" class="headerlink" title="9.2. 建立冗余数据"></a>9.2. 建立冗余数据</h3></li><li>数据恢复的核心技术：建立冗余数据和利用冗余数据实施数据库恢复。</li><li>建立冗余数据的技术：数据转储和登记日志文件等。</li><li>数据转储分类：静态海量转储、静态增量转储、动态海量转储和动态增量转储，各自的含义。</li></ul><h2 id="十、数据库设计"><a href="#十、数据库设计" class="headerlink" title="十、数据库设计"></a>十、数据库设计</h2><p>数据库设计方法：手工经验法，新奥尔良法，ER图法，3NF法等</p>]]></content>
    
    
    <summary type="html">考前1晚从0开始女娲补天的数据库复习(×)预习(√)笔记</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.cclmsy.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="http://www.cclmsy.cc/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《概率论与数理统计》期末复习笔记</title>
    <link href="http://www.cclmsy.cc/posts/2aad59c.html"/>
    <id>http://www.cclmsy.cc/posts/2aad59c.html</id>
    <published>2024-01-11T18:55:00.000Z</published>
    <updated>2024-02-05T10:59:23.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h1><h2 id="一、随机事件与概率"><a href="#一、随机事件与概率" class="headerlink" title="一、随机事件与概率"></a>一、随机事件与概率</h2><h3 id="1-公式："><a href="#1-公式：" class="headerlink" title="1.公式："></a>1.公式：</h3><ol><li>条件概率：$P(A|B)=\frac{P(AB)}{P(B)}$</li><li>乘法公式：$P(AB)=P(A|B)P(B)=P(B|A)P(A)$</li><li>全概率公式：$P(A)=\sum_{i=1}^nP(A|B_i)P(B_i)$</li><li>贝叶斯公式：$P(B<em>i|A)=\frac{P(A|B_i)P(B_i)}{\sum</em>{i=1}^nP(A|B_i)P(B_i)}$</li><li>抽签问题：$P(A)=\frac{m}{n}$</li></ol><h3 id="2-事件独立性"><a href="#2-事件独立性" class="headerlink" title="2.事件独立性"></a>2.事件独立性</h3><p>事件A,B,C相互独立 $\Leftrightarrow P(ABC)=P(A)P(B)P(C),P(AB)=P(A)P(B),P(AC)=P(A)P(C),P(BC)=P(B)P(C)$</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>$A,B,C$独立，$ABC=\varnothing,P(A)=P(B)=P(C)\lt\frac{1}{2},P(A\cup B\cup C)=\frac{9}{16}$,求$P(A)$</p><p>$P(A\cup B\cup C)=P(A)+P(B)+P(C)-P(AB)-P(AC)-P(BC)+P(ABC)=3P(A)-3P(A)^2+0$</p><p>$=\frac{9}{16} \Rightarrow P(A)=\frac{1}{4}$或$P(A)=\frac{3}{4}$(舍)</p><h3 id="3-超几何分布"><a href="#3-超几何分布" class="headerlink" title="3.超几何分布"></a>3.超几何分布</h3><ol><li>概述：$n+m$件产品中有$m$件次品，从中抽取$k$件，求其中有$i$件次品的概率</li><li>分布律：$P(X=i)=\frac{C<em>m^iC</em>{n}^{k-i}}{C_{m+n}^k}$</li></ol><div STYLE="page-break-after: always;"></div><h2 id="二、随机变量及其分布-数字特征"><a href="#二、随机变量及其分布-数字特征" class="headerlink" title="二、随机变量及其分布+数字特征"></a>二、随机变量及其分布+数字特征</h2><h3 id="1-X-B-n-p"><a href="#1-X-B-n-p" class="headerlink" title="1. $X$ ~ $B(n,p)$"></a>1. $X$ ~ $B(n,p)$</h3><ol><li>分布名称：二项分布</li><li>概述：$n$次独立重复试验中，事件A发生的次数$X$（伯努利试验）</li><li>分布律：$P(X=k)=C_n^kp^k(1-p)^{n-k}$</li><li>期望：$E(X)=np$</li><li>方差：$D(X)=np(1-p)$</li></ol><h3 id="2-X-P-lambda"><a href="#2-X-P-lambda" class="headerlink" title="2. $X$ ~ $P(\lambda)$"></a>2. $X$ ~ $P(\lambda)$</h3><ol><li>分布名称：泊松分布</li><li>概述：多次试验中小概率事件A发生的次数$X$</li><li>分布律：$P(X=k)=\frac{\lambda^k}{k!}e^{-\lambda}$</li><li>期望：$E(X)=\lambda$</li><li>方差：$D(X)=\lambda$</li><li>泊松定理：对于$X$ ~ $B(n,p)$，当$n\rightarrow\infty,p\rightarrow0,np=\lambda$时，可近似认为$X$ ~ $P(\lambda)$</li></ol><h3 id="3-X-g-p"><a href="#3-X-g-p" class="headerlink" title="3. $X$ ~ $g(p)$"></a>3. $X$ ~ $g(p)$</h3><ol><li>分布名称：几何分布</li><li>概述：多次试验中事件A第一次成功的次数$X$</li><li>分布律：$P(X=k)=p(1-p)^{k-1}$</li><li>期望：$E(X)=\frac{1}{p}$</li><li>方差：$D(X)=\frac{1-p}{p^2}$</li><li>无记忆性：$P(X&gt;s+t|X&gt;s)=P(X&gt;t)$</li></ol><h3 id="4-X-U-a-b"><a href="#4-X-U-a-b" class="headerlink" title="4. $X$ ~ $U(a,b)$"></a>4. $X$ ~ $U(a,b)$</h3><ol><li>分布名称：均匀分布</li><li>分布函数：$F(x)=\begin{cases}0&amp;,x<a \\\\ \dfrac{x-a}{b-a}&,a\leq x\leq b \\\\ 1&,x>b\end{cases}$</li><li>概率密度函数：$f(x)=\begin{cases}\frac{1}{b-a}&amp;,a\leq x\leq b \\ 0&amp;,\text{其他}\end{cases}$</li><li>期望：$E(X)=\frac{a+b}{2}$</li><li>方差：$D(X)=\frac{(b-a)^2}{12}$</li></ol><div STYLE="page-break-after: always;"></div><h3 id="5-X-E-lambda"><a href="#5-X-E-lambda" class="headerlink" title="5. $X$ ~ $E(\lambda)$"></a>5. $X$ ~ $E(\lambda)$</h3><ol><li>分布名称：指数分布</li><li>分布函数：$F(x)=\begin{cases}1-e^{-\lambda x}&amp;,x\geq 0 \\ 0&amp;,x&lt;0\end{cases}$</li><li>概率密度函数：$f(x)=\begin{cases}\lambda e^{-\lambda x}&amp;,x\geq 0 \\ 0&amp;,x&lt;0\end{cases}$</li><li>期望：$E(X)=\frac{1}{\lambda}$</li><li>方差：$D(X)=\frac{1}{\lambda^2}$</li><li>$P(X&gt;t)=e^{-\lambda t}$</li><li>无记忆性：$P(X&gt;s+t|X&gt;s)=P(X&gt;t)$</li><li>与泊松分布的关系：服从$E(\lambda)$的事件，$t$时间内发生的次数$X$ ~ $P(\lambda t)$</li><li>事件下次发生的时间：$X$ ~ $E(\lambda)$，$P(X&gt;t)=e^{-\lambda t}$</li></ol><h3 id="6-X-N-mu-sigma-2"><a href="#6-X-N-mu-sigma-2" class="headerlink" title="6. $X$ ~ $N(\mu,\sigma^2)$"></a>6. $X$ ~ $N(\mu,\sigma^2)$</h3><ol><li>分布名称：正态分布</li><li>分布函数：$F(x)=\frac{1}{\sqrt{2\pi}\sigma}\int_{-\infty}^xe^{-\frac{(t-\mu)^2}{2\sigma^2}}dt$</li><li>概率密度函数：$f(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}$</li><li>期望：$E(X)=\mu$</li><li>方差：$D(X)=\sigma^2$</li><li>对称轴：$x=\mu$</li><li>拐点：$x=\mu \pm \sigma$</li><li>分布函数最大值：$f(x)_{max}=f(\mu)=\frac{1}{\sqrt{2\pi}\sigma}$</li><li>$\sigma\uparrow$：扁平 ； $\sigma\downarrow$：尖锐</li><li>$\mu\uparrow\downarrow$：左右平移，形状不变<h3 id="7-X-N-0-1"><a href="#7-X-N-0-1" class="headerlink" title="7. $X$ ~ $N(0,1)$"></a>7. $X$ ~ $N(0,1)$</h3></li><li>分布名称：标准正态分布</li><li>分布函数：$\varPhi(x)=\frac{1}{\sqrt{2\pi}}\int_{-\infty}^xe^{-\frac{t^2}{2}}dt$</li><li>概率密度函数：$\varphi(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}$</li><li>期望：$E(X)=0$</li><li>方差：$D(X)=1$</li><li>$\varPhi(-x)=1-\varPhi(x)$</li><li>$P(a&lt;X&lt;b)=\varPhi(b)-\varPhi(a)$</li><li>$P(|X|&lt;a)=2\varPhi(a)-1$</li><li>$3\mu$原则：$P(|X-\mu|&lt;k\sigma),k=1,2,3$分别对应$0.683,0.954,0.997$</li><li>正态分布标准化：$X$ ~ $N(\mu,\sigma^2)$，$Z=\frac{X-\mu}{\sigma}$ ~ $N(0,1)$</li></ol><div STYLE="page-break-after: always;"></div><h2 id="三、多维随机变量及其分布"><a href="#三、多维随机变量及其分布" class="headerlink" title="三、多维随机变量及其分布"></a>三、多维随机变量及其分布</h2><h3 id="1-二维随机分布函数的充要条件-3"><a href="#1-二维随机分布函数的充要条件-3" class="headerlink" title="1. 二维随机分布函数的充要条件(3)"></a>1. 二维随机分布函数的充要条件(3)</h3><ol><li>右连续：$F(x+0,y)=F(x,y)$</li><li>规范性：$P(+\infty,+\infty)=1,P(-\infty,-\infty)=0$</li><li>容斥：$P(x_1\leq x\leq x_2,y_1\leq y\leq y_2)=F(x_2,y_2)-F(x_1,y_2)-F(x_2,y_1)+F(x_1,y_1)$<h3 id="2-边缘分布函数"><a href="#2-边缘分布函数" class="headerlink" title="2. 边缘分布函数"></a>2. 边缘分布函数</h3></li><li>$F_X(x)=F(x,+\infty)$</li><li>$F_Y(y)=F(+\infty,y)$<h3 id="3-联合密度函数、边缘密度函数定义"><a href="#3-联合密度函数、边缘密度函数定义" class="headerlink" title="3. 联合密度函数、边缘密度函数定义"></a>3. 联合密度函数、边缘密度函数定义</h3></li><li>联合密度函数：$F(x,y)=\int<em>{-\infty}^x\int</em>{-\infty}^yf(x,y)dxdy$</li><li>边缘密度函数：$f<em>X(x)=\int</em>{-\infty}^{+\infty}f(x,y)dy,f<em>Y(y)=\int</em>{-\infty}^{+\infty}f(x,y)dx$<h3 id="4-二维正态分布"><a href="#4-二维正态分布" class="headerlink" title="4. 二维正态分布"></a>4. 二维正态分布</h3></li><li>$(X,Y)$ ~ $N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$</li><li>二维正态分布的边缘分布仍是正态分布：$X$ ~ $N(\mu_1,\sigma_1^2),Y$ ~ $N(\mu_2,\sigma_2^2)$</li><li>$X,Y$ 独立 $\Leftrightarrow$ $X,Y$ 无关 $\Leftrightarrow$ $\rho=0$<h3 id="5-可加性"><a href="#5-可加性" class="headerlink" title="5. 可加性"></a>5. 可加性</h3></li><li>前提：$X_i$ 独立</li><li>泊松分布：$X_i$ ~ $P(\lambda _i)$ $\Rightarrow$ $\sum X_i$ ~ $P(\sum \lambda _i)$</li><li>二项分布：$X_i$ ~ $B(n_i,p)$ $\Rightarrow$ $\sum X_i$ ~ $B(\sum n_i,p)$</li><li>正态分布：$X_i$ ~ $N(\mu _i,\sigma _i^2)$ $\Rightarrow$ $\sum k_iX_i$ ~ $N(\sum k_i\mu _i,\sum k_i^2\sigma _i^2)$<h3 id="6-最值分布函数"><a href="#6-最值分布函数" class="headerlink" title="6. 最值分布函数"></a>6. 最值分布函数</h3></li><li>$F_{max}(x)=P(X_1\leq x,X_2\leq x,\cdots,X_n\leq x)=\prod F(x_i)$</li><li>$F_{min}(x)=P(X_1\leq x,X_2\leq x,\cdots,X_n\leq x)=1-\prod (1-F(x_i))$</li></ol><div STYLE="page-break-after: always;"></div><h4 id="例题：已知-mathbb-X-X-1-X-2-cdots-X-n-独立同分布，且服从于-U-0-theta-，求-max-mathbb-X-、-min-mathbb-X-的密度函数-f-M-x-、-f-N-x-。"><a href="#例题：已知-mathbb-X-X-1-X-2-cdots-X-n-独立同分布，且服从于-U-0-theta-，求-max-mathbb-X-、-min-mathbb-X-的密度函数-f-M-x-、-f-N-x-。" class="headerlink" title="例题：已知$\mathbb{X}=(X_1,X_2,\cdots,X_n)$独立同分布，且服从于$U(0,\theta)$，求$\max(\mathbb{X})$、$\min(\mathbb{X})$的密度函数$f_M(x)$、$f_N(x)$。"></a>例题：已知$\mathbb{X}=(X_1,X_2,\cdots,X_n)$独立同分布，且服从于$U(0,\theta)$，求$\max(\mathbb{X})$、$\min(\mathbb{X})$的密度函数$f_M(x)$、$f_N(x)$。</h4><p>$X_i$ ~ $U(0,\theta)$ $\Rightarrow$ $F(x)=\begin{cases}0&amp;,x<0\\\\\frac{x}{\theta}&,0\leq x\leq \theta\\\\1&,x>\theta\end{cases}$</p><p>$F_M(x)=\prod F(x_i)=(F(x))^n=\begin{cases}0&amp;,x<0\\\\\left(\frac{x}{\theta}\right)^n&,0\leq x\leq \theta\\\\1&,x>\theta\end{cases}$</p><p>$\Rightarrow$ $f_M(x)=\frac{dF_M(x)}{dx}=\begin{cases}\frac{nx^{n-1}}{\theta^n}&amp;,0\leq x\leq \theta\\0&amp;,Otherwise\end{cases}$</p><p>$F_N(x)=1-F_M(x)=\begin{cases}1&amp;,x<0\\\\1-\left(\frac{x}{\theta}\right)^n&,0\leq x\leq \theta\\\\0&,x>\theta\end{cases}$</p><p>$\Rightarrow$ $f_N(x)=\frac{dF_N(x)}{dx}=\begin{cases}\frac{nx^{n-1}}{\theta^n}&amp;,0\leq x\leq \theta\\0&amp;,Otherwise\end{cases}$</p><div STYLE="page-break-after: always;"></div><h2 id="专：随机变量函数的分布"><a href="#专：随机变量函数的分布" class="headerlink" title="专：随机变量函数的分布"></a>专：随机变量函数的分布</h2><h3 id="1-离散型随机变量"><a href="#1-离散型随机变量" class="headerlink" title="1. 离散型随机变量"></a>1. 离散型随机变量</h3><ol><li>一维：$P(X=x<em>i)=p_i$，$Y=h(X)$ $\Rightarrow$ $P(Y=y_j)=\sum\limits</em>{h(x_i)=y_j}p_i$</li><li>二维：$P(X=x<em>i,Y=y_j)=p</em>{ij}$，$Z=h(X,Y)$ $\Rightarrow$ $P(Z=z<em>k)=\sum\limits</em>{h(x<em>i,y_j)=z_k}p</em>{ij}$</li></ol><h3 id="2-连续型随机变量"><a href="#2-连续型随机变量" class="headerlink" title="2. 连续型随机变量"></a>2. 连续型随机变量</h3><h4 id="一维例题：-X-N-0-1-Y-X-2-，求-f-Y-y"><a href="#一维例题：-X-N-0-1-Y-X-2-，求-f-Y-y" class="headerlink" title="一维例题：$X$ ~ $N(0,1)$ , $Y=X^2$，求$f_Y(y)$"></a>一维例题：$X$ ~ $N(0,1)$ , $Y=X^2$，求$f_Y(y)$</h4><p>第1步：写$X$的取值范围，确认$f_Y(y)$的定义域，定义域外$f_Y(y)=0$</p><p>$X\in R$ $\Rightarrow$ $Y=X^2\geq 0$</p><p>第2步：写出$X$的分布函数$F_X(x)$</p><p>$F_X(x)=\varPhi(x)$</p><p>第3步：求$Y$的分布函数$F_Y(y)$</p><p>$y\geq 0$ 时， $F_Y(y)=P(Y\leq y)=P(X^2\leq y)=P(|X| \leq \sqrt{y})=2\varPhi(\sqrt{y})-1$</p><p>$\Rightarrow$ $F_Y(y)=\begin{cases}0&amp;,y&lt;0\\2\varPhi(\sqrt{y})-1&amp;,y\geq 0\end{cases}$</p><p>第4步：对$F_Y(y)$求导，得$f_Y(y)$</p><p>$f_Y(y)=\frac{dF_Y(y)}{dy}=\begin{cases}0&amp;,y&lt;0\\y^{-\frac{1}{2}}\varphi(\sqrt{y})&amp;,y\geq 0\end{cases}$</p><div STYLE="page-break-after: always;"></div><h4 id="二维例题：-X-E-1-Y-U-0-1-X-Y-独立-Z-X-2Y-，求-f-Z-z"><a href="#二维例题：-X-E-1-Y-U-0-1-X-Y-独立-Z-X-2Y-，求-f-Z-z" class="headerlink" title="二维例题：$X$ ~ $E(1)$ , $Y$ ~ $U(0,1)$ , $X,Y$独立 , $Z=X+2Y$，求$f_Z(z)$"></a>二维例题：$X$ ~ $E(1)$ , $Y$ ~ $U(0,1)$ , $X,Y$独立 , $Z=X+2Y$，求$f_Z(z)$</h4><p>第1步：写$X,Y$的取值范围，确认$f_Z(z)$的定义域，定义域外$f_Z(z)=0$</p><p>$X \geq 0$ , $Y\in [0,1]$ $\Rightarrow$ $Z=X+2Y\geq 0$</p><p>第2步：写出$X,Y$的密度函数$f_X(x)$、$f_Y(y)$</p><p>$f_X(x)=\begin{cases}e^{-x}&amp;,x\geq 0\\0&amp;,Otherwise\end{cases}$</p><p>$f_Y(y)=\begin{cases}1&amp;,y\in[0,1]\\0&amp;,Otherwise\end{cases}$</p><p>第3步：写出$X,Y$的联合密度函数$f_{XY}(x,y)$</p><p>$f_{XY}(x,y)=f_X(x)f_Y(y)=\begin{cases}e^{-x}&amp;,x\geq 0,y\in[0,1]\\0&amp;,Otherwise\end{cases}$</p><p>第4步：确定积分区域（作图）</p><p>第5步：求$Z$的分布函数$F_Z(z)$</p><p>$F_Z(z)=P(Z\leq z)=P(X+2Y\leq z)=P(Y\leq \frac{z-X}{2})$ </p><script type="math/tex; mode=display">\begin{align}\Rightarrow F_Z(z)&=\begin{cases}    \int_0^ze^{-x}dx\int_0^{\frac{z-x}{2}}dy &, z\in[0,2]  \\\\    \int_0^{z-2}e^{-x}dx\int_0^1dy+\int_{z-2}^ze^{-x}dx\int_0^{\frac{z-x}{2}}dy &, z\geq 2 \\\\    0 &, Otherwise\end{cases}\\\\&=\begin{cases}    \frac{1}{2}(e^{-z}+z-1) &, z\in[0,2] \\\\    1-\frac{1}{2}e^{2-z}+\frac{1}{2}e^{-z} &, z\geq 2 \\\\    0 &, Otherwise\end{cases}\end{align}</script><p>第6步：对$F_Z(z)$求导，得$f_Z(z)$</p><script type="math/tex; mode=display">f_Z(z)=\frac{dF_Z(z)}{dz}=\begin{cases}    -\frac{1}{2}e^{-z}+\frac{1}{2} &, z\in[0,2] \\\\    \frac{1}{2}e^{2-z}-\frac{1}{2}e^{-z} &, z\geq 2 \\\\    0 &, Otherwise\end{cases}</script><div STYLE="page-break-after: always;"></div><h2 id="四、随机变量的数字特征"><a href="#四、随机变量的数字特征" class="headerlink" title="四、随机变量的数字特征"></a>四、随机变量的数字特征</h2><h3 id="1-数学期望"><a href="#1-数学期望" class="headerlink" title="1. 数学期望"></a>1. 数学期望</h3><p>离散型：$E(X)=\sum x_ip_i$</p><p>连续型：$E(X)=\int_{-\infty}^{+\infty}xf(x)dx$</p><p>随机变量函数：$E(Y)=E(h(X))$</p><p>性质：</p><ol><li>$E(C)=C$</li><li>$E(CX)=CE(X)$</li><li>$E(X\pm Y)=E(X)\pm E(Y)$</li><li>$X,Y$ 独立 $\Rightarrow$ $E(XY)=E(X)E(Y)$<h3 id="2-方差"><a href="#2-方差" class="headerlink" title="2. 方差"></a>2. 方差</h3>$D(X)=E(X-E(X))^2=E(X^2)-[E(X)]^2$</li></ol><p>标准差：$\sqrt{D(X)}$</p><p>性质：</p><ol><li>$D(C)=0$</li><li>$D(X+C)=D(X)$</li><li>$D(CX)=C^2D(X)$</li><li>$D(X\pm Y)=D(X)+D(Y)\pm 2Cov(X,Y)$</li><li>$X,Y$ 独立 $\Rightarrow$ $D(X\pm Y)=D(X)+D(Y)$</li><li>$D(X)=0 \Leftrightarrow P(X=E(X))=1$</li></ol><h3 id="3-协方差"><a href="#3-协方差" class="headerlink" title="3. 协方差"></a>3. 协方差</h3><p>$Cov(X,Y)=E(XY)-E(X)E(Y)$</p><p>性质：</p><ol><li>$Cov(X,X)=D(X)$</li><li>$Cov(X,Y)=Cov(Y,X)$</li><li>$Cov(aX,bY)=abCov(X,Y)$</li><li>$Cov(X_1+X_2,Y)=Cov(X_1,Y)+Cov(X_2,Y)$</li><li>$Cov(X,C)=0$</li><li>$X,Y$ 独立 $\Rightarrow$ $Cov(X,Y)=0$</li></ol><div STYLE="page-break-after: always;"></div><h3 id="4-相关系数"><a href="#4-相关系数" class="headerlink" title="4. 相关系数"></a>4. 相关系数</h3><p>随机变量$X$的标准化：$X^*=\frac{X-E(X)}{\sqrt{D(X)}}$</p><p>相关系数：$\rho_{XY}=Cov(X^<em>,Y^</em>)=\frac{Cov(X,Y)}{\sqrt{D(X)}\sqrt{D(Y)}}$</p><p>性质：</p><ol><li>$|\rho_{XY}|\leq 1$</li><li>$|\rho<em>{XY}|=1 \Leftrightarrow$ $X,Y$ 成线性关系，$\exists a,b\ s.t.\ P(Y=aX+b)=1$, $a\rho</em>{XY}&gt;0$</li></ol><div STYLE="page-break-after: always;"></div><h2 id="五、大数定律与中心极限定理"><a href="#五、大数定律与中心极限定理" class="headerlink" title="五、大数定律与中心极限定理"></a>五、大数定律与中心极限定理</h2><h3 id="1-大量独立同分布随机变量和的极限分布是正态分布（基础）"><a href="#1-大量独立同分布随机变量和的极限分布是正态分布（基础）" class="headerlink" title="1. 大量独立同分布随机变量和的极限分布是正态分布（基础）"></a>1. 大量独立同分布随机变量和的极限分布是正态分布（基础）</h3><p>$E(X_i)=\mu,D(X_i)=\sigma^2,Y=\sum X_i$</p><p>$\Rightarrow$ $E(Y)=n\mu,D(Y)=n\sigma^2$</p><p>$\Rightarrow$ $Y$ ~ $N(n\mu,n\sigma^2)$</p><p>$\Rightarrow$ 标准化： $\frac{Y-n\mu}{\sigma\sqrt{n}}$ ~ $N(0,1)$</p><h3 id="2-切比雪夫不等式（重点）"><a href="#2-切比雪夫不等式（重点）" class="headerlink" title="2. 切比雪夫不等式（重点）"></a>2. 切比雪夫不等式（重点）</h3><p>若$E(X)=\mu,D(X)=\sigma^2$，则对任意$\epsilon&gt;0$，有$P(|X-\mu|\geq \epsilon)\leq \frac{\sigma^2}{\epsilon^2}$</p><p>落在$\mu\pm\epsilon$外的概率不超过$\frac{\sigma^2}{\epsilon^2}$</p><h3 id="3-中心极限定理"><a href="#3-中心极限定理" class="headerlink" title="3. 中心极限定理"></a>3. 中心极限定理</h3><p>$\mathbb{X}=(X<em>1,X_2,\cdots,X_n)$独立同分布，$E(X_i)=\mu,0\lt D(X_i)=\sigma^2\lt\infty$，则$\forall x,\lim\limits</em>{n\rightarrow\infty}P\left(\frac{\sum X_i-n\mu}{\sigma\sqrt{n}}\leq x\right)=\varPhi(x)$</p><h4 id="例题：每台车床有-70-的时间在工作"><a href="#例题：每台车床有-70-的时间在工作" class="headerlink" title="例题：每台车床有$70\%$的时间在工作"></a>例题：每台车床有$70\%$的时间在工作</h4><h4 id="1-100台车床，求任意时刻有70至80台车床在工作的概率"><a href="#1-100台车床，求任意时刻有70至80台车床在工作的概率" class="headerlink" title="1. 100台车床，求任意时刻有70至80台车床在工作的概率"></a>1. 100台车床，求任意时刻有70至80台车床在工作的概率</h4><p>第1步：写出单个样本$X$的期望和方差</p><p>单个车床$X$ ~ $B(1,0.7)$ $\Rightarrow$ $E(X)=0.7,D(X)=0.21$</p><p>第2步：写出样本总体$Y$的期望和方差</p><p>记任意时刻工作的车床数为$Y$，<br>$E(Y)=100E(X)=70,D(Y)=100D(X)=21$</p><p>第3步：写出所求概率，对$Y$进行标准化，并用标准正态分布分布函数表示</p><p>$P(70\leq Y\leq 80)=P\left(\frac{70-70}{\sqrt{21}}\leq \frac{Y-70}{\sqrt{21}}\leq \frac{80-70}{\sqrt{21}}\right)=\varPhi\left(\frac{10}{\sqrt{21}}\right)-\varPhi(0)=\varPhi\left(2.18\right)-\varPhi(0)$</p><p>第4步：查表代入</p><h4 id="2-求以0-997的概率保证-任意时刻至少有80台车床在工作-所需的车床数"><a href="#2-求以0-997的概率保证-任意时刻至少有80台车床在工作-所需的车床数" class="headerlink" title="2. 求以0.997的概率保证 任意时刻至少有80台车床在工作 所需的车床数"></a>2. 求以0.997的概率保证 任意时刻至少有80台车床在工作 所需的车床数</h4><p>设所需车床数为$N$，任意某时刻工作的车床数为$X$，则$E(X)=0.7N,D(X)=0.21N$</p><p>$P(X\geq 80)=1-P(X\lt 80)=1-P\left(\frac{X-0.7N}{\sqrt{0.21N}}\lt \frac{80-0.7N}{\sqrt{0.21N}}\right)=1-\varPhi\left(\frac{80-0.7N}{\sqrt{0.21N}}\right)\geq 0.997$</p><p>$\Rightarrow$ $\varPhi\left(\frac{80-0.7N}{\sqrt{0.21N}}\right)\leq 0.003$ $\Rightarrow$ $\frac{80-0.7N}{\sqrt{0.21N}}\leq -2.75$</p><h3 id="4-伯努利大数定律"><a href="#4-伯努利大数定律" class="headerlink" title="4*. 伯努利大数定律"></a>4*. 伯努利大数定律</h3><p>$n$次独立重复试验中，事件A发生的次数$m$，$P(A)=p$，则对任意$\epsilon&gt;0$，有$\lim\limits_{n\rightarrow\infty}P\left(\left|\frac{m}{n}-p\right|\leq \epsilon\right)=1$</p><h3 id="5-辛钦大数定律"><a href="#5-辛钦大数定律" class="headerlink" title="5*. 辛钦大数定律"></a>5*. 辛钦大数定律</h3><p>$\mathbb{X}=(X<em>1,X_2,\cdots,X_n)$独立同分布，记$X_i=\begin{cases}1&amp;,A发生\\0&amp;,A不发生\end{cases}$，则对任意$\epsilon&gt;0$，有$\lim\limits</em>{n\rightarrow\infty}P\left(\left|\frac{\sum X_i}{n}-p\right|\leq \epsilon\right)=1$</p><h3 id="6-切比雪夫大数定律"><a href="#6-切比雪夫大数定律" class="headerlink" title="6*. 切比雪夫大数定律"></a>6*. 切比雪夫大数定律</h3><p>$\mathbb{X}=(X<em>1,X_2,\cdots,X_n)$不相关，$\exists E(X_i),D(X_i)&lt;\infty$，则对任意$\epsilon&gt;0$，有$\lim\limits</em>{n\rightarrow\infty}P\left(\left|\frac{\sum X_i}{n}-\frac{\sum E(X_i)}{n}\right|\leq \epsilon\right)=1$</p><div STYLE="page-break-after: always;"></div><h2 id="六、抽样分布"><a href="#六、抽样分布" class="headerlink" title="六、抽样分布"></a>六、抽样分布</h2><h3 id="1-统计量"><a href="#1-统计量" class="headerlink" title="1. 统计量"></a>1. 统计量</h3><ol><li>样本均值：$\overline{X}=\frac{1}{n}\sum X_i$</li><li>样本方差：$S^2=\frac{1}{n-1}\sum(X_i-\overline{X})^2$</li><li>样本标准差：$S=\sqrt{S^2}$</li><li>样本$k$阶原点矩：$A_k=\frac{1}{n}\sum X_i^k$</li><li>样本$k$阶中心矩：$B_k=\frac{1}{n}\sum(X_i-\overline{X})^k$</li></ol><p>$\overline{X}=A_1$，$S^2=\frac{n-1}{n}B_2$，$B_1=0$</p><h3 id="2-X-N-mu-sigma-2"><a href="#2-X-N-mu-sigma-2" class="headerlink" title="2. $X$~$N(\mu,\sigma^2)$"></a>2. $X$~$N(\mu,\sigma^2)$</h3><ol><li>分布名称：正态分布</li><li>上$\alpha$分位数：$u_\alpha$</li></ol><h3 id="3-X-chi-2-n"><a href="#3-X-chi-2-n" class="headerlink" title="3. $X$~$\chi^2(n)$"></a>3. $X$~$\chi^2(n)$</h3><ol><li>分布名称：卡方分布</li><li>概述：$X_1,X_2,\cdots,X_n$独立同分布，且$X_i$ ~ $N(0,1)$，则$X=\sum X_i^2$ ~ $\chi^2(n)$</li><li>上$\alpha$分位数：$\chi_\alpha^2(n)$</li><li>期望：$E(X)=n$</li><li>方差：$D(X)=2n$</li><li>$n\rightarrow\infty$时，$\chi^2(n)$近似于$N(n,2n)$</li><li>可加性：$X_i$ ~ $\chi^2(n_i)$ $\Rightarrow$ $\sum X_i$ ~ $\chi^2(\sum n_i)$</li></ol><h3 id="4-X-t-n"><a href="#4-X-t-n" class="headerlink" title="4. $X$~$t(n)$"></a>4. $X$~$t(n)$</h3><ol><li>分布名称：t分布</li><li>概述：$X$ ~ $N(0,1)$，$Y$ ~ $\chi^2(n)$，$X,Y$独立，$\frac{X}{\sqrt{\frac{Y}{n}}}$ ~ $t(n)$</li><li>上$\alpha$分位数：$t_\alpha(n)$</li><li>期望：$E(X)=0$ 对称性：$t<em>{1-\alpha}(n)=-t</em>\alpha(n)$</li><li>$n\rightarrow\infty$时，$t(n)$近似于$N(0,1)$</li></ol><h3 id="5-X-F-n-1-n-2"><a href="#5-X-F-n-1-n-2" class="headerlink" title="5. $X$~$F(n_1,n_2)$"></a>5. $X$~$F(n_1,n_2)$</h3><ol><li>分布名称：F分布</li><li>概述：$X_1$ ~ $\chi^2(n_1)$，$X_2$ ~ $\chi^2(n_2)$，$X_1,X_2$独立，$\frac{X_1/n_1}{X_2/n_2}$ ~ $F(n_1,n_2)$</li><li>上$\alpha$分位数：$F_\alpha(n_1,n_2)$</li><li>性质1：$F<em>{1-\alpha}(n_1,n_2)=\frac{1}{F</em>\alpha(n_2,n_1)}$</li><li>性质2：$P(F\leq F_\alpha(n_1,n_2))=1-\alpha$</li></ol><div STYLE="page-break-after: always;"></div><h3 id="6-单正态总体下的抽样分布"><a href="#6-单正态总体下的抽样分布" class="headerlink" title="6.单正态总体下的抽样分布"></a>6.单正态总体下的抽样分布</h3><ol><li>$\overline{X}$ ~ $N(\mu,\frac{\sigma^2}{n})$</li><li>$U=\frac{\overline{X}-\mu}{\sigma}{\sqrt{n}}$ ~ $N(0,1)$</li><li>$T=\frac{\overline{X}-\mu}{S}{\sqrt{n}}$ ~ $t(n-1)$</li><li>$C=\frac{(n-1)S^2}{\sigma^2}=\frac{1}{\sigma^2}\sum(X_i-\overline{X})^2$ ~ $\chi^2(n-1)$</li></ol><h3 id="7-两正态总体下的抽样分布"><a href="#7-两正态总体下的抽样分布" class="headerlink" title="7.两正态总体下的抽样分布"></a>7.两正态总体下的抽样分布</h3><ol><li>$\overline{X}-\overline{Y}$ ~ $N(\mu_1-\mu_2,\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2})$ $\Rightarrow$ $U=\frac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{\sqrt{\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2}}}$ ~ $N(0,1)$</li><li>$\frac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{S_w\sqrt{\frac{1}{n_1}+\frac{1}{n_2}}}$ ~ $t(n_1+n_2-2)$ $\Rightarrow$ $T=\frac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{S_w\sqrt{\frac{1}{n_1}+\frac{1}{n_2}}}$ ~ $t(n_1+n_2-2)$</li><li>$\frac{S_1^2/\sigma_1^2}{S_2^2/\sigma_2^2}$ ~ $F(n_1-1,n_2-1)$ $\Rightarrow$ $F=\frac{S_1^2/\sigma_1^2}{S_2^2/\sigma_2^2}$ ~ $F(n_1-1,n_2-1)$</li></ol><p>注：$S_w^2=\frac{(n_1-1)S_1^2+(n_2-1)S_2^2}{n_1+n_2-2}$</p><div STYLE="page-break-after: always;"></div><h2 id="七、参数估计（点估计）"><a href="#七、参数估计（点估计）" class="headerlink" title="七、参数估计（点估计）"></a>七、参数估计（点估计）</h2><h3 id="1-矩估计"><a href="#1-矩估计" class="headerlink" title="1. 矩估计"></a>1. 矩估计</h3><p>利用样本矩去估计总体矩，建立样本矩与总体矩的关系，解出参数</p><p>$A_1=\overline{X}=E(X)$，$A_2=\frac{1}{n}\sum X_i^2=E(X^2)$，$B_2=A_2-\overline{X}^2$</p><p>$\Rightarrow$ $\mu=A_1$，$\sigma^2=B_2$</p><h3 id="2-极大似然估计"><a href="#2-极大似然估计" class="headerlink" title="2. 极大似然估计"></a>2. 极大似然估计</h3><ol><li>写出总体的密度函数$f(x;\theta)$</li><li>写出样本的似然函数$L(\theta)=\prod f(x_i;\theta)$</li><li>对$L(\theta)$取对数，得到对数似然函数$\ln L(\theta)$</li><li>对$\ln L(\theta)$求导，令其等于0，解出$\theta$的值</li><li>多个参数时，对每个参数分别求偏导，令其等于0，得到方程组，解出每个参数的值</li></ol><h3 id="3-点估计的优良性"><a href="#3-点估计的优良性" class="headerlink" title="3. 点估计的优良性"></a>3. 点估计的优良性</h3><ol><li>无偏性：$E(\hat{\theta})=\theta$</li><li>有效性：$D(\hat{\theta})\leq D(\tilde{\theta})$，$\hat{\theta}=\overline{X}$时最有效</li></ol><h4 id="例题：设-X-1-X-2-cdots-X-n-是来自总体-X-的样本，-X-的密度函数为-f-x-sigma-frac-1-2-sigma-e-frac-x-sigma-，其中-sigma-gt-0-为未知参数，求-sigma-的矩估计和极大似然估计。"><a href="#例题：设-X-1-X-2-cdots-X-n-是来自总体-X-的样本，-X-的密度函数为-f-x-sigma-frac-1-2-sigma-e-frac-x-sigma-，其中-sigma-gt-0-为未知参数，求-sigma-的矩估计和极大似然估计。" class="headerlink" title="例题：设$X_1,X_2,\cdots,X_n$是来自总体$X$的样本，$X$的密度函数为$f(x;\sigma)=\frac{1}{2\sigma}e^{-\frac{|x|}{\sigma}}$，其中$\sigma&gt;0$为未知参数，求$\sigma$的矩估计和极大似然估计。"></a>例题：设$X_1,X_2,\cdots,X_n$是来自总体$X$的样本，$X$的密度函数为$f(x;\sigma)=\frac{1}{2\sigma}e^{-\frac{|x|}{\sigma}}$，其中$\sigma&gt;0$为未知参数，求$\sigma$的矩估计和极大似然估计。</h4><p>矩估计</p><p>$E(X)=\int<em>{-\infty}^{+\infty}xf(x;\sigma)dx=\frac{1}{2\sigma}\int</em>{-\infty}^{+\infty}xe^{-\frac{|x|}{\sigma}}dx=0$，无法求出$\sigma$，故用二阶矩求解</p><p>$E(X^2)=\int<em>{-\infty}^{+\infty}x^2f(x;\sigma)dx=\frac{1}{2\sigma}\int</em>{-\infty}^{+\infty}x^2e^{-\frac{|x|}{\sigma}}dx=2\sigma^2$</p><p>$A_2=2\hat\sigma^2$，解得$\hat\sigma=\sqrt{\frac{A_2}{2}}$</p><p>极大似然估计</p><p>$L(\hat\sigma)=\prod f(x_i;\hat\sigma)=\prod\frac{1}{2\hat\sigma}e^{-\frac{|x_i|}{\hat\sigma}}=\frac{1}{2^n\hat\sigma^n}e^{-\frac{\sum|x_i|}{\hat\sigma}}$</p><p>$\ln L(\hat\sigma)=-n\ln(2\hat\sigma)-\frac{\sum|x_i|}{\hat\sigma}$</p><p>$\frac{d\ln L(\hat\sigma)}{d\hat\sigma}=-\frac{n}{\hat\sigma}+\frac{\sum|x_i|}{\hat\sigma^2}=0$，解得$\hat\sigma=\frac{\sum|x_i|}{n}$</p><div STYLE="page-break-after: always;"></div><h2 id="八、假设检验"><a href="#八、假设检验" class="headerlink" title="八、假设检验"></a>八、假设检验</h2><h3 id="1-基本步骤"><a href="#1-基本步骤" class="headerlink" title="1. 基本步骤"></a>1. 基本步骤</h3><ol><li>建立原假设$H_0$和备择假设$H_1$，确定显著性水平$\alpha$</li><li>选取检验统计量$U$，此时拒绝域$C={|U| \ge u_\frac{\alpha}{2}}$</li><li>计算检验统计量的值$u$，若$u\in C$，则拒绝$H_0$，否则接受$H_0$</li></ol><h3 id="2-单个正态总体的假设检验"><a href="#2-单个正态总体的假设检验" class="headerlink" title="2. 单个正态总体的假设检验"></a>2. 单个正态总体的假设检验</h3><h4 id="H-0-mu-mu-0-，-H-1-mu-neq-mu-0"><a href="#H-0-mu-mu-0-，-H-1-mu-neq-mu-0" class="headerlink" title="$H_0:\mu=\mu_0$，$H_1:\mu\neq\mu_0$"></a>$H_0:\mu=\mu_0$，$H_1:\mu\neq\mu_0$</h4><ol><li>$\sigma^2$已知，$U=\frac{\overline{X}-\mu_0}{\sigma/\sqrt{n}}$ ~ $N(0,1)$</li><li>$\sigma^2$未知，$T=\frac{\overline{X}-\mu_0}{S/\sqrt{n}}$ ~ $t(n-1)$<h4 id="H-0-sigma-2-sigma-0-2-，-H-1-sigma-2-neq-sigma-0-2"><a href="#H-0-sigma-2-sigma-0-2-，-H-1-sigma-2-neq-sigma-0-2" class="headerlink" title="$H_0:\sigma^2=\sigma_0^2$，$H_1:\sigma^2\neq\sigma_0^2$"></a>$H_0:\sigma^2=\sigma_0^2$，$H_1:\sigma^2\neq\sigma_0^2$</h4>$\chi^2=\frac{(n-1)S^2}{\sigma_0^2}$ ~ $\chi^2(n-1)$</li></ol><h3 id="3-两个正态总体的假设检验"><a href="#3-两个正态总体的假设检验" class="headerlink" title="3. 两个正态总体的假设检验"></a>3. 两个正态总体的假设检验</h3><h4 id="H-0-mu-1-mu-2-，-H-1-mu-1-neq-mu-2"><a href="#H-0-mu-1-mu-2-，-H-1-mu-1-neq-mu-2" class="headerlink" title="$H_0:\mu_1=\mu_2$，$H_1:\mu_1\neq\mu_2$"></a>$H_0:\mu_1=\mu_2$，$H_1:\mu_1\neq\mu_2$</h4><ol><li>$\sigma_1^2,\sigma_2^2$已知，$U=\frac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{\sqrt{\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2}}}$ ~ $N(0,1)$</li><li>$\sigma_1^2,\sigma_2^2$未知，$T=\frac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{S_w\sqrt{\frac{1}{n_1}+\frac{1}{n_2}}}$ ~ $t(n_1+n_2-2)$<h4 id="H-0-sigma-1-2-sigma-2-2-，-H-1-sigma-1-2-neq-sigma-2-2"><a href="#H-0-sigma-1-2-sigma-2-2-，-H-1-sigma-1-2-neq-sigma-2-2" class="headerlink" title="$H_0:\sigma_1^2=\sigma_2^2$，$H_1:\sigma_1^2\neq\sigma_2^2$"></a>$H_0:\sigma_1^2=\sigma_2^2$，$H_1:\sigma_1^2\neq\sigma_2^2$</h4>$F=\frac{S_1^2}{S_2^2}$ ~ $F(n_1-1,n_2-1)$</li></ol>]]></content>
    
    
    <summary type="html">考前3天速通99分概率论の复习笔记</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.cclmsy.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="http://www.cclmsy.cc/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>教程|本地化部署一个QQ机器人</title>
    <link href="http://www.cclmsy.cc/posts/11f0411.html"/>
    <id>http://www.cclmsy.cc/posts/11f0411.html</id>
    <published>2023-10-06T06:00:00.000Z</published>
    <updated>2024-01-18T08:53:58.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-序言"><a href="#0-序言" class="headerlink" title="0.序言"></a>0.序言</h1><ol><li>本教程主要面向<strong>Windows系统</strong>用户</li><li>教程从0开始全程详细指导，0基础萌新请放心食用🍕</li><li>如果你遇到了问题，在提问前，请仔细检查是否哪一步有遗漏。</li><li>如果你确定自己的操作没问题，可以在评论区里提问。注意留言时请填写正确的邮箱以确保能收到站长的回复。</li></ol><h1 id="1-搭建前的准备工作："><a href="#1-搭建前的准备工作：" class="headerlink" title="1.搭建前的准备工作："></a>1.搭建前的准备工作：</h1><h2 id="1-1-需要用到的工具"><a href="#1-1-需要用到的工具" class="headerlink" title="1.1.需要用到的工具"></a>1.1.需要用到的工具</h2><ul><li>一台24小时开机联网的服务器/计算机</li><li>操作系统：Windows10</li><li>文本编辑器（强烈推荐使用VSCode）</li><li>Python3.11.5</li><li>一个闲置的QQ账号</li></ul><h2 id="1-2-Python安装指南"><a href="#1-2-Python安装指南" class="headerlink" title="1.2.Python安装指南"></a>1.2.Python安装指南</h2><p>参考我的这篇文章：<a href="/posts/c34e2ac0.html">Python安装指南</a></p><p>10月2日发布了Python3.12.0版本，站长在10月5日安装机器人框架依赖时会报以下错误：<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ERROR: </span>Could not build wheels for yarl, httptools, multidict, which is required to install pyproject.toml-based projects</span><br><span class="line">安装依赖失败! 请手动安装依赖.</span><br></pre></td></tr></table></figure><br>尝试了几种方法没有解决，故使用之前成功过的Python3.11.5版本。</p><p>Python 3.11.5官方下载链接：<a href="https://www.python.org/downloads/release/python-3115/">Python 3.11.5</a><br>国内下载速度可能会有点慢，有条件的可以通过国际网络访问。<br>站长这里提供Windows64位版本的下载：<a href="http://source.cclmsy.cc/Tools/python-3.11.5-amd64.exe">python-3.11.5-amd64</a></p><h2 id="1-3-VSCode安装指南"><a href="#1-3-VSCode安装指南" class="headerlink" title="1.3.VSCode安装指南"></a>1.3.VSCode安装指南</h2><p>VSCode是一款轻量化的IDE，支持市面上绝大多数编程语言，具有良好的扩展性，且具有非常友好的代码补全功能。<del>是CC站长的最爱</del><br>下载完成后直接一路确定傻瓜式安装即可//部分自定义配置说明如下：<br><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_12.png" alt="VSCode"></p><p>VSCode官网：<a href="https://code.visualstudio.com/">Visual Studio Code</a><br>同样国内下载比较慢，站长这里提供Windows64位1.82.2版本的下载，VSCode支持软件内更新到最新版本：<a href="http://source.cclmsy.cc/Tools/VSCodeUserSetup-x64-1.82.2.exe">VSCodeUserSetup-x64-1.82.2</a></p><h1 id="2-安装Nonebot框架"><a href="#2-安装Nonebot框架" class="headerlink" title="2.安装Nonebot框架"></a>2.安装Nonebot框架</h1><h2 id="2-1-创建文件夹"><a href="#2-1-创建文件夹" class="headerlink" title="2.1.创建文件夹"></a>2.1.创建文件夹</h2><p>创建一个文件夹用于存放项目，然后用VSCode打开这个文件夹。<br><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_13.png" alt="InstallNonebot1"></p><h2 id="2-2-安装pipx"><a href="#2-2-安装pipx" class="headerlink" title="2.2.安装pipx"></a>2.2.安装pipx</h2><p>点击“终端-新建终端”（或直接按住Ctrl+Shift+`）创建一个终端，在终端中输入以下命令：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install --<span class="keyword">user</span> <span class="title">pipx</span></span><br><span class="line">python -m pipx ensurepath</span><br></pre></td></tr></table></figure><br>如果出现以下提示，请调整你的账户环境变量：<br><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_14.png" alt="InstallNonebot2"><br>调整账户的环境变量参考：<a href="/posts/c34e2ac0.html">教程|Python安装指南</a></p><p><strong>安装完成后，关闭当前VSCode窗口，重启VSCode后才会生效。</strong></p><h2 id="2-3-安装Nonebot脚手架"><a href="#2-3-安装Nonebot脚手架" class="headerlink" title="2.3.安装Nonebot脚手架"></a>2.3.安装Nonebot脚手架</h2><p>创建一个终端，在终端中输入以下命令：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipx install nb-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure><br><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_15.png" alt="InstallNonebot3"><br>如果出现无法找到<code>pipx</code>命令的情况（例如出现“Command not found”字样），请确认你在上一步中账户环境变量设置正确，且<strong>完全重启</strong>VSCode。<br>如果你确信自己的所有配置完全正确，请尝试重启你的计算机。</p><h1 id="3-创建项目"><a href="#3-创建项目" class="headerlink" title="3.创建项目"></a>3.创建项目</h1><p>在终端中输入以下命令：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nb create</span></span><br></pre></td></tr></table></figure><br>选择“bootstrap (初学者或用户)”，回车。<br><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_16.png" alt="Create1"></p><p>等待资源加载，加载完成后进行如下配置：<br> (键盘上下键移动光标，空格选中，回车确认)<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">[?]</span> 项目名称: <span class="comment">[为你的项目取个名字吧！]</span> (项目名称建议由英文字母和数字构成，因为部分插件可能不支持包含中文的路径)</span><br><span class="line"><span class="comment">[?]</span> 要使用哪些驱动器? FastAPI (FastAPI 驱动器) </span><br><span class="line"><span class="comment">[?]</span> 要使用哪些适配器? OneBot V11 (OneBot V11 协议) </span><br><span class="line"><span class="comment">[?]</span> 立即安装依赖? y</span><br><span class="line"><span class="comment">[?]</span> 创建虚拟环境? y</span><br></pre></td></tr></table></figure><br><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_17.png" alt="Create2"><br>脚手架会自动创建并引入所需的依赖包。</p><p>最后选择安装内置插件<code>echo</code>，这是一个简单的复读回显插件，可以用于测试你的机器人是否正常运行：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[?]</span> 要使用哪些内置插件? echo</span><br></pre></td></tr></table></figure><br>请注意，如果你这一步没有安装<code>echo</code>，<strong>后续将无法进行补装</strong>。<br>如果你操作失误没有安装，请删除当前项目文件夹并返回第<code>3</code>节开头。</p><p>出现以下提示则项目创建成功<br><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_18.png" alt="Create3"></p><p>在终端中输入以下命令进入项目文件夹：<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cd</span><span class="meta"> [你的项目的名字]</span></span><br></pre></td></tr></table></figure><br><strong>请注意：后续的操作均需要你的终端处于项目文件夹中。</strong><br>如果你使用的是VSCode，方便起见，你可以直接选择打开项目文件夹作为VSCode工作文件夹：<br><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_22.png" alt="Create4"><br>这样后续VSCode新建终端就会默认处于项目文件夹中。</p><h1 id="4-编辑配置文件"><a href="#4-编辑配置文件" class="headerlink" title="4.编辑配置文件"></a>4.编辑配置文件</h1><p>脚手架会在项目文件夹中自动创建一个配置文件<code>.env.prod</code>，但你仍然需要进行一些自定义配置。</p><p>打开项目文件夹下的<code>.env.prod</code>文件，编辑内容如下：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DRIVER</span>=~fastapi  <span class="comment"># 脚手架自动生成的配置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">HOST</span>=<span class="number">127.0</span>.<span class="number">0.1</span>  <span class="comment"># 配置 NoneBot 监听的 IP / 主机名</span></span><br><span class="line"><span class="attr">PORT</span>=<span class="number">23333</span>  <span class="comment"># 配置 NoneBot 监听的端口</span></span><br></pre></td></tr></table></figure><br>其中<code>HOST</code><strong>必须</strong>设为<code>127.0.0.1</code>（即localhost）<br><code>PORT</code>可以选择你喜欢的数字，范围在0-65535之间。不设置默认为8080，但尽量在15000-50000之间选择，避免和已有的端口发生冲突。</p><p>此外，你可以选择设置超级用户<code>SUPERUSERS</code>、命令起始字符<code>COMMAND_START</code>和命令分割字符<code>COMMAND_SEP</code>，你可以在有需要使用这些设置的时候再行配置。<br>部分插件可能会区分普通用户和超级用户（管理员），可以在<code>SUPERUSERS</code>中设置超级用户<br>设置命令起始字符后，机器人只响应以起始字符开头的命令。<br>设置命令分割字符后，你可以用一个语句包含多个命令，机器人会先按分割字符将命令分开，再按顺序处理。<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SUPERUSERS</span>=[<span class="string">&quot;1234567890&quot;</span>,<span class="string">&quot;2333333333&quot;</span>]  <span class="comment"># 配置 NoneBot 的超级用户，可以是多个（你的QQ号）（可选）</span></span><br><span class="line"><span class="attr">COMMAND_START</span>=[<span class="string">&quot;/&quot;</span>]  <span class="comment"># 配置命令起始字符（可选）</span></span><br><span class="line"><span class="attr">COMMAND_SEP</span>=[<span class="string">&quot;.&quot;</span>]  <span class="comment"># 配置命令分割字符（可选）</span></span><br></pre></td></tr></table></figure></p><h1 id="5-安装插件"><a href="#5-安装插件" class="headerlink" title="5.安装插件"></a>5.安装插件</h1><h2 id="5-1-管理插件的方法"><a href="#5-1-管理插件的方法" class="headerlink" title="5.1.管理插件的方法"></a>5.1.管理插件的方法</h2><blockquote><p>本节旨在让读者了解操作管理插件的流程，选择自己喜欢的管理插件的方式。<br>你也可以选择先跳过本节，在后面的教程中会默认提供方法一的命令。</p></blockquote><p>Nonebot提供了三种管理插件的方法，请确保你的终端当前处于项目文件夹中。<br>其中使用<code>pip</code>安装（方法三）需要手动激活Python虚拟环境，方法一、二管理插件时会自动使用虚拟环境。</p><h3 id="5-1-1-方法一：命令行管理"><a href="#5-1-1-方法一：命令行管理" class="headerlink" title="5.1.1.方法一：命令行管理"></a>5.1.1.方法一：命令行管理</h3><p>在终端输入以下命令：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nb plugin install <span class="variable">&lt;插件名称&gt;</span>  <span class="comment"># 安装插件</span></span><br><span class="line">nb plugin uninstall <span class="variable">&lt;插件名称&gt;</span>  <span class="comment"># 卸载插件</span></span><br><span class="line">nb plugin update <span class="variable">&lt;插件名称&gt;</span>  <span class="comment"># 升级插件</span></span><br><span class="line">nb plugin list  <span class="comment"># 列出商店所有插件</span></span><br><span class="line">nb plugin search [关键词]  <span class="comment"># 搜索商店插件</span></span><br></pre></td></tr></table></figure></p><h3 id="5-1-2-方法二：交互式管理"><a href="#5-1-2-方法二：交互式管理" class="headerlink" title="5.1.2.方法二：交互式管理"></a>5.1.2.方法二：交互式管理</h3><p>在终端输入以下命令：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nb plugin</span></span><br></pre></td></tr></table></figure><br>将进入控制台交互模式，键盘上下键移动光标，空格选中，回车确认。<br><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_21.png" alt="Plugin1"><br>按照提示输入插件名称即可。</p><h3 id="5-1-3-方法三：使用pip安装"><a href="#5-1-3-方法三：使用pip安装" class="headerlink" title="5.1.3.方法三：使用pip安装"></a>5.1.3.方法三：使用pip安装</h3><p>如果你在第3节中正确创建了项目，那么你的项目文件夹中会有一个<code>.venv</code>文件夹，这是项目的Python虚拟环境文件夹。</p><p>值得一提的是，虚拟环境是Python提供的一个非常实用的功能，它可以将项目环境和全局环境隔离。<br>你可以在虚拟环境中安装和管理项目特定的Python库和依赖项，而不会与全局Python环境相互影响。</p><p>在终端输入以下命令以激活虚拟环境：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\.venv\Scripts\<span class="built_in">activate</span></span><br></pre></td></tr></table></figure><br>如果遇到“禁止运行脚本”的报错，可以参考我的这篇文章来解决：<a href="/posts/28dedfa6.html">教程|Windows系统无法激活Python虚拟环境的解决方案</a><br>如果命令行开头出现一个括号，内容为你的项目名称，则代表Python虚拟环境已经成功激活。</p><p>接下来你可以使用pip命令来管理你的插件：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install <span class="variable">&lt;插件名称&gt;</span>  <span class="comment"># 安装插件</span></span><br><span class="line">pip uninstall <span class="variable">&lt;插件名称&gt;</span>  <span class="comment"># 卸载插件</span></span><br><span class="line">pip install --upgrade <span class="variable">&lt;插件名称&gt;</span>  <span class="comment"># 升级插件</span></span><br><span class="line">pip list  <span class="comment"># 列出当前已经安装的插件（包含Nonebot依赖包）</span></span><br></pre></td></tr></table></figure><br><code>pip</code>相比前两种方法，缺少了列出和搜索商店插件的功能，多了可以查询当前已经安装了的插件的功能。<br>在忘记已经安装的插件或插件名情况下查询比较方便（当然你也可以自己在<code>.\.venv\Lib\site-packages</code>里查看）。</p><h2 id="5-2-安装go-cqhttp"><a href="#5-2-安装go-cqhttp" class="headerlink" title="5.2.安装go-cqhttp"></a>5.2.安装go-cqhttp</h2><p><code>go-cqhttp</code>框架提供了接收QQ事件与调用QQ的API的能力，是QQ机器人的核心组件。<br>NoneBot插件商店中提供了这个框架的插件，插件名称为：<code>nonebot-plugin-gocqhttp</code><br>在终端中输入以下命令安装插件：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nb <span class="keyword">plugin</span> install nonebot-<span class="keyword">plugin</span>-gocqhttp</span><br></pre></td></tr></table></figure><br>安装完成后，在终端中输入以下命令运行机器人：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nb <span class="built_in">run</span></span><br></pre></td></tr></table></figure><br>出现以下提示则安装和运行成功：<br><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_23.png" alt="gocq1"><br>按住Ctrl单击链接进入<code>go-cqhttp</code>的WebUI界面<br><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_24.png" alt="gocq2"></p><h1 id="6-登录QQ机器人与检查"><a href="#6-登录QQ机器人与检查" class="headerlink" title="6.登录QQ机器人与检查"></a>6.登录QQ机器人与检查</h1><h2 id="6-1-登录QQ机器人"><a href="#6-1-登录QQ机器人" class="headerlink" title="6.1.登录QQ机器人"></a>6.1.登录QQ机器人</h2><p>点击左上角“添加账号”，输入要部署的QQ账号，密码留空，设备类型选择“Android Watch”：<br>（注：也可以选择账号密码登录，但可能出现账号被风控无法登录的情况，手表协议登录相对比较稳定。）<br><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_25.png" alt="QQLogin1"><br>添加完成后点击启动，待加载出二维码后点击“显示登录二维码”。<br>用你的手机登录要部署的QQ账号，扫描二维码登录。<br><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_26.png" alt="QQLogin2"><br>登陆完成后会有消息提示如下：<br><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_27.png" alt="QQLogin3"></p><h2 id="6-2-检查QQ机器人是否正常运行"><a href="#6-2-检查QQ机器人是否正常运行" class="headerlink" title="6.2.检查QQ机器人是否正常运行"></a>6.2.检查QQ机器人是否正常运行</h2><p>登录你自己的QQ账号，添加机器人为QQ好友，然后按以下格式发送给机器人消息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\<span class="built_in">echo</span> [自定义消息]</span><br></pre></td></tr></table></figure><br>请注意，不论你有没有配置命令起始字符，在这里echo的开头<strong>必须包含”\“字符</strong>。<br>如果机器人回复了和自定义消息相同的内容，那么恭喜你，你已经成功地完成了QQ机器人的部署。<br><div class="hide-block"><button type="button" class="hide-button" style="background-color:  --theme-color;">点我预览示例    </button><div class="hide-content"><p><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_28.png" alt="image" style="zoom:67%;" /></p></div></div></p><p>这一步完成后，建议将项目文件夹复制一份作为备份。<br>这样后续重置机器人时，只需要将备份复制一份回来即可。</p><h1 id="7-为你的QQ机器人赋能"><a href="#7-为你的QQ机器人赋能" class="headerlink" title="7.为你的QQ机器人赋能"></a>7.为你的QQ机器人赋能</h1><p>完成了QQ机器人部署后，你就可以为你的机器人添加插件以实现各种各样的功能。插件的管理方式见<code>5.1</code>节。<br>你可以在官方插件商店找到你需要的插件，根据插件开发者提供的的文档进行安装与配置：<a href="https://nonebot.dev/store/plugins">插件商店</a>。<br>如果你有足够的能力和精力，可以学习NoneBot文档，编写开发自己的插件：<a href="https://nonebot.dev/docs/">NoneBot文档</a>。</p><h1 id="8-注意事项"><a href="#8-注意事项" class="headerlink" title="8.注意事项"></a>8.注意事项</h1><ol><li>机器人的运行进程由终端调起，在你运行机器人的过程中，请务必保证你原来的终端窗口一直保持开启状态。如果你使用的是VSCode之类的IDE，请不要关闭你终端所在的窗口。</li><li>机器人以你的计算机作为服务器端，BOT使用期间请务必保证你的服务器/计算机处于开机联网状态。</li><li>Windows系统时常会进行自动更新，必要时可以关闭自动更新。</li></ol>]]></content>
    
    
    <summary type="html">拥有一个自己的QQ机器人难道不是一件很酷的事情吗//</summary>
    
    
    
    <category term="教程" scheme="http://www.cclmsy.cc/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Python" scheme="http://www.cclmsy.cc/tags/Python/"/>
    
    <category term="教程" scheme="http://www.cclmsy.cc/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="机器人" scheme="http://www.cclmsy.cc/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>教程|Windows系统无法激活Python虚拟环境的解决方案</title>
    <link href="http://www.cclmsy.cc/posts/28dedfa6.html"/>
    <id>http://www.cclmsy.cc/posts/28dedfa6.html</id>
    <published>2023-10-05T13:00:00.000Z</published>
    <updated>2024-01-18T08:53:58.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="情况描述"><a href="#情况描述" class="headerlink" title="情况描述"></a>情况描述</h1><p>在Windows系统终端激活Python虚拟环境时可能出现以下报错（假设你的虚拟环境名为“.venv”）：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS (yourpath<span class="string">\yourProj)&gt;</span> .<span class="string">\.venv\Scripts\activate</span></span><br><span class="line">.<span class="string">\.venv\Scripts\activate</span> : 无法加载文件 (yourpath<span class="string">\yourProj)\.venv\Scripts\activate.ps1，因为在此系统上禁止运行脚本。</span></span><br><span class="line">有关详细信息，请参阅 https:<span class="regexp">/go.microsoft.com/fwlink/</span>?LinkID=<span class="number">135170</span> 中的 about_Execution_Policies。</span><br><span class="line">所在位置 行:<span class="number">1</span> 字符: <span class="number">1</span></span><br><span class="line">+ .<span class="string">\.venv\Scripts\activate</span></span><br><span class="line">+ ~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">    + CategoryInfo          : SecurityError: (:) []，PSSecurityException</span><br><span class="line">    + FullyQualifiedErrorId : UnauthorizedAccess</span><br></pre></td></tr></table></figure></p><h1 id="报错原因"><a href="#报错原因" class="headerlink" title="报错原因"></a>报错原因</h1><p>Windows系统具有执行策略（Execution Policy），导致无法运行虚拟环境的激活脚本。<br>执行策略是Windows中的一种安全机制，它可以防止执行不信任的脚本。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol><li>点击屏幕左下角Windows徽标打开“开始”菜单栏，在搜索栏搜索“PowerShell”，然后单击 “以管理员身份运行”。<br><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_19.png" alt="Python_venv1"></li><li>在弹出的终端中输入以下命令，回车：<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Set</span>-ExecutionPolicy <span class="comment">RemoteSigned</span></span><br></pre></td></tr></table></figure></li><li>弹出询问时输入“y”，回车：<br><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_20.png" alt="Python_venv2"></li><li>没有消息提示，退出 PowerShell 终端，回到你激活Python虚拟环境的终端。此时可以正常激活Python虚拟环境：<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS (yourpath<span class="string">\yourProj)&gt;</span> .<span class="string">\.venv\Scripts\activate</span></span><br><span class="line">(yourProj) PS (yourpath<span class="string">\yourProj)&gt;</span> </span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">教程|Windows系统无法激活Python虚拟环境的解决方案</summary>
    
    
    
    <category term="教程" scheme="http://www.cclmsy.cc/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Python" scheme="http://www.cclmsy.cc/tags/Python/"/>
    
    <category term="教程" scheme="http://www.cclmsy.cc/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>教程|Python安装指南</title>
    <link href="http://www.cclmsy.cc/posts/c34e2ac0.html"/>
    <id>http://www.cclmsy.cc/posts/c34e2ac0.html</id>
    <published>2023-10-05T09:00:00.000Z</published>
    <updated>2024-01-18T08:53:58.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-选择正确的版本，下载安装包"><a href="#1-选择正确的版本，下载安装包" class="headerlink" title="1. 选择正确的版本，下载安装包"></a>1. 选择正确的版本，下载安装包</h2><p>根据你的实际需要选择Python发行版本。值得注意的是，编程语言包并不是越新越好的，不同版本的Python之间可能会产生兼容性问题。<br>如果你不确定你的项目需要哪个版本，请查阅您可能需要使用到的插件的文档或咨询有相关经验的前辈。</p><ul><li>注：Python于10月2日发布3.12.0版本，站长今天使用该版本安装某项目依赖包时发生兼容性错误//本教程采用先前成功过的Python3.11.5版本。</li></ul><p>Python 3.11.5官方下载链接：<a href="https://www.python.org/downloads/release/python-3115/">Python 3.11.5</a><br>拉到页面底部，<strong>根据你的系统选择对应的版本下载</strong>，站长使用的是64位Windows系统，国内大多数普通用户使用的一般也是这个版本。<br><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_01.png" alt="Download"></p><p>国内下载速度可能会有点慢，有条件的可以通过国际网络访问<br>站长这里提供Python 3.11.5 Windows64位版本的下载：<a href="http://source.cclmsy.cc/Tools/python-3.11.5-amd64.exe">python-3.11.5-amd64</a></p><h2 id="2-安装Python到计算机"><a href="#2-安装Python到计算机" class="headerlink" title="2. 安装Python到计算机"></a>2. 安装Python到计算机</h2><p>下载完成后，打开文件所在的文件夹，选中文件右键，以管理员身份运行，按下图所示的步骤安装<br><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_02.png" alt="Install1"><br><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_03.png" alt="Install2"><br><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_04.png" alt="Install3"><br><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_05.png" alt="Install4"><br><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_06.png" alt="Install5"></p><h2 id="3-检查环境变量"><a href="#3-检查环境变量" class="headerlink" title="3. 检查环境变量"></a>3. 检查环境变量</h2><ol><li>打开设置，搜索“环境变量”，点击“编辑账户的环境变量”<br><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_07.png" alt="Env1"></li><li>在弹出的页面单击选中“Path”，点击“编辑”<br><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_08.png" alt="Env2"></li><li>在弹出的页面查看是否包含这两项。若没有，则添加这两项。（如果你在上一步自定义了安装路径，则添加对应的路径）<br><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_09.png" alt="Env3"></li><li>依次点击上面两个弹窗的“确定”，才能正确保存PATH。如果不确定是否正确保存，可以回去看一下//</li></ol><h2 id="4-检查是否正确安装了Python"><a href="#4-检查是否正确安装了Python" class="headerlink" title="4. 检查是否正确安装了Python"></a>4. 检查是否正确安装了Python</h2><ol><li>键盘按Windows+R，输入cmd运行终端<br><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_10.png" alt="Check1"></li><li>输入python回车，若显示版本号则表示安装成功<br><img src="http://source.cclmsy.cc/Images/Posts/BOT/BOT_11.png" alt="Check2"></li></ol>]]></content>
    
    
    <summary type="html">安装Python、配置Python环境（附安装包）</summary>
    
    
    
    <category term="教程" scheme="http://www.cclmsy.cc/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Python" scheme="http://www.cclmsy.cc/tags/Python/"/>
    
    <category term="教程" scheme="http://www.cclmsy.cc/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Introduction</title>
    <link href="http://www.cclmsy.cc/posts/ed318fdc.html"/>
    <id>http://www.cclmsy.cc/posts/ed318fdc.html</id>
    <published>2023-09-25T12:00:00.000Z</published>
    <updated>2023-11-05T14:13:27.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博客介绍"><a href="#博客介绍" class="headerlink" title="博客介绍"></a>博客介绍</h1><p>欢迎来到CCLMSY的Blog！<br>本博客自2023/9/26开始建设，于2023/10/4正式发布。<br>博客不定期更新算法竞赛题解、学习心得、模板笔记等等内容//<br><del>也可能会日常发疯（毕竟带学生哪有不疯的）</del><br>网站已开启邮件提醒功能。正确输入邮箱后，评论收到回复将有邮件提醒。</p><p>已知问题：</p><ul><li>由于书写时使用的MarkDown版本不同，部分内容的MarkDown格式或Katex公式渲染可能会不正确。如有发现请在评论区指正！非常感谢！（鞠躬）</li><li>使用国际网络访问可能导致无法正常使用自定义美化功能，目前尚未查明原因。</li></ul><p>关于网站、关于站长：见<a href="/about">关于</a>栏目<br>维护日志：见<a href="/site/time">旧时光</a>栏目</p>]]></content>
    
    
    <summary type="html">This is an introduction</summary>
    
    
    
    <category term="其他" scheme="http://www.cclmsy.cc/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>动态规划-其他</title>
    <link href="http://www.cclmsy.cc/posts/4014d4be.html"/>
    <id>http://www.cclmsy.cc/posts/4014d4be.html</id>
    <published>2023-09-22T12:00:00.000Z</published>
    <updated>2023-10-22T06:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-子序列问题"><a href="#一-子序列问题" class="headerlink" title="一.子序列问题"></a>一.子序列问题</h1><h2 id="1-最长公共子序列-LCS"><a href="#1-最长公共子序列-LCS" class="headerlink" title="1.最长公共子序列(LCS)"></a>1.最长公共子序列(LCS)</h2><p>O(mn)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 1005</span></span><br><span class="line">ll a[N]=&#123;<span class="number">0</span>&#125;,b[N]=&#123;<span class="number">0</span>&#125;,dp[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m) cin &gt;&gt; b[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j]) dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-最长上升子序列"><a href="#2-最长上升子序列" class="headerlink" title="2.最长上升子序列"></a>2.最长上升子序列</h2><h3 id="2-1-DP"><a href="#2-1-DP" class="headerlink" title="2.1.DP"></a>2.1.DP</h3><p>$O(n^2)$ 洛谷B3637<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*----------Code Area----------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line">ll a[N]=&#123;<span class="number">0</span>&#125;,dp[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; a[i];</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        ll mx=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,i<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[j]) mx=<span class="built_in">max</span>(mx,dp[j]);</span><br><span class="line">        dp[i]=mx+<span class="number">1</span>;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-2-贪心"><a href="#2-2-贪心" class="headerlink" title="2.2.贪心"></a>2.2.贪心</h3><p>$O(n\log n)$ 洛谷B3637<br>贪心：维护当前子序列d，替换序列中不小于a[i]的第一个元素<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line">ll a[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">vector&lt;ll&gt; d;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; a[i];</span><br><span class="line">    d.<span class="built_in">emplace_back</span>(a[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d.<span class="built_in">back</span>()&lt;a[i]) d.<span class="built_in">emplace_back</span>(a[i]);</span><br><span class="line">        <span class="keyword">else</span> *<span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(d),a[i])=a[i];</span><br><span class="line">    &#125;<span class="comment">//最长不降子序列改成upper_bound</span></span><br><span class="line">    cout &lt;&lt; d.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="二-区间DP"><a href="#二-区间DP" class="headerlink" title="二.区间DP"></a>二.区间DP</h1><p>$O(n^3)$ NOI1995/LOJ10147<br>分治：父问题的答案由子问题集中最优解转移<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 205</span></span><br><span class="line">ll v[N*<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;,S[N*<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dpmx[N*<span class="number">2</span>][N*<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;,dpmn[N*<span class="number">2</span>][N*<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; v[i];</span><br><span class="line">        v[i+n]=v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n*<span class="number">2</span>) <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n*<span class="number">2</span>) dpmn[i][j]=INF;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n*<span class="number">2</span>) dpmn[i][i]=<span class="number">0</span>;<span class="comment">//Init</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n*<span class="number">2</span>) S[i]=S[i<span class="number">-1</span>]+v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(len,<span class="number">1</span>,n)&#123;<span class="comment">//枚举区间长度</span></span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n*<span class="number">2</span>-len+<span class="number">1</span>)&#123;</span><br><span class="line">            ll j=i+len<span class="number">-1</span>;<span class="comment">//根据长度和i算出j</span></span><br><span class="line">            <span class="built_in">FORLL</span>(k,i,j<span class="number">-1</span>)&#123;<span class="comment">//枚举分界点</span></span><br><span class="line">                dpmx[i][j]=<span class="built_in">max</span>(dpmx[i][j],dpmx[i][k]+dpmx[k+<span class="number">1</span>][j]+S[j]-S[i<span class="number">-1</span>]);</span><br><span class="line">                dpmn[i][j]=<span class="built_in">min</span>(dpmn[i][j],dpmn[i][k]+dpmn[k+<span class="number">1</span>][j]+S[j]-S[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;<span class="comment">//转移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mx=<span class="number">0</span>,mn=INF;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n+<span class="number">1</span>) mx=<span class="built_in">max</span>(mx,dpmx[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n+<span class="number">1</span>) mn=<span class="built_in">min</span>(mn,dpmn[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    cout &lt;&lt; mn &lt;&lt; endl &lt;&lt; mx &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="三-期望DP"><a href="#三-期望DP" class="headerlink" title="三.期望DP"></a>三.期望DP</h1><p>ATC-abc323_e<br>某点的期望从此前的一段区间内转移<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 1003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X 10004</span></span><br><span class="line">ll dp[X]=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//歌曲在t时刻切换的概率</span></span><br><span class="line">ll t[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,x;cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; t[i];</span><br><span class="line">    ll invn=<span class="built_in">inv</span>(n);<span class="comment">//1/n</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,x)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n) <span class="keyword">if</span>(i&gt;=t[j])</span><br><span class="line">            <span class="built_in">addto</span>(dp[i],dp[i-t[j]]);</span><br><span class="line">        <span class="built_in">multo</span>(dp[i],invn);</span><br><span class="line">    &#125;</span><br><span class="line">    ll re=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="built_in">max</span>(<span class="number">0ll</span>,x-t[<span class="number">1</span>]+<span class="number">1</span>),x) <span class="built_in">addto</span>(re,dp[i]);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">multo</span>(re,invn) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="四-DP优化"><a href="#四-DP优化" class="headerlink" title="四.DP优化"></a>四.DP优化</h1><h2 id="1-单调队列优化DP"><a href="#1-单调队列优化DP" class="headerlink" title="1. 单调队列优化DP"></a>1. 单调队列优化DP</h2><p>O(mn) M(m) CF372C<br>利用单调队列将每次区间DP均摊复杂度降至O(1)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 305</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 150005</span></span><br><span class="line">ll a[N]=&#123;<span class="number">0</span>&#125;,b[N]=&#123;<span class="number">0</span>&#125;,t[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[<span class="number">2</span>][M]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n,m,d;<span class="type">int</span> fl=<span class="number">1</span>;</span><br><span class="line">ll que[M]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m) cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; t[i];</span><br><span class="line">    fl=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        ll l=<span class="number">1</span>,r=<span class="number">0</span>,k=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="keyword">for</span>(;k&lt;=<span class="built_in">min</span>(n,j+(t[i]-t[i<span class="number">-1</span>])*d);k++)&#123;</span><br><span class="line">                <span class="keyword">while</span>(r&gt;=l&amp;&amp;dp[fl^<span class="number">1</span>][que[r]]&lt;dp[fl^<span class="number">1</span>][k]) r--;</span><br><span class="line">                que[++r]=k;<span class="comment">//单调队列优化DP：维护上一状态的有效区间内的最大值的下标</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(r&gt;=l&amp;&amp;que[l]&lt;<span class="built_in">max</span>(<span class="number">1ll</span>,j-(t[i]-t[i<span class="number">-1</span>])*d)) l++;</span><br><span class="line">            dp[fl][j]=dp[fl^<span class="number">1</span>][que[l]]+b[i]-<span class="built_in">abs</span>(a[i]-j);</span><br><span class="line">        &#125;fl^=<span class="number">1</span>;<span class="comment">//状态转换</span></span><br><span class="line">    &#125;fl^=<span class="number">1</span>;<span class="comment">//回到最终状态</span></span><br><span class="line">    ll ans=-INF;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) ans=<span class="built_in">max</span>(ans,dp[fl][i]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Reference：<a href="https://oi-wiki.org/dp/">OI-Wiki</a></p>]]></content>
    
    
    <summary type="html">动态规划-其他//其他类型的题目篇幅较小，故整合到一起</summary>
    
    
    
    <category term="代码/模板" scheme="http://www.cclmsy.cc/categories/%E4%BB%A3%E7%A0%81-%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="动态规划" scheme="http://www.cclmsy.cc/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="笔记" scheme="http://www.cclmsy.cc/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>动态规划-背包DP</title>
    <link href="http://www.cclmsy.cc/posts/Infinity.html"/>
    <id>http://www.cclmsy.cc/posts/Infinity.html</id>
    <published>2023-09-22T12:00:00.000Z</published>
    <updated>2023-10-22T06:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-01背包"><a href="#1-01背包" class="headerlink" title="1.01背包"></a>1.01背包</h1><h2 id="1-1-DFS记忆化搜索"><a href="#1-1-DFS记忆化搜索" class="headerlink" title="1.1.DFS记忆化搜索"></a>1.1.DFS记忆化搜索</h2><p>$O(wn)$ <a href="https://www.luogu.com.cn/problem/P1048">洛谷P1048</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 1005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 105</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;z</span><br><span class="line">ll mem[W][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll maxw,n;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll i,ll curw)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mem[i][curw]) <span class="keyword">return</span> mem[i][curw];</span><br><span class="line">    <span class="keyword">if</span>(i&gt;n) <span class="keyword">return</span> mem[i][curw]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(curw&gt;=w[i])</span><br><span class="line">        <span class="keyword">return</span> mem[i][curw]=<span class="built_in">max</span>(<span class="built_in">dfs</span>(i+<span class="number">1</span>,curw-w[i])+v[i],<span class="built_in">dfs</span>(i+<span class="number">1</span>,curw));</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> mem[i][curw]=<span class="built_in">dfs</span>(i+<span class="number">1</span>,curw);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(<span class="number">1</span>,maxw) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="1-2-二维数组"><a href="#1-2-二维数组" class="headerlink" title="1.2.二维数组"></a>1.2.二维数组</h2><p>$O(wn) M(wn)$ <a href="https://www.luogu.com.cn/problem/P1048">洛谷P1048</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*----------Code Area----------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 105</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[N][W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n,maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,maxw)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=w[i]) dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j-w[i]]+v[i],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="1-3-一维滚动数组"><a href="#1-3-一维滚动数组" class="headerlink" title="1.3.一维滚动数组"></a>1.3.一维滚动数组</h2><p>$O(wn) M(w)$ <a href="https://www.luogu.com.cn/problem/P2871">洛谷P2871</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 20005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n,maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; maxw;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) </span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,w[i])&#123;<span class="comment">//01背包从大到小遍历，每个物品只能取一次</span></span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j-w[i]]+v[i],dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="2-完全背包"><a href="#2-完全背包" class="headerlink" title="2.完全背包"></a>2.完全背包</h1><h2 id="2-1-一维滚动数组"><a href="#2-1-一维滚动数组" class="headerlink" title="2.1.一维滚动数组"></a>2.1.一维滚动数组</h2><p>$O(wn) M(w)$ <a href="https://www.luogu.com.cn/problem/P1616">洛谷P1616</a><br>和01背包唯一区别在剩余容量从小到大遍历，每个物品能取多次<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 10000005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n,maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) </span><br><span class="line">        <span class="built_in">FORLL</span>(j,w[i],maxw)&#123;<span class="comment">//和01背包唯一区别在从小到大遍历，每个物品能取多次</span></span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j-w[i]]+v[i],dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-2-贪心优化"><a href="#2-2-贪心优化" class="headerlink" title="2.2.贪心优化"></a>2.2.贪心优化</h2><p>$O(wn) M(w)$ <a href="https://www.luogu.com.cn/problem/P1616">洛谷P1616</a><br>贪心思想：对于两件物品 $i,j$ ，如果 $w_i \le w_j \And v_i \ge v_j$ ，则只需保留 $i$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 10000005</span></span><br><span class="line">vector&lt;pll&gt; objs,tv;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n,maxw,w,v;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    tv.<span class="built_in">resize</span>(n);<span class="comment">//物品：&lt;weight,value&gt;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:tv) cin &gt;&gt; x.first &gt;&gt; x.second;</span><br><span class="line">    <span class="built_in">SORT</span>(tv);ll maxv=<span class="number">-1</span>;<span class="comment">//物品序列按主w次v排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:tv)</span><br><span class="line">        <span class="keyword">if</span>(x.second&gt;maxv)<span class="comment">//O(n)筛去多余物品</span></span><br><span class="line">            &#123;objs.<span class="built_in">emplace_back</span>(x);maxv=x.second;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:objs)&#123;</span><br><span class="line">        w=x.first;v=x.second;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,w,maxw)&#123;<span class="comment">//和01背包唯一区别在从小到大遍历，每个物品能取多次</span></span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j-w]+v,dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="3-多重背包"><a href="#3-多重背包" class="headerlink" title="3.多重背包"></a>3.多重背包</h1><h2 id="3-1-朴素方法"><a href="#3-1-朴素方法" class="headerlink" title="3.1.朴素方法"></a>3.1.朴素方法</h2><p>$O(w\sum cnt_i)$<br>朴素方法：按有 $cnt_i$ 个的物品 $i$ ，进行01背包<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 100005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n=<span class="number">0</span>,maxw,tn;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; tn &gt;&gt; maxw;</span><br><span class="line">    ll tv,tw,cnt,n=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,tn)&#123;</span><br><span class="line">        cin &gt;&gt; tv &gt;&gt; tw &gt;&gt; cnt;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,cnt)&#123;</span><br><span class="line">            v[++n]=tv;</span><br><span class="line">            w[n]=tw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,w[i])</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j-w[i]]+v[i],dp[j]);</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-2-二进制分组"><a href="#3-2-二进制分组" class="headerlink" title="3.2.二进制分组"></a>3.2.二进制分组</h2><p>$O(w\sum\lg{cnt_i})$<br>二进制分组优化：对于每个物品，将其按二进制分组，捆绑一个物品<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 100005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n=<span class="number">0</span>,maxw,tn;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; tn &gt;&gt; maxw;</span><br><span class="line">    ll tv,tw,cnt,n=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,tn)&#123;</span><br><span class="line">        cin &gt;&gt; tv &gt;&gt; tw &gt;&gt; cnt;</span><br><span class="line">        ll b=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cnt&gt;b)&#123;</span><br><span class="line">            v[++n]=tv*b;</span><br><span class="line">            w[n]=tw*b;</span><br><span class="line">            cnt-=b;b*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt) &#123;v[++n]=tv*cnt;w[n]=tw*cnt;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,w[i])</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j-w[i]]+v[i],dp[j]);</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="4-混合背包"><a href="#4-混合背包" class="headerlink" title="4.混合背包"></a>4.混合背包</h1><p>$O(wn)$ <a href="https://www.luogu.com.cn/problem/P1833">洛谷P1833</a><br>01背包、多重背包和完全背包的缝合怪//<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 100005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> cnt[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n=<span class="number">0</span>,maxw,tn;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll h1,m1,h2,m2;<span class="type">char</span> tc;</span><br><span class="line">    cin &gt;&gt; h1 &gt;&gt; tc &gt;&gt; m1 &gt;&gt; h2 &gt;&gt; tc &gt;&gt; m2 &gt;&gt; tn;</span><br><span class="line">    maxw=<span class="built_in">abs</span>((h2*<span class="number">60</span>+m2)-(h1*<span class="number">60</span>+m1));</span><br><span class="line">    ll tv,tw,tcnt,n=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,tn)&#123;</span><br><span class="line">        cin &gt;&gt; tw &gt;&gt; tv &gt;&gt; tcnt;</span><br><span class="line">        <span class="keyword">if</span>(tcnt)&#123;</span><br><span class="line">            ll b=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(tcnt&gt;b)&#123;</span><br><span class="line">                v[++n]=tv*b;</span><br><span class="line">                w[n]=tw*b;</span><br><span class="line">                cnt[n]=b;</span><br><span class="line">                tcnt-=b;b*=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="comment">//多重背包二进制分组</span></span><br><span class="line">            <span class="keyword">if</span>(tcnt) &#123;v[++n]=tv*tcnt;w[n]=tw*tcnt;cnt[n]=<span class="number">1</span>;&#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            v[++n]=tv;</span><br><span class="line">            w[n]=tw;</span><br><span class="line">            cnt[n]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="keyword">if</span>(cnt[i])&#123;<span class="comment">//01背包</span></span><br><span class="line">            <span class="built_in">FORLL_rev</span>(j,maxw,w[i])</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j-w[i]]+v[i],dp[j]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//完全背包</span></span><br><span class="line">            <span class="built_in">FORLL</span>(j,w[i],maxw)</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j-w[i]]+v[i],dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="5-二维费用背包"><a href="#5-二维费用背包" class="headerlink" title="5.二维费用背包"></a>5.二维费用背包</h1><p>$O(nw_1w_2)$ <a href="https://www.luogu.com.cn/problem/P1855">洛谷P1855</a><br>具有两种费用属性的背包问题，以01背包为例<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 205</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w1[N]=&#123;<span class="number">0</span>&#125;,w2[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W][W]=&#123;<span class="number">0</span>&#125;;<span class="comment">//二维滚动数组</span></span><br><span class="line">ll n,maxw1,maxw2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; maxw1 &gt;&gt; maxw2;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; w1[i] &gt;&gt; w2[i];</span><br><span class="line">        v[i]=<span class="number">1</span>;<span class="comment">//本题中价值均为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j1,maxw1,w1[i])</span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j2,maxw2,w2[i])</span><br><span class="line">            dp[j1][j2]=<span class="built_in">max</span>(dp[j1-w1[i]][j2-w2[i]]+v[i],dp[j1][j2]);</span><br><span class="line">    cout &lt;&lt; dp[maxw1][maxw2] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="6-分组背包"><a href="#6-分组背包" class="headerlink" title="6.分组背包"></a>6.分组背包</h1><p>$O(nw)$ <a href="https://www.luogu.com.cn/problem/P1757">洛谷P1757</a><br>01背包的进化体，每个组中最多能取1个物品<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 65536</span></span><br><span class="line">ll maxw,n;</span><br><span class="line">ll v[<span class="number">105</span>][N]=&#123;<span class="number">0</span>&#125;,w[<span class="number">105</span>][N]=&#123;<span class="number">0</span>&#125;,dp[<span class="number">1000</span>*N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll cnt[<span class="number">105</span>]=&#123;<span class="number">0</span>&#125;,mxid=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    ll tv,tw,id;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; tw &gt;&gt; tv &gt;&gt; id;</span><br><span class="line">        cnt[id]++;</span><br><span class="line">        v[id][cnt[id]]=tv;</span><br><span class="line">        w[id][cnt[id]]=tw;</span><br><span class="line">        mxid=<span class="built_in">max</span>(mxid,id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(k,<span class="number">1</span>,mxid)<span class="comment">//对于每一组物品</span></span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,<span class="number">0</span>)<span class="comment">//对于每一种容量（从后往前遍历，保证同组两种物品不同时取到）</span></span><br><span class="line">            <span class="built_in">FORLL</span>(i,<span class="number">1</span>,cnt[k]) <span class="keyword">if</span>(j&gt;=w[k][i])<span class="comment">//放入该组每种物品时可达到的最大值</span></span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j-w[k][i]]+v[k][i],dp[j]);</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="7-有依赖的背包"><a href="#7-有依赖的背包" class="headerlink" title="7.有依赖的背包"></a>7.有依赖的背包</h1><p>$O(nw)$ <a href="https://www.luogu.com.cn/problem/P1064">洛谷P1064</a><br>分组背包的进化体，将所有主副件组合方案作为一组进行分组背包<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> W 32005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 61</span></span><br><span class="line">ll maxw,n;</span><br><span class="line">ll w[N][<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;,v[N][<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;,dp[W]=&#123;<span class="number">0</span>&#125;,cnt[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">vector&lt;ll&gt; id_list;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    ll tw,tp,id;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; tw &gt;&gt; tp &gt;&gt; id;</span><br><span class="line">        <span class="keyword">if</span>(id==<span class="number">0</span>)&#123;<span class="comment">//0：纯主件</span></span><br><span class="line">            id=i;w[id][<span class="number">0</span>]=tw;v[id][<span class="number">0</span>]=tw*tp;</span><br><span class="line">            id_list.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cnt[id]==<span class="number">0</span>)&#123;<span class="comment">//1：主件+配件1</span></span><br><span class="line">            cnt[id]++;</span><br><span class="line">            w[id][<span class="number">1</span>]=tw+w[id][<span class="number">0</span>];</span><br><span class="line">            v[id][<span class="number">1</span>]=tw*tp+v[id][<span class="number">0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cnt[id]==<span class="number">1</span>)&#123;<span class="comment">//2：主件+配件2//3：主件+配件1+配件2</span></span><br><span class="line">            cnt[id]++;</span><br><span class="line">            w[id][<span class="number">2</span>]=tw+w[id][<span class="number">0</span>];</span><br><span class="line">            v[id][<span class="number">2</span>]=tw*tp+v[id][<span class="number">0</span>];</span><br><span class="line">            w[id][<span class="number">3</span>]=tw+w[id][<span class="number">1</span>];</span><br><span class="line">            v[id][<span class="number">3</span>]=tw*tp+v[id][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> k:id_list)&#123;<span class="comment">//对于每一组物品</span></span><br><span class="line">        ll t=<span class="number">0</span>; <span class="keyword">if</span>(cnt[k]==<span class="number">1</span>) t=<span class="number">1</span>; <span class="keyword">if</span>(cnt[k]==<span class="number">2</span>) t=<span class="number">3</span>; </span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,<span class="number">0</span>)<span class="comment">//对于每一种容量（从后往前遍历，保证同组两种方案不同时取到）</span></span><br><span class="line">            <span class="built_in">FORLL</span>(i,<span class="number">0</span>,t) <span class="keyword">if</span>(j&gt;=w[k][i])<span class="comment">//采取该组每种方案时可达到的最大值</span></span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j-w[k][i]]+v[k][i],dp[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="8-进阶问题"><a href="#8-进阶问题" class="headerlink" title="8.进阶问题"></a>8.进阶问题</h1><h2 id="1-求具体方案"><a href="#1-求具体方案" class="headerlink" title="1.求具体方案"></a>1.求具体方案</h2><p>$O(wn)$<br>以完全背包为例，在转移时记录容量j下选择的物品编号<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 10000005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;,cnt[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;,g[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n,maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) </span><br><span class="line">        <span class="built_in">FORLL</span>(j,w[i],maxw)&#123;<span class="comment">//和01背包唯一区别在从小到大遍历，每个物品能取多次</span></span><br><span class="line">            <span class="keyword">if</span>(dp[j-w[i]]+v[i]&gt;dp[j])&#123;</span><br><span class="line">                dp[j]=dp[j-w[i]]+v[i];</span><br><span class="line">                g[j]=i;<span class="comment">//记录在容量j下选择了物品i</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">    ll curw=maxw;</span><br><span class="line">    <span class="keyword">while</span>(g[curw])&#123;</span><br><span class="line">        cnt[g[curw]]++;</span><br><span class="line">        curw-=w[g[curw]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) ;<span class="comment">//输出方案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-装满方案计数"><a href="#2-装满方案计数" class="headerlink" title="2.装满方案计数"></a>2.装满方案计数</h2><p>对于给定的一个背包容量、物品费用、其他关系等的问题，求装到一定容量的方案总数。</p><h3 id="2-1-不考虑顺序"><a href="#2-1-不考虑顺序" class="headerlink" title="2.1.不考虑顺序"></a>2.1.不考虑顺序</h3><p>$O(wn)$<br>不同的选择顺序看作相同方案。以01背包为例<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 20005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//dp[0]即不选，方案数为1</span></span><br><span class="line">ll n,maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; maxw;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="comment">//先遍历物品</span></span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,w[i])&#123;<span class="comment">//01背包从大到小遍历，每个物品只能取一次</span></span><br><span class="line">            dp[j]=dp[j]+dp[j-w[i]];<span class="comment">//不选+选</span></span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-2-考虑顺序"><a href="#2-2-考虑顺序" class="headerlink" title="2.2.考虑顺序"></a>2.2.考虑顺序</h3><p>$O(wn)$ ZJNU C1299_B<br>不同的选择顺序看作不同方案。以完全背包为例</p><blockquote><p>从 $0$ 到 $n$ ，每次可以前进 {1,2,4} ，求方案数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> W 205</span></span><br><span class="line">ll w[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">ll maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw;</span><br><span class="line">    <span class="built_in">FORLL</span>(j,<span class="number">1</span>,maxw) <span class="comment">//先遍历容量</span></span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,<span class="number">3</span>) <span class="keyword">if</span>(j&gt;=w[i])</span><br><span class="line">            dp[j]=dp[j]+dp[j-w[i]];</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="3-最优方案计数"><a href="#3-最优方案计数" class="headerlink" title="3.最优方案计数"></a>3.最优方案计数</h2><p>$O(wn)$<br>求最优背包方案数，以01背包为例，g[j]代表容量j下最优方案数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 20005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;,g[W]=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//g[0]即不选，方案数为1</span></span><br><span class="line">ll n,maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; maxw;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) </span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,w[i])<span class="comment">//01背包从大到小遍历，每个物品只能取一次</span></span><br><span class="line">            <span class="keyword">if</span>(dp[j-w[i]]+v[i]&gt;dp[j])&#123;<span class="comment">//取 最优</span></span><br><span class="line">                dp[j]=dp[j-w[i]]+v[i];</span><br><span class="line">                g[j]=g[j-w[i]];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[j-w[i]]+v[i]==dp[j]) g[j]+=g[j-w[i]]; <span class="comment">//取或不取都最优</span></span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; g[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-求第k优解"><a href="#4-求第k优解" class="headerlink" title="4.求第k优解"></a>4.求第k优解</h2><p>$O(wnk)$ <a href="https://vjudge.net/problem/HDU-2639">HDU2639</a><br>求背包的第k优解，以01背包为例<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 1005</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ll dp[W][<span class="number">35</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//dp[j][k]表示容量j下第k优解</span></span><br><span class="line">    ll a[<span class="number">35</span>]=&#123;<span class="number">0</span>&#125;,b[<span class="number">35</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ll n,maxw,tark;</span><br><span class="line">    ll x,y,z;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; maxw &gt;&gt; tark;</span><br><span class="line">    a[tark+<span class="number">1</span>]=b[tark+<span class="number">1</span>]=<span class="number">-1</span>;<span class="comment">//哨兵</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="comment">//考虑前i个物品时</span></span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,w[i])&#123; <span class="comment">//容量为j下</span></span><br><span class="line">            <span class="built_in">FORLL</span>(k,<span class="number">1</span>,tark)&#123;</span><br><span class="line">                a[k]=dp[j-w[i]][k]+v[i];<span class="comment">//第k优解，选</span></span><br><span class="line">                b[k]=dp[j][k];<span class="comment">//第k优解，不选</span></span><br><span class="line">            &#125;<span class="comment">//dp数组不升保证a,b数组不升</span></span><br><span class="line">            x=y=z=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(z&lt;=tark&amp;&amp;!(a[x]==<span class="number">-1</span>&amp;&amp;b[y]==<span class="number">-1</span>))&#123;<span class="comment">//循环直到找到全部前k解，或两指针都到末尾</span></span><br><span class="line">                <span class="keyword">if</span>(a[x]&gt;b[y]) dp[j][z]=a[x++];</span><br><span class="line">                <span class="keyword">else</span> dp[j][z]=b[y++];</span><br><span class="line">                <span class="keyword">if</span>(dp[j][z]!=dp[j][z<span class="number">-1</span>]) z++;<span class="comment">//非严格比较则删去if条件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw][tark] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Reference：<a href="https://oi-wiki.org/dp/">OI-Wiki</a></p>]]></content>
    
    
    <summary type="html">动态规划-背包DP部分例题、板子代码</summary>
    
    
    
    <category term="代码/模板" scheme="http://www.cclmsy.cc/categories/%E4%BB%A3%E7%A0%81-%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="动态规划" scheme="http://www.cclmsy.cc/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="笔记" scheme="http://www.cclmsy.cc/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="背包DP" scheme="http://www.cclmsy.cc/tags/%E8%83%8C%E5%8C%85DP/"/>
    
  </entry>
  
  <entry>
    <title>题解|2023暑期牛客多校10</title>
    <link href="http://www.cclmsy.cc/posts/f6ff419e.html"/>
    <id>http://www.cclmsy.cc/posts/f6ff419e.html</id>
    <published>2023-08-17T16:00:00.000Z</published>
    <updated>2023-11-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="K-First-Last"><a href="#K-First-Last" class="headerlink" title="K.First Last"></a>K.First Last</h1><p><strong>签到题</strong></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>$n$ 个人参加 $m$ 场比赛，每场比赛中获得名次得概率均等<br>问针对某一人，他在所有场次比赛中都获得第一或倒数第一的概率</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>如果人数 $n&gt;1$ ，每场比赛的概率是 $p=\dfrac{2}{n}$ ；人数为 $1$ 时 $p=1$</p><p>输出 $p^m$ 即可</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">double</span> p=<span class="number">2.</span>/n,re=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) p=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m) re*=p;</span><br><span class="line">    <span class="built_in">print_float</span>(re,<span class="number">15</span>);cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="M-Fair-Equation"><a href="#M-Fair-Equation" class="headerlink" title="M.Fair Equation"></a>M.Fair Equation</h1><p><strong>模拟</strong></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个式子 $A+B=C$ ，其中正整数 $A,B,C\le 10^6$<br>问能否在 $A,B,C$ 其中一个数的某一位置（可以是开头和结尾）插入一个数字，使得等式成立；或原式自然成立。<br>若成立，输出成立的等式</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>如题如题目所述，取出等式中的数字，逐位模拟即可。具体实现可参考代码</p><h2 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_equal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; YES;</span><br><span class="line">    cout &lt;&lt; num[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; num[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; num[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;<span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="built_in">get_nums</span>(s);ll t;<span class="comment">//分离出数字</span></span><br><span class="line">    <span class="keyword">if</span>(num[<span class="number">0</span>]+num[<span class="number">1</span>]==num[<span class="number">2</span>]) &#123;<span class="built_in">print_equal</span>();<span class="keyword">return</span> ;&#125;<span class="comment">//原式成立</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,<span class="number">9</span>)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(k,<span class="number">0</span>,numlen[<span class="number">0</span>])&#123;</span><br><span class="line">            t=(num[<span class="number">0</span>]/pow_10[k])*pow_10[k]*<span class="number">10</span>+i*pow_10[k]+num[<span class="number">0</span>]%pow_10[k];</span><br><span class="line">            <span class="keyword">if</span>(t+num[<span class="number">1</span>]==num[<span class="number">2</span>]) &#123;num[<span class="number">0</span>]=t;<span class="built_in">print_equal</span>();<span class="keyword">return</span> ;&#125;</span><br><span class="line">        &#125;<span class="comment">//在A的第k位插入i，判断是否符合条件，下面同理</span></span><br><span class="line">        <span class="built_in">FORLL</span>(k,<span class="number">0</span>,numlen[<span class="number">1</span>])&#123;</span><br><span class="line">            t=(num[<span class="number">1</span>]/pow_10[k])*pow_10[k]*<span class="number">10</span>+i*pow_10[k]+num[<span class="number">1</span>]%pow_10[k];</span><br><span class="line">            <span class="keyword">if</span>(num[<span class="number">0</span>]+t==num[<span class="number">2</span>]) &#123;num[<span class="number">1</span>]=t;<span class="built_in">print_equal</span>();<span class="keyword">return</span> ;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">FORLL</span>(k,<span class="number">0</span>,numlen[<span class="number">0</span>])&#123;</span><br><span class="line">            t=(num[<span class="number">2</span>]/pow_10[k])*pow_10[k]*<span class="number">10</span>+i*pow_10[k]+num[<span class="number">2</span>]%pow_10[k];</span><br><span class="line">            <span class="keyword">if</span>(num[<span class="number">0</span>]+num[<span class="number">1</span>]==t) &#123;num[<span class="number">2</span>]=t;<span class="built_in">print_equal</span>();<span class="keyword">return</span> ;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2023暑期牛客多校10</summary>
    
    
    
    <category term="算法竞赛" scheme="http://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2023暑期牛客多校" scheme="http://www.cclmsy.cc/tags/2023%E6%9A%91%E6%9C%9F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2023暑期杭电多校10</title>
    <link href="http://www.cclmsy.cc/posts/8239c814.html"/>
    <id>http://www.cclmsy.cc/posts/8239c814.html</id>
    <published>2023-08-16T16:00:00.000Z</published>
    <updated>2023-11-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1004-Do-You-Like-Interactive-Problems"><a href="#1004-Do-You-Like-Interactive-Problems" class="headerlink" title="1004.Do You Like Interactive Problems?"></a>1004.Do You Like Interactive Problems?</h1><p><strong>概率论-数学期望</strong></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个正整数 $n$ ，在 $1$ ~ $n$ 范围内有一个正整数 $x$<br>进行若干轮猜测，每次猜测在 $1$ ~ $n$ 范围内等概率随机选择一个正整数 $y$ ，可以得到如下信息中的一个： $y&gt;x,y=x,y&lt;x$<br><strong>每次猜测后，下一次猜测仍在原范围内随机选择</strong>。当得到的信息能够唯一确定 $x$ 时，游戏结束<br>求猜测轮数的数学期望</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由题意可知，当且仅当出现以下情况时，可以唯一确定 $x$ ：</p><ol><li>选到 $x$ </li><li>$x$ 的相邻元素都被选到</li></ol><p>每次选择后，下一次选择的范围是不变的，因此其他元素的信息对唯一确定 $x$ 是没有作用的</p><p>对于给定 $n$ ，根据以下情况展开讨论：</p><ol><li>不论 $x$ 的位置，直接选到 $x$ ，轮数为 $1$ ，概率为 $\dfrac{1}{n}$ </li><li>已经选到一个相邻点（或 $x$ 在两端），轮数期望记为 $E_2$<ol><li>选另一相邻点（或唯一相邻点），轮数为 $1$ ，概率为 $\dfrac{1}{n}$ </li><li>选其他点没有贡献，概率为 $\dfrac{n-2}{n}$ </li></ol></li><li>$x$ 在中间，没有选到过相邻点，轮数期望记为 $E_3$<ol><li>选到两个相邻点之一，转移到情况 $2$ ，概率为 $\dfrac{2}{n}$ </li><li>选到其他点没有贡献，概率为 $\dfrac{n-3}{n}$</li></ol></li></ol><p>综上可得：</p><p>$E_2=\dfrac{1}{n}+\dfrac{1}{n}+\dfrac{n-2}{n}(1+E_2)$</p><p>$E_3=\dfrac{1}{n}+\dfrac{2}{n}(1+E_2)+\dfrac{n-3}{n}(1+E_3)$</p><p>解得 $E_2=\dfrac{n}{2},E_3=\dfrac{2n}{3}$<br>得到最终期望为：$E=\dfrac{2}{n}E_2+\dfrac{n-2}{n}E_3=\dfrac{2n-1}{3}$</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    ll t=<span class="built_in">mul</span>(<span class="built_in">Get_Mod</span>(<span class="number">2</span>*(n<span class="number">-2</span>)+<span class="number">3</span>),<span class="built_in">inv</span>(<span class="number">3</span>));</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="1012-Equalize-the-Array"><a href="#1012-Equalize-the-Array" class="headerlink" title="1012.Equalize the Array"></a>1012.Equalize the Array</h1><p><strong>签到</strong></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>定义一个数组的 $mode$ 是其中出现次数最多的数字（可不唯一）<br>给定一个数组 $a$ ，每次操作可以选定其一个 $mode$ 并使数组中所有与之相等的元素 $+1$<br>问任意次操作后能否使数组中全部元素相等</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>如果数组中最小的元素是 $mode$ ，连续操作最小元素即可实现//<br>元素计数，判断最小元素出现次数是否最多即可</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(n\log n)$</p><h2 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    map&lt;ll,ll&gt; mp;ll t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;mp[t]++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mxcnt=<span class="number">0</span>,mxi=<span class="number">0</span>,mn=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        t=mp[i];<span class="keyword">if</span>(!mn&amp;&amp;t) mn=i;</span><br><span class="line">        <span class="keyword">if</span>(t&gt;mxcnt) &#123;mxcnt=t;mxi=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mxi&lt;=mn) cout &lt;&lt; YES;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2023暑期杭电多校10</summary>
    
    
    
    <category term="算法竞赛" scheme="http://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2023暑期杭电多校" scheme="http://www.cclmsy.cc/tags/2023%E6%9A%91%E6%9C%9F%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2023暑期杭电多校09</title>
    <link href="http://www.cclmsy.cc/posts/e80ac002.html"/>
    <id>http://www.cclmsy.cc/posts/e80ac002.html</id>
    <published>2023-08-14T16:00:00.000Z</published>
    <updated>2023-11-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1002-Shortest-path"><a href="#1002-Shortest-path" class="headerlink" title="1002.Shortest path"></a>1002.Shortest path</h1><p><strong><del>签到题</del></strong> <strong>DFS记忆化搜索</strong></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个正整数 $n$ ，可以对其进行以下操作：</p><ol><li>如果 $n$ 能被 $3$ 整除，则可以使 $n=n/3$ ;</li><li>如果 $n$ 能被 $2$ 整除，则可以使 $n=n/2$ ;</li><li>使 $n=n-1$ </li></ol><p>求使得 $n$ 变成 $1$ 的最少操作次数</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><del>将样例Output输出即可</del></p><blockquote><p>这题不难，但确实精彩()//毕竟……<br>《钉耙编程”中国大学生算法设计超级联赛》是由hdu自主研发的一款全新开放世界冒险竞赛。竞赛发生在一个被称作“hdu”的幻想世界，在这里，被编译器选中的人将被授予“C++”，导引代码之力。你将扮演一位名为“acmer”的神秘角色，在自由的打题中邂逅性格各异能力独特的STL容器，和他们一起击败强题，找回AC的代码</p></blockquote><p>不闹了，解题吧</p><p>不难看出操作 $3$ 的收益最低，是不满足操作 $1,2$ 的时候凑条件用的。<br>而由于只允许整除，操作 $1,2$ 的优劣性不好评估（因为要夹杂操作 $3$ 而不单纯是减少的量的区别），因此每次对本次进行的两种操作方案进行比较。</p><p>按以下操作递归处理 $n$ ：</p><ol><li>如果 $n=1$ ，则返回 $0$ ；</li><li>进行若干次（可能0次）操作 $3$ 使得 $n$ 能被 $2$ 整除，执行操作 $2$</li><li>进行若干次（可能0次）操作 $3$ 使得 $n$ 能被 $3$ 整除，执行操作 $1$</li></ol><p>由于数据范围的关系，传统的DFS会超时，因此需要使用记忆化搜索<br>即每次计算完某个数（记为 $x$ ）的结果，将其保存下来，后续搜索 $x$ 时就无需继续搜索到底部，直接输出这个数的结果即可<br>记忆化搜索可以用 map 实现，频繁读取而不考虑元素顺序的可以使用 unordered_map ，有效降低时间空间复杂度</p><p><img src="/images/ACM/2023Summer_HDU09_1002.png" alt="Img"></p><p>第2、3行的提交使用了 map ，代码完全一致；第1行的提交仅仅将 map 改为了 unordered_map </p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(t\log^2n)$</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;ll,ll&gt; mp;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>-n;</span><br><span class="line">    <span class="keyword">if</span>(mp[n]) <span class="keyword">return</span> mp[n];</span><br><span class="line">    ll t1,t2;</span><br><span class="line">    t1=n%<span class="number">2</span>+<span class="number">1</span>+<span class="built_in">dfs</span>(n/<span class="number">2</span>);</span><br><span class="line">    t2=n%<span class="number">3</span>+<span class="number">1</span>+<span class="built_in">dfs</span>(n/<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> mp[n]=<span class="built_in">min</span>(t1,t2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(n) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="1005-List-Reshape"><a href="#1005-List-Reshape" class="headerlink" title="1005.List Reshape"></a>1005.List Reshape</h1><p><strong>签到题、模拟</strong></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>按一定格式给定一个纯数字一维数组，按给定格式输出成二维数组。</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>读入初始数组字符串，将每个数字分离，按要求输出即可</p><h2 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="type">char</span> s[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">vector&lt;string&gt; nums;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getnums</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string ts;ll len=<span class="built_in">strlen</span>(s);<span class="type">char</span> c;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,len)&#123;</span><br><span class="line">        c=s[i];</span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) ts.<span class="built_in">push_back</span>(c);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ts.<span class="built_in">size</span>())&#123;</span><br><span class="line">            nums.<span class="built_in">emplace_back</span>(ts);</span><br><span class="line">            ts.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">getchar</span>();<span class="built_in">gets</span>(s);</span><br><span class="line">    ll n,m;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    nums.<span class="built_in">clear</span>();<span class="built_in">getnums</span>();</span><br><span class="line">    <span class="comment">//print_vec(nums);</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">            cout &lt;&lt; nums[i*m+j];</span><br><span class="line">            <span class="keyword">if</span>(m<span class="number">-1</span>-j) cout &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        &#125;cout &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(n<span class="number">-1</span>-i) cout &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;cout &lt;&lt; <span class="string">&#x27;]&#x27;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="1008-Coins"><a href="#1008-Coins" class="headerlink" title="1008.Coins"></a>1008.Coins</h1><p><strong>概率论</strong></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>$n$ 个人进行游戏，每个人初始有 $a_i$ 个硬币，每次随机选择一个人给另一个人一枚硬币<br>若某人给出硬币后没有剩余，则退出游戏。直到有人拿到所有硬币游戏结束<br>求游戏轮数的数学期望</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>概率论还没学（）官方题解的鞅论看不懂（躺）//<br>等学完回来给严格推导（手搓大饼ing）<br>ACMer三大美德：暴力、打表、猜结论//下面给出道德解法（）</p><p>假设现在只有两个人，那么每个人给对方硬币的概率都为50%，直到其中一人没有硬币为止。<br>设这两个人的硬币数分别为 $m,n$ ，则游戏轮数期望为：<br>$f(m,n)=1+\dfrac{1}{2}f(m+1,n-1)+\dfrac{1}{2}f(m-1,n+1)$</p><p>可以发现越往后对期望的贡献越低，限制递归深度，利用如下程序暴力打表：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(ll m,ll n,ll rnd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rnd&gt;<span class="number">40</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//递归上限40层（已经要跑很久了）</span></span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>||n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+<span class="number">0.5</span>*<span class="built_in">f</span>(m+<span class="number">1</span>,n<span class="number">-1</span>,rnd+<span class="number">1</span>)+<span class="number">0.5</span>*<span class="built_in">f</span>(m<span class="number">-1</span>,n+<span class="number">1</span>,rnd+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(m,n,<span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>得到以下打表结果（不得不说跑的是真慢）：<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">in</span>:<span class="number">1</span> <span class="number">3</span> out:<span class="number">3</span></span><br><span class="line"><span class="attribute">in</span>:<span class="number">1</span> <span class="number">5</span> out:<span class="number">4</span>.<span class="number">98732</span></span><br><span class="line"><span class="attribute">in</span>:<span class="number">2</span> <span class="number">3</span> out:<span class="number">5</span>.<span class="number">99897</span></span><br><span class="line"><span class="attribute">in</span>:<span class="number">2</span> <span class="number">5</span> out:<span class="number">9</span>.<span class="number">8626</span></span><br><span class="line"><span class="attribute">in</span>:<span class="number">3</span> <span class="number">4</span> out:<span class="number">11</span>.<span class="number">8287</span></span><br></pre></td></tr></table></figure></p><p>暴力打完表可以猜结论了： $f(m,n)=mn$ ，即对于两个人，答案是他们硬币数的乘积；<br>那么对于三个人，利用样例<code>in:1 1 1 out:3</code>盲猜是 $a_1a_2+a_1a_3+a_2a_3$<br>推广到 $n$ 个人，两两相乘再相加即可</p><p>由于数据较大，答案需要开int128才能放得下<br>另外结合数据范围，利用前缀和算出结果即可</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>前缀和&amp;求和：$O(n)$</p><h2 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int128 res;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(n+<span class="number">1</span>)</span>,<span class="title">sum</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; v[i];</span><br><span class="line">        sum[i]=v[i]+sum[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,n,<span class="number">1</span>)&#123;</span><br><span class="line">        res=res+sum[i<span class="number">-1</span>]*v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="built_in">print</span>();<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2023暑期杭电多校09</summary>
    
    
    
    <category term="算法竞赛" scheme="http://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2023暑期杭电多校" scheme="http://www.cclmsy.cc/tags/2023%E6%9A%91%E6%9C%9F%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2023暑期牛客多校09</title>
    <link href="http://www.cclmsy.cc/posts/3f9284b7.html"/>
    <id>http://www.cclmsy.cc/posts/3f9284b7.html</id>
    <published>2023-08-13T16:00:00.000Z</published>
    <updated>2023-11-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="E-Puzzle-Square-Jam"><a href="#E-Puzzle-Square-Jam" class="headerlink" title="E.Puzzle: Square Jam"></a>E.Puzzle: Square Jam</h1><p><strong>几何</strong></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个 $n$ 行 $m$ 列的矩形，将其切割为若干个边长为正整数的正方形部分<br>要求矩形内每个整点都不能同时在四个正方形的边界上</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>每次在矩形中取最大的正方形，剩余部分递归处理即可。如此取，每个点最多在三个正方形的边界上</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;pll,ll&gt;&gt; ans;</span><br><span class="line">pair&lt;pll,ll&gt; tp;<span class="comment">//&lt;坐标,边长&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve_sqr</span><span class="params">(ll x,ll y,ll n,ll m)</span></span>&#123;</span><br><span class="line">    <span class="comment">//处理坐标在(x,y)，n行m列的矩形</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||m==<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;=m)&#123;</span><br><span class="line">        tp.first.first=x;tp.first.second=y;tp.second=m;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(tp);</span><br><span class="line">        <span class="built_in">solve_sqr</span>(x+m,y,n-m,m);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        tp.first.first=x;tp.first.second=y;tp.second=n;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(tp);</span><br><span class="line">        <span class="built_in">solve_sqr</span>(x,y+n,n,m-n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ans.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">solve_sqr</span>(<span class="number">0</span>,<span class="number">0</span>,n,m);</span><br><span class="line">    cout &lt;&lt; YES ;</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:ans)&#123;</span><br><span class="line">        cout &lt;&lt; x.first.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x.first.second &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2023暑期牛客多校09</summary>
    
    
    
    <category term="算法竞赛" scheme="http://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2023暑期牛客多校" scheme="http://www.cclmsy.cc/tags/2023%E6%9A%91%E6%9C%9F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2023暑期牛客多校08</title>
    <link href="http://www.cclmsy.cc/posts/b57662bf.html"/>
    <id>http://www.cclmsy.cc/posts/b57662bf.html</id>
    <published>2023-08-10T16:00:00.000Z</published>
    <updated>2023-11-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-Alive-Fossils"><a href="#A-Alive-Fossils" class="headerlink" title="A.Alive Fossils"></a>A.Alive Fossils</h1><p><strong>签到</strong></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定 $n$ 个字符串集，求它们的交集，按字典序输出</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>逐一处理字符串集，开个 map 记录此前的交集，从当前集合中选走元素即可</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(n)$</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;ll tn;cin &gt;&gt; tn;</span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt; mp;string ts;</span><br><span class="line">    vector&lt;string&gt; v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,tn)&#123;</span><br><span class="line">        cin &gt;&gt; ts;</span><br><span class="line">        mp[ts]++;</span><br><span class="line">        v.<span class="built_in">emplace_back</span>(ts);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        v.<span class="built_in">clear</span>();</span><br><span class="line">        cin &gt;&gt; tn;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,tn)&#123;</span><br><span class="line">            cin &gt;&gt; ts;</span><br><span class="line">            <span class="keyword">if</span>(mp[ts]) v.<span class="built_in">emplace_back</span>(ts);</span><br><span class="line">        &#125;</span><br><span class="line">        mp.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s:v) mp[s]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> s:v) cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="J-Permutation-and-Primes"><a href="#J-Permutation-and-Primes" class="headerlink" title="J.Permutation and Primes"></a>J.Permutation and Primes</h1><p><strong>构造</strong></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个正整数 $n$ ，构造一个 $n$ 的排列，使得每对相邻元素的和或差的绝对值为一奇素数</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>两个数的和或差是奇数，那么它们的奇偶性一定是不同的，因此所求排列中，奇数和偶数是交错分布的</p><p>对于排列的构造，首先考虑能不能通过自然排列转化而成//</p><p>赛时首先想到奇偶分开后，将全体偶数向左或向右循环移动 $2$ ~ $3$ 位，这样可以保证绝大部分位置和左右两边之差为 $3$ 或 $5$ //当时以为要切了，结果剩余的数字考虑了两年半还是没有找到符合题意而不失一般性的构造方法</p><p>然后考虑分段调整。在上面思想的基础上，发现如果元素个数为 $8$ 个，那么全体偶数左移 $2$ 位和右移 $2$ 位的结果都为： $1,6,3,8,5,2,7,4$ 。并且如果下一段长度为 $8$ 的序列也按照这种规则变换顺序，那么 $4$ 和下一段长度为 $8$ 的序列的开头 $9$ 之差为 $5$ ，符合题意，从而解决了边界问题</p><p>将 $n$ 模 $8$ 取余，记 $n=8k+r$ 。解决前 $r$ 个数的排列后，之后每 $8$ 个数按 $1,6,3,8,5,2,7,4$ 的顺序变换即可</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(n)$</p><h2 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ll rem[<span class="number">8</span>][<span class="number">8</span>]=&#123;&#123;&#125;,&#123;<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>&#125;,&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>&#125;,&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">ll pl[<span class="number">9</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    ll r=n%<span class="number">8</span>,d=n/<span class="number">8</span>;</span><br><span class="line">    vector&lt;ll&gt; v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,r<span class="number">-1</span>) v.<span class="built_in">emplace_back</span>(rem[r][i]);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,d<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,<span class="number">8</span>)&#123;</span><br><span class="line">            v.<span class="built_in">emplace_back</span>(<span class="number">8</span>*i+pl[j]+r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cout &lt;&lt; v[i] &lt;&lt; <span class="built_in">Presentation</span>(i,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2023暑期牛客多校08</summary>
    
    
    
    <category term="算法竞赛" scheme="http://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2023暑期牛客多校" scheme="http://www.cclmsy.cc/tags/2023%E6%9A%91%E6%9C%9F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2023暑期杭电多校08</title>
    <link href="http://www.cclmsy.cc/posts/a4f57cd6.html"/>
    <id>http://www.cclmsy.cc/posts/a4f57cd6.html</id>
    <published>2023-08-09T16:00:00.000Z</published>
    <updated>2023-11-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1005-0-vs-1"><a href="#1005-0-vs-1" class="headerlink" title="1005.0 vs 1"></a>1005.0 vs 1</h1><p><strong>博弈，模拟</strong></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>两人名为零和壹，在给定的 $01$ 串上进行博弈<br>零只能取走两端的某一个 $0$ ，壹只能取走两端的某一个 $1$ ，零执先<br>先不能取的人判负，若取完则判平局</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>模拟博弈过程，当前操作者 $x$ 可以可以遵循以下策略：</p><ol><li>两端不同，只能取 $x$ 的一端，交替操作权</li><li>两端相同<ol><li>两端都不是 $x$ ，无法操作，失败</li><li>两端都是 $x$ ，假设取了某端<ol><li>这端的下一个数字是 $x$ ，则两端都是 $x$ ，对方无法操作，获胜</li><li>这端的下一个数字是 $!x$ ，则对方只能取这一端</li></ol></li><li>如果离任一端最近的连续两个相同的数都为 $x$ ，则根据上 $2$ 一直取到 $x$ 获胜</li><li>如果离两端最近的连续两个相同的数都为 $!x$ ，则不论选哪端，最终都会到达两端都为 $!x$ 的情况，失败<ol><li>特判：如果整个串有且仅有 $1$ 段连续两个相同的 $!x$ ，则从两端向中间将各会取掉一个，达成平局 </li></ol></li></ol></li></ol><p>可以结合代码注释理解这一过程</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(n)$</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve_s</span><span class="params">(deque&lt;<span class="type">int</span>&gt; s,<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">    ll n=s.<span class="built_in">size</span>(),i,j;;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">empty</span>()) &#123;cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//取完平局</span></span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">front</span>()!=s.<span class="built_in">back</span>())&#123;<span class="comment">//前后不同，无法自由选择，交替操作权</span></span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">front</span>()==now)&#123;<span class="comment">//取前</span></span><br><span class="line">            s.<span class="built_in">pop_front</span>();<span class="built_in">solve_s</span>(s,(now?<span class="number">0</span>:<span class="number">1</span>));<span class="keyword">return</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//取后</span></span><br><span class="line">            s.<span class="built_in">pop_back</span>(); <span class="built_in">solve_s</span>(s,(now?<span class="number">0</span>:<span class="number">1</span>));<span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//前后相同</span></span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">front</span>()!=now) &#123;cout &lt;&lt; (now?<span class="string">&quot;0&quot;</span>:<span class="string">&quot;1&quot;</span>) &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//两端不可取，失败</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++) <span class="keyword">if</span>(s[i]==s[i+<span class="number">1</span>]) <span class="keyword">break</span>;<span class="comment">//从前往后找第一个连续</span></span><br><span class="line">        <span class="keyword">if</span>(i==n<span class="number">-1</span>) &#123;cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//无连续，取完平局</span></span><br><span class="line">        <span class="keyword">if</span>(s[i]==now) &#123;cout &lt;&lt; (now?<span class="string">&quot;1&quot;</span>:<span class="string">&quot;0&quot;</span>) &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//有己方连续，胜利</span></span><br><span class="line">        <span class="keyword">for</span>(j=n<span class="number">-1</span>;j&gt;i;j--) <span class="keyword">if</span>(s[j]==s[j<span class="number">-1</span>]) <span class="keyword">break</span>;<span class="comment">//从后往前找最后一个连续</span></span><br><span class="line">        <span class="keyword">if</span>(s[j]==now) &#123;cout &lt;&lt; (now?<span class="string">&quot;1&quot;</span>:<span class="string">&quot;0&quot;</span>) &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//有己方连续，胜利</span></span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>==j) &#123;cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//有且仅有一对对方连续，取完平局</span></span><br><span class="line">        &#123;cout &lt;&lt; (now?<span class="string">&quot;0&quot;</span>:<span class="string">&quot;1&quot;</span>) &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//两对以上对方连续，失去主动权，判负</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    string ts;cin &gt;&gt; ts;</span><br><span class="line">    <span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n)</span></span>;<span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) s[i]=ts[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="built_in">solve_s</span>(s,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="1007-Solubility"><a href="#1007-Solubility" class="headerlink" title="1007.Solubility"></a>1007.Solubility</h1><p><strong>并查集/DFS</strong></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定 $n$ 个元素之间的 $m$ 对等价关系，问指定 $k$ 个元素是否属于同一等价类</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>这里给出两种解题思路：</p><ol><li>DFS：建无向图，DFS判断指定元素是否在同一个连通分量里</li><li>并查集：标准并查集板子题，裸套即可</li></ol><h2 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><ol><li><p>DFS</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="type">int</span> visited[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">vector&lt;vector&lt;ll&gt;&gt; G;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    visited[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:G[x])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[v]) <span class="built_in">DFS</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    G.<span class="built_in">clear</span>();G.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) visited[i]=<span class="number">0</span>;</span><br><span class="line">    ll u,v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">        G[v].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    ll k;cin &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">s</span><span class="params">(k)</span></span>;<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:s) cin &gt;&gt; x;</span><br><span class="line">    <span class="built_in">DFS</span>(s[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:s) <span class="keyword">if</span>(!visited[x]) &#123;cout &lt;&lt; NO;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    cout &lt;&lt; YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>并查集</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">DSU <span class="title">dsu</span><span class="params">(n)</span></span>;</span><br><span class="line">    ll a,b;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        dsu.<span class="built_in">merge</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    ll k;cin &gt;&gt; k &gt;&gt; a;a=dsu.<span class="built_in">find</span>(a);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,k)&#123;</span><br><span class="line">        cin &gt;&gt; b;b=dsu.<span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(b!=a) &#123;cout &lt;&lt; NO;<span class="built_in">FORLL</span>(j,i+<span class="number">1</span>,k) cin &gt;&gt; n;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    &#125;cout &lt;&lt; YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="1008-Expectation-of-Rank"><a href="#1008-Expectation-of-Rank" class="headerlink" title="1008.Expectation of Rank"></a>1008.Expectation of Rank</h1><p><strong>线性代数-矩阵与向量空间、期望、动态规划</strong></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定两个正整数 $n,p$ ，其中 $p$ 是质数<br> $n$ 阶矩阵 $\bf A$ 中的所有元素随机在 $p$ 的有限域 $\mathbb{F}_p$ 中产生，求矩阵 $\bf A$ 的秩的期望 $\mathbb{E}(rank(\bf A))$ ，答案取模</p><h3 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h3><ol><li><a href="https://baike.baidu.com/item/%E6%9C%89%E9%99%90%E5%9F%9F/4273049">有限域</a> $\mathbb{F}_p$ ：在本题中可以粗略的理解为 $[0,p-1]$ 的整数集</li><li>线性代数-矩阵与向量空间基础知识：多维向量与向量组、线性相关、矩阵的秩与向量之间的关系、向量组张成向量空间的概念等</li></ol><p>建议在学习过《线性代数》课程后再解决本题。</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>一个含 $k$ 个向量的极大无关组可以张成一个 $k$ 维向量空间</p><p>在 $p$ 的有限域 $\mathbb{F}_p$ 下，每一维度上的坐标有 $p$ 种选择，故以该极大无关组为基，通过线性组合可以产生 $p^k$ 种不同的 $k$ 维向量（高维包含低维）<br>顺带一提，这并不意味着这 $p^k$ 种向量仅有 $k$ 位坐标非 $0$ </p><p>矩阵 $\bf A$ 的每一行可以视为一个 $n$ 维向量，前 $i$ 行的秩表示了前 $i$ 个向量组成的向量组，其极大无关组中有多少个向量。这也意味着前 $i$ 行已经张成了一个多少维度的向量空间</p><p>构造DP数组， $dp_{i,k}$ 用以表示矩阵 $\bf A$ 前 $i$ 行的秩为 $k$ 的方案数</p><p>假设前 $i-1$ 行的秩为 $k$ ，那么其张成的向量空间为 $k$ 维，考虑状态转移：</p><ol><li>第 $i$ 行中可以构造出 $p^k$ 个向量落在这个向量空间中，并不改变秩（或者说维数）</li><li>余下 $p^n-p^k$ 个向量将与前 $i-1$ 个向量线性无关，并使张成的空间增大一维，秩 $+1$</li></ol><p>综上所述，构造出以下状态转移方程：</p><script type="math/tex; mode=display">dp_{i,k}=\begin{cases}    0 \qquad,k>i\quad(rank_i\le i恒成立) \newline    1 \qquad,k=0\quad(当且仅当全为 \bf{0} \text{向量}) \newline    \sum\limits_{j=1}^{i-1} dp_{i-1,j}\times p^j + dp_{i-1,j-1}\times (p^n-p^j) &,Otherwise\end{cases}</script><p>总方案数为 $(p^n)^n=p^{n^2}$ ，最终期望为 $\dfrac{1}{p^{n^2}}\sum\limits<em>{j=1}^{n} j\times dp</em>{n,j}$</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>DP：$O(n^2)$</p><h2 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5005</span></span><br><span class="line">ll n,p;</span><br><span class="line">ll dp[N][N],powp[N];<span class="comment">//dp_i,k表示矩阵前i行秩为k的方案数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n)</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,n)</span><br><span class="line">            dp[i][j]=<span class="number">0</span>;</span><br><span class="line">    powp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) powp[i]=<span class="built_in">mul</span>(powp[i<span class="number">-1</span>],p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">    <span class="built_in">Init</span>(n);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(k,<span class="number">1</span>,i)&#123;<span class="comment">//每行看作一个向量，有p^n种构造法。确定前i行的秩为k的总向量方案数</span></span><br><span class="line">            <span class="built_in">addto</span>(dp[i][k],<span class="built_in">mul</span>(dp[i<span class="number">-1</span>][k],powp[k]));</span><br><span class="line">            <span class="comment">//对于前i-1行秩为k的某方案，其向量空间为k维，故在p的有限集下有且仅有p^k个向量落在该向量空间</span></span><br><span class="line">            <span class="built_in">addto</span>(dp[i][k],<span class="built_in">mul</span>(dp[i<span class="number">-1</span>][k<span class="number">-1</span>],<span class="built_in">sub</span>(powp[n],powp[k<span class="number">-1</span>])));</span><br><span class="line">            <span class="comment">//对于前i-1行秩为k-1的某方案，有p^(k-1)个向量落在其张成的向量空间，剩余向量与前i-1行线性无关</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll re=<span class="number">0</span>,ninv=<span class="built_in">inv</span>(<span class="built_in">qcpow</span>(powp[n],n));<span class="comment">//ninv:总方案数(p^n)^n的倒数</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="built_in">addto</span>(re,<span class="built_in">mul</span>(<span class="built_in">mul</span>(i,dp[n][i]),ninv));</span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="1010-Rikka-with-Square-Numbers"><a href="#1010-Rikka-with-Square-Numbers" class="headerlink" title="1010.Rikka with Square Numbers"></a>1010.Rikka with Square Numbers</h1><p><strong>数学、贪心</strong></p><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定两个正整数 $a,b$ ，每次操作可以使 $a$ 增大或减小一个平方数 $x$ ，求把 $a$ 变成 $b$ 的最小操作次数 </p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>即求 $a,b$ 之差最少可以用多少个平方数的和差表示。以下是一些思路：</p><ol><li>$a=b$ ， $0$</li><li>$n^2$ ，平方数本身， $1$</li><li>$n^2-(n-1)^2=2n-1$ ，用两个相邻平方数之差即可表示任意奇数</li><li>$n^2-(n-2)^2=4(n-1)$ ，用两个距离为 $2$ 的平方数之差可以表示任意 $4$ 的倍数</li><li>结合以上两条可以归纳证明两个平方数之差一定为奇数或 $4$ 的倍数，$2$</li><li>模 $4$ 余 $2$ 的情况可能为两平方数加和，可以枚举判断， $2$</li><li>其余的数可以用第 $3$ 点得到任意奇数后加减 $1$ ， $3$ </li></ol><p>综上判定即可</p><h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p> $O(\sqrt n)$</p><h2 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Is_Sqr</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    ll t=<span class="built_in">sqrt</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(t*t==x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a,b;cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b) <span class="built_in">swap</span>(a,b); ll dif=a-b;</span><br><span class="line">    <span class="keyword">if</span>(a==b) &#123;cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Is_Sqr</span>(dif)) &#123;cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">if</span>(dif%<span class="number">2</span>||(dif%<span class="number">4</span>==<span class="number">0</span>)) &#123;cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i*i&lt;=dif;i++) <span class="keyword">if</span>(<span class="built_in">Is_Sqr</span>(dif-i*i)) &#123;cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    cout &lt;&lt; <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2023暑期杭电多校08</summary>
    
    
    
    <category term="算法竞赛" scheme="http://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2023暑期杭电多校" scheme="http://www.cclmsy.cc/tags/2023%E6%9A%91%E6%9C%9F%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2023暑期杭电多校07</title>
    <link href="http://www.cclmsy.cc/posts/adbd05a4.html"/>
    <id>http://www.cclmsy.cc/posts/adbd05a4.html</id>
    <published>2023-08-07T16:00:00.000Z</published>
    <updated>2023-11-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1002-Random-Nim-Game"><a href="#1002-Random-Nim-Game" class="headerlink" title="1002.Random Nim Game"></a>1002.Random Nim Game</h1><p><strong>诈骗博弈题</strong></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>Nim是一种双人数学策略游戏，玩家轮流从不同的堆中移除棋子。在每一轮游戏中，玩家必须至少取出一个棋子，并且可以取出任意数量的棋子，条件是这些棋子都来自同一个棋子堆。走最后一步棋（即取出最后一块棋子）的人获胜。</p><p>现在更改游戏规则，在每个回合中，棋手必须选择一个棋子堆。假设他选择的堆包含 $x$ 个棋子，将从 $[1,x]$ 中随机一个整数 $y$ ，并从堆中移除 $y$ 个棋子</p><p>求先手获胜的概率，答案取模</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>看起来很吓人的一道题（谁被吓退了我不说）//</p><p>考虑只有一个堆的情况<br>若只有 $1$ 个棋子，先手必胜<br>如果有 $2$ 个棋子，有 $\dfrac{1}{2}$ 的概率拿完获胜，有 $\dfrac{1}{2}$ 的概率余 $1$ 失败，综合胜率 $\dfrac{1}{2}$<br> $\vdots$<br>如果有 $x\ (x&gt;1)$ 个棋子，有 $\dfrac{n-2}{n}$ 的概率转移到 剩余个数 $&gt;1$ 的状态，有 $\dfrac{1}{n}$ 的概率拿完获胜，有 $\dfrac{1}{n}$ 的概率余 $1$ 失败。递归得到 $x&gt;1$ 的状态下的综合胜率为 $\dfrac{1}{2}$ </p><p>再考虑多堆的情况<br>如果所有堆的棋子数量均为 $1$ ，则当堆数 $n$ 为奇数时先手必胜<br>如果有某堆的数量多于 $1$ 个，那么必胜态将以 $\dfrac{1}{2}$ 的概率流转</p><p>综上所述，如果所有堆的棋子数量均为 $1$ ，则当堆数 $n$ 为奇数时先手必胜， $n$ 为偶数时先手必败，其余情况综合胜率 $\dfrac{1}{2}$ </p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;ll mx=<span class="number">0</span>,t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        mx=<span class="built_in">max</span>(mx,t);</span><br><span class="line">    &#125;<span class="keyword">if</span>(mx&gt;<span class="number">1</span>) cout &lt;&lt; <span class="built_in">inv</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n%<span class="number">2</span>) cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="1004-Medians-Strike-Back"><a href="#1004-Medians-Strike-Back" class="headerlink" title="1004.Medians Strike Back"></a>1004.Medians Strike Back</h1><p><strong>构造</strong></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>定义长度为 $n$ 的整数序列的中位数：</p><ol><li>如果 $n$ 为奇数，则中位数是将序列排序后正中间的数</li><li>如果 $n$ 为偶数，则中位数是将序列排序后中间两个数中，出现次数较多的那个数，如果出现次数相同则取较小的那个数</li></ol><p>定义序列的 $shikness$ ：该序列中位数出现的次数<br>定义序列的 $nitness$ ：该序列的所有连续子串的 $shikness$ 的最大值</p><p>给定一个正整数 $n$ ，构造长度为 $n$ 且仅含元素 $1,2,3$ 的序列，并使 $nitness$ 最小化，求出最小值</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>构造找规律<br>$nitness<em>{min}=1$ 时，构造出最长序列为： $123$<br>$nitness</em>{min}=2$ 时，构造出最长序列为： $1313221313$<br>$nitness<em>{min}=3$ 时，构造出最长序列为： $131313222131313$<br>$nitness</em>{min}=4$ 时，构造出最长序列为： $1313131322131313132213131313$</p><p>如果序列中存在两个及以上的 $2$ ，那么 $2$ 是稳定作为中位数的，因此可以考虑以下构造方法：<br>连续 $n$ 对 $13$ 为一个单位子串//每个单位子串利用两个或三个连续的 $2$ 隔开，将得到以下格式的序列：$1313(n对)\cdots22\ 1313(n对)\cdots22\ 1313(n对)$</p><p>下面阐释这种构造方法的合法性</p><ol><li>对于整个序列， $nitness=cnt_2=n$ </li><li>对于含多个 $2$ 的子串， $2$ 稳定做中位数， $nitness&lt;cnt_2=n$</li><li>对于仅含一个 $2$ 的子串，这个 $2$ 一定在单位子串的左边或右边，而单位子串的长度为 $2n$ ，因此加上 $2$ 后的长度为奇数，$2$ 稳定做中位数，$nitness=1$</li><li>对于不含 $2$ 的子串，其一定也是单位子串的子串，而单位子串中 $cnt_1=cnt3=n$ ，因此 $nitness\le n$</li></ol><p>计数得到最长长度的通项公式： $len_i=2i(\lfloor \dfrac{i}{2} \rfloor+1)+i$</p><p>初始化长度数组，二分查找即可</p><h2 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 500000</span></span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(N)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(v),n)-v.<span class="built_in">begin</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*----------Initialize----------*/</span></span><br><span class="line">    v[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,N)&#123;</span><br><span class="line">        v[i]=(i/<span class="number">2</span>+<span class="number">1</span>)*<span class="number">2</span>*i+i;</span><br><span class="line">        <span class="keyword">if</span>(v[i]&gt;<span class="number">1e11</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;v.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line"><span class="comment">/*----------Initialize----------*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="1011-Three-Operations"><a href="#1011-Three-Operations" class="headerlink" title="1011.Three Operations"></a>1011.Three Operations</h1><p><strong>签到题</strong></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定正整数 $x,a,b$ 可以进行以下操作：</p><ol><li>$x\leftarrow x-1$</li><li>$x\leftarrow \lfloor \dfrac{x+a}{2} \rfloor$</li><li>$x\leftarrow \lfloor \sqrt{x+b} \rfloor$</li></ol><p>求使得 $x$ 变为 $0$ 的最少操作次数</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>每次比较三种操作后的 $x$ 最小即可</p><h2 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,a,b,t,re=<span class="number">0</span>;cin &gt;&gt; x &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        t=<span class="built_in">min</span>((x+a)/<span class="number">2</span>,(ll)<span class="built_in">sqrt</span>(x+b));</span><br><span class="line">        <span class="keyword">if</span>(t&lt;x<span class="number">-1</span>) &#123;re++;x=t;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;re+=x;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="1013-Minimal-and-Maximal-XOR-Sum"><a href="#1013-Minimal-and-Maximal-XOR-Sum" class="headerlink" title="1013.Minimal and Maximal XOR Sum"></a>1013.Minimal and Maximal XOR Sum</h1><p><strong>归并排序、贪心</strong></p><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个长度为 $n$ 的排列 $p$ ，每次操作可以选定一段连续子序列 $p_{i,j}$ ，花费等同于元素个数的代价 $c=j-i+1$ ，使得这一段顺序反转<br>记使得排序变成自然排序（ $p_i=i$ ）所经过的一系列操作中，每一次的代价的异或和为 $x=c_1 \oplus c_2 \oplus \cdots \oplus c_i$<br>求 $x$ 的最大值和最小值</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>排列的奇偶性定义为其所具有的逆序对数的奇偶性。任意一个n阶排列，可经过一系列对换转变为标准排列，且所做对换的次数与排列具有相同的奇偶性。</p><p>观察操作的特点可以得出，选定单一元素操作时，排列本身不发生改变，但产生 $1$ 点代价//这意味着所得结果 $x$ 的最后一个二进制位可以任意调整（和 $1$ 做异或）</p><p>考虑使得 $x$ 最小的操作方法<br>每次花费 $2$ 代价做对换，最小值 $x_{min}$ 一定会落在 $0$ 或 $2$ 上。根据对换次数与排列奇偶性的关系，判断排列逆序对数的奇偶性即可，可以使用归并排序进行逆序对计数</p><p>接下来考虑使得 $x$ 最大的操作方法<br>在排列 $p$ 已经有序的情况下，考虑如何操作花费代价可以使得异或和 $x$ 产生高位 $1$ ：先花费高代价 $c$ 反转某个长子序列，再连续花费 $2$ 代价做对换将序列恢复为有序</p><p>可以发现 $x$ 的最大可能二进制位数与 $n$ 相同，逐位考虑转 $1$ 记某位上的权重为 $2^m &lt;n$ ，则反转 $2^m$ 个数后，恢复有序需要连续做对换的次数为 $2^m(2^m-1)/2$ ， $m\ge 2$ 时对换次数为偶数，即对最终的异或和 $x$ 无影响，这意味着按照上述策略可以将 $x$ 倒数第3位（权重为4）及以前的数位全部置1//</p><p>$m=1$ 时对换次数为 $1$ ，和反转 $2^1$ 个数的代价 $2$ 抵消，因此无法变更倒数第二位的值</p><p>综上所述，只需将 $x$ 调整为与 $n$ 具有相同二进制数的最大值，再判断倒数第二位即可//</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>归并排序： $O(n\log n)$</p><h2 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;ll mn,mx;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:v) cin &gt;&gt; x;</span><br><span class="line">    ll cntinv=<span class="built_in">mergeSortAndCount</span>(v,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(cntinv%<span class="number">2</span>) mn=<span class="number">2</span>;<span class="keyword">else</span> mn=<span class="number">0</span>;</span><br><span class="line">    ll t=n,dig=<span class="number">0</span>;<span class="keyword">while</span>(t) &#123;dig++;t/=<span class="number">2</span>;&#125;</span><br><span class="line">    mx=(<span class="number">1</span>&lt;&lt;dig)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mn==<span class="number">0</span>) mx-=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;0 1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; mn &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; mx &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2023暑期杭电多校07</summary>
    
    
    
    <category term="算法竞赛" scheme="http://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2023暑期杭电多校" scheme="http://www.cclmsy.cc/tags/2023%E6%9A%91%E6%9C%9F%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2023暑期牛客多校07</title>
    <link href="http://www.cclmsy.cc/posts/179d3b5a.html"/>
    <id>http://www.cclmsy.cc/posts/179d3b5a.html</id>
    <published>2023-08-06T16:00:00.000Z</published>
    <updated>2023-11-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="M-Writing-Books"><a href="#M-Writing-Books" class="headerlink" title="M.Writing Books"></a>M.Writing Books</h1><p><strong>签到</strong></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个正整数 $n$ ，求 $1$ ~ $n$ 共有多少位数字</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>$1$ ~ $9$ 共 $9\times 10^0 \times 1$ 位；<br>$10$ ~ $99$ 共 $9\times 10^1 \times 2$ 位；<br>以此类推，求和即可</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ll a=<span class="number">1</span>,x=<span class="number">9</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;=x) &#123;n-=x;cnt+=a*x;x*=<span class="number">10</span>;a++;&#125;</span><br><span class="line">    cnt+=a*n;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2023暑期牛客多校07</summary>
    
    
    
    <category term="算法竞赛" scheme="http://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2023暑期牛客多校" scheme="http://www.cclmsy.cc/tags/2023%E6%9A%91%E6%9C%9F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2023暑期牛客多校06</title>
    <link href="http://www.cclmsy.cc/posts/d9c7e69f.html"/>
    <id>http://www.cclmsy.cc/posts/d9c7e69f.html</id>
    <published>2023-08-03T16:00:00.000Z</published>
    <updated>2023-11-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-Tree"><a href="#A-Tree" class="headerlink" title="A.Tree"></a>A.Tree</h1><p><strong>图论-Kruskal、动态规划</strong></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一棵 $n$ 个节点带点权和边权的无根树</p><p>节点具有颜色白（$0$）和黑（$1$），颜色可反转，所需代价 $cost_i$ 为该点点权</p><p>整棵树的 $earning$ 为 $\sum\limits<em>{u\in V_0}\sum\limits</em>{v\in V_1} val(u,v)$ 。其中， $val(u,v)$ 为节点 $u\rightarrow v$的最短路径上的最大边权， $V_0$ 为白色点集， $V_2$ 为黑色点集</p><p>可以操作反转节点颜色任意次，求最大 $earning-\sum cost$ （以下简称 $score$ ）</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>注意到对于每对黑白点对，其贡献为最短路径上的最大边权。考虑利用Kruskal算法对树进行重构，即按边权从小到大的顺序进行加边</p><p>可以发现，在加入某条边 $e_i$ 时，原本在同一连通分量中的黑白点对的 $score$ 不受影响。由于加边顺序，新加的边一定具有目前最大的边权，因此只有经过新加的这条边的点对才对 $score$ 具有贡献，每个点对的贡献值为 $w_i$ ，点对数量为：$左白\times右黑+左黑\times右白$</p><p>构造dp数组：定义 $dp<em>{i,j}$ 为连通分量 $i$ （以并查集中连通分量的根节点标识）中具有 $j$ 个白色节点时的最大 $score$ 。初始对于点 $i$ ，$dp</em>{i,color<em>i}=0$ （不变）；$dp</em>{i,color_i\oplus 1}=-cost_i$ （反转）</p><p>在合并 $A、B$ 两个连通分量到 $C$ 时具有以下转移方程：</p><script type="math/tex; mode=display">dp_{C,i}=\max\limits_{0\le k \le |A| \And 0\le i-k\le |B|}\{dp_{A,k}+dp_{B,i-k}+w(k(|B|-(i-k))+(i-k)(|A|-k))\}</script><p>（两边原有的 $score$ 加上过新加边的 $score$ ）</p><p>可以结合代码注释进行理解</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(n^2\log n)$</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v;ll w;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">edge</span>():<span class="built_in">u</span>(<span class="number">0</span>),<span class="built_in">v</span>(<span class="number">0</span>),<span class="built_in">w</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="type">int</span> _u,<span class="type">int</span> _v,ll _w): <span class="built_in">u</span>(_u),<span class="built_in">v</span>(_v),<span class="built_in">w</span>(_w) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> edge &amp;b)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="comment">//手写edge类，自定义比较方式</span></span><br><span class="line"><span class="comment">//下面的注释中也添加了不用手写的代码，优点是少写一段代码，缺点是表述较为冗杂不直观</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 3005</span></span><br><span class="line"><span class="type">int</span> dsu[N]=&#123;<span class="number">0</span>&#125;,sz[N]=&#123;<span class="number">0</span>&#125;,color[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">vector&lt;ll&gt; dp[N];<span class="comment">//dp_i,j:集合i有j个白色点时的score</span></span><br><span class="line">vector&lt;edge&gt; Edge;</span><br><span class="line"><span class="comment">//vector&lt;pair&lt;ll,pll&gt;&gt; Edge;//&lt;w,&lt;u,v&gt;&gt;;</span></span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">cost</span><span class="params">(N)</span></span>;</span><br><span class="line"><span class="function">ll <span class="title">find_dsu</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dsu[x]==x?x:dsu[x]=<span class="built_in">find_dsu</span>(dsu[x]);</span><br><span class="line">&#125;<span class="comment">//并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_dsu</span><span class="params">(ll a,ll b,ll w)</span></span>&#123;</span><br><span class="line">    a=<span class="built_in">find_dsu</span>(a);b=<span class="built_in">find_dsu</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(sz[a]&gt;sz[b]) <span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="keyword">if</span>(a==b) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    ll n=sz[a]+sz[b],rt;</span><br><span class="line">    <span class="comment">//n:a,b点集体积之和，即白点数量上限</span></span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">tmp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">        rt=-INF;</span><br><span class="line">        <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;=sz[a];k++) <span class="keyword">if</span>(k&lt;=i&amp;&amp;i-k&lt;=sz[b])&#123;<span class="comment">//k:a中白点数量</span></span><br><span class="line">            ll cnt0=i-k,cnt1=sz[b]-(i-k);<span class="comment">//cnt0:b中白点数量 cnt1:b中黑点数量</span></span><br><span class="line">            rt=<span class="built_in">max</span>(rt,dp[a][k]+dp[b][i-k]+w*(k*cnt1+cnt0*(sz[a]-k)));</span><br><span class="line">            <span class="comment">//dp=max(两点集已经具有的最大earning-cost+经过这条边的点对数*边权)</span></span><br><span class="line">        &#125;</span><br><span class="line">        tmp[i]=rt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dp[b]=tmp;</span><br><span class="line"></span><br><span class="line">    sz[b]+=sz[a];</span><br><span class="line">    dsu[a]=b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    Edge.<span class="built_in">resize</span>(n<span class="number">-1</span>);</span><br><span class="line">    ll u,v,w;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        dp[i].<span class="built_in">resize</span>(<span class="number">2</span>);<span class="comment">//接下来有需求会扩容</span></span><br><span class="line">        dsu[i]=i;sz[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; color[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; cost[i];</span><br><span class="line">        dp[i][color[i]]=(ll)<span class="number">0</span>;</span><br><span class="line">        dp[i][color[i]^<span class="number">1</span>]=(ll)-cost[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e:Edge)&#123;</span><br><span class="line">        cin &gt;&gt; e.u &gt;&gt; e.v &gt;&gt; e.w;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span></span><br><span class="line">        <span class="comment">//e.second.first=u;e.second.second=v;e.first=w;</span></span><br><span class="line">    &#125;<span class="comment">//存边</span></span><br><span class="line">    <span class="built_in">SORT</span>(Edge);<span class="comment">//按边权从小到大重构树</span></span><br><span class="line">    edge e;</span><br><span class="line">    <span class="comment">//pair&lt;ll,pll&gt; e;</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-2</span>)&#123;</span><br><span class="line">        e=Edge[i];</span><br><span class="line">        u=e.u;v=e.v;w=e.w;</span><br><span class="line">        <span class="comment">//u=e.second.first;v=e.second.second;w=e.first;</span></span><br><span class="line">        <span class="built_in">merge_dsu</span>(u,v,w);</span><br><span class="line">    &#125;<span class="keyword">auto</span> tmp=dp[<span class="built_in">find_dsu</span>(<span class="number">1</span>)];</span><br><span class="line">    cout &lt;&lt; *<span class="built_in">max_element</span>(<span class="built_in">ALL</span>(tmp)) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="B-Distance"><a href="#B-Distance" class="headerlink" title="B.Distance"></a>B.Distance</h1><p><strong>数学、贪心(?)</strong></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>对于两个大小相同的多重集 $\mathbb{A},\mathbb{B}$ ，可以选择其中任一元素 $x$ 执行操作 $x=x+1$  任意次数，最少的使得 $\mathbb{A},\mathbb{B}$ 相同的操作次数记为 $C(\mathbb{A},\mathbb{B})$<br>不同大小的 $\mathbb{A},\mathbb{B}$ 视为 $C(\mathbb{A},\mathbb{B})=0$</p><p>现在，给定两个大小为 $n$ 的多重集 $\mathbb{S},\mathbb{T}$ ，求对于 $\mathbb{S},\mathbb{T}$ 的所有子集 $\mathbb{A},\mathbb{B}$ ，最少操作次数之和 $\sum\limits<em>{\mathbb{A} \subseteq \mathbb{S}}\sum\limits</em>{\mathbb{B} \subseteq \mathbb{T}} C(\mathbb{A},\mathbb{B})$ 的值<br>具有相同值的两个元素视为不同元素，答案取模</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>对于某对子集 $\mathbb{A},\mathbb{B}$ ，为了使他们相同的操作次数最少，我们会将他们排序的元素后一一对应，使每一对中较小的数变成较大的数//假设 $a_i$ 与 $b_i$ 对应，他们在这次变化中贡献的操作次数显然是 $|a_i-b_i|$ </p><p>那么换一种角度考虑，对于原多重集 $\mathbb{S},\mathbb{T}$ ，任取一对数 $a<em>i,b_j$ ，考虑它们俩对应的方案数 $cnt</em>{i,j}$ ，那么它们在全部方案中贡献的总操作次数即为 $|a<em>i-b_i|\times cnt</em>{i,j}$</p><p>由于我们的操作策略是排序后对应，因此先对 $\mathbb{S},\mathbb{T}$ 进行排序//<br>选定两个数 $a<em>i,b_j$ 后，它们在 $\mathbb{S},\mathbb{T}$ 中的位置前面选 $k$ 对数的方案数为 $\sum\limits</em>{k=0}^{min(i-1,j-1)}C<em>{i-1}^kC</em>{j-1}^k=C_{i+j-2}^k$ （<a href="https://oi-wiki.org/math/combinatorics/vandermonde-convolution/">范德蒙德卷积</a>）</p><p>同理，它们在 $\mathbb{S},\mathbb{T}$ 中的位置后面选 $k$ 对数的方案数为 $C<em>{2*n-i-j}^k$<br>总方案数为 $cnt</em>{i,j}=C<em>{i+j-2}^kC</em>{2*n-i-j}^k$ ，乘以两数之差的绝对值即为它们对答案的总贡献//</p><p>预处理组合数，枚举 $i,j$ 求和即可</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(n^2)$</p><h2 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 2005</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span>,<span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a) cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:b) cin &gt;&gt; x;</span><br><span class="line">    ll re=<span class="number">0</span>;<span class="built_in">SORT</span>(a);<span class="built_in">SORT</span>(b);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="built_in">FORLL</span>(j,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">addto</span>(re,<span class="built_in">mul</span>(<span class="built_in">abs</span>(a[i]-b[j]),<span class="built_in">mul</span>(<span class="built_in">Get_Combination</span>(i+j,i),<span class="built_in">Get_Combination</span>((n-i<span class="number">-1</span>)+(n-j<span class="number">-1</span>),(n-i<span class="number">-1</span>)))));</span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="C-idol"><a href="#C-idol" class="headerlink" title="C.idol!!"></a>C.idol!!</h1><p><strong>数学</strong></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>正整数 $n$ 的双阶乘 $n!!$ 表示不超过 $n$ 且与 $n$ 有相同奇偶性的所有正整数乘积<br>求对于给定 $n$ ，$\prod\limits_{i=1}^n i!!$ 的后缀 $0$ 个数</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据双阶乘的性质，可以得到： $(n-1)!!\times n!!=n!$<br>因此对于给定的 $n$ ，原式可化为：</p><script type="math/tex; mode=display">\prod\limits_{i=1}^n i!!=\begin{cases}    \prod\limits_{i=1}^\frac{n}{2} (2i)! &,n为偶数 \newline    \prod\limits_{i=1}^\frac{n+1}{2} (2i-1)! &,n为奇数 \end{cases}</script><p>显而易见的，阶乘中因子 $2$ 的个数一定多于因子 $5$ 的个数，因此题目等价于求上式中因子 $5$ 的个数//</p><p>考虑某单一阶乘 $n!$ 中所含因子 $5$ 的个数。<br>可以发现，每个 $5$ 的倍数项会提供 $1$ 个因子 $5$ ，共有 $\lfloor \dfrac{n}{5} \rfloor$ 项<br>除此之外每个 $25=5^2$ 的倍数项会额外提供一个因子 $5$ ，共有 $\lfloor \dfrac{n}{5^2} \rfloor$ 项<br>再除此之外每个 $125=5^3$ 的倍数项会额外提供一个因子 $5$ ，共有 $\lfloor \dfrac{n}{5^3} \rfloor$ 项……<br>因此对于单一阶乘 $n!$ ，其提供因子 $5$ 的数量 $cnt<em>5=\sum\limits</em>{i=1}^N \lfloor \dfrac{n}{5^i} \rfloor (5^N&gt;n)$ </p><p>接着考虑连乘积中因子 $5$ 个数的总和。</p><script type="math/tex; mode=display">ans=\begin{cases}    \sum\limits_{i=1}^\frac{n}{2} \sum\limits_{j=1}^N \lfloor \dfrac{2i}{5^j} \rfloor=\sum\limits_{i=1}^N \sum\limits_{j=1}^\frac{n}{2} \lfloor \dfrac{2j}{5^i} \rfloor &,n为偶数 \newline    \sum\limits_{i=1}^\frac{n+1}{2} \sum\limits_{j=1}^N \lfloor \dfrac{2i-1}{5^j} \rfloor=\sum\limits_{i=1}^N \sum\limits_{j=1}^\frac{n+1}{2} \lfloor \dfrac{2j-1}{5^i} \rfloor &,n为奇数 \end{cases} \newline</script><p>对于某一 $i$ ，发现不论 $n$ 的奇偶， $j=1$ 开始的每 $5^i$ 项之和构成公差为 $2\times5^i$ 的等差数列//<br>例：$i=1$ ，$n$ 为偶数且足够大时，$\lfloor \dfrac{2j}{5^i} \rfloor$ 的前 $15$ 项如下，其中每 $5$ 项之和构成公差为 $5\times 2$ 的等差数列： $0,0,1,1,2||2,2,3,3,4||4,4,5,5,6……$</p><p>经计算，对于某一 $i$ ，等差数列的首项为</p><script type="math/tex; mode=display">a_1=\begin{cases}    \lfloor \dfrac{5^i}{2} \rfloor+2 &,n为偶数 \newline    \lfloor \dfrac{5^i}{2} \rfloor+1 &,n为奇数\end{cases}</script><p>完整的段用等差数列求和，非完整的段手算一下//<br>​<br>若此前完整段的数量记为 $m$ ，则非完整段：<br>前 $\lfloor \dfrac{5^i}{2} \rfloor$ 项的值为 $2m$ ，<br>第 $\lfloor \dfrac{5^i}{2} \rfloor+1$ 至 $2\times\lfloor \dfrac{5^i}{2} \rfloor $ 项的值为 $2m+1$（手搓一下就知道了）</p><p>求和即可</p><p>令 $N=\lfloor \log_5n \rfloor+1$ ，对 $i\in[1,N]$ 遍历求和得到答案</p><p>由于答案数据极其庞大，超出了C++ %lld(64bits)的范围，因此需要使用更高位数的整数类型（如int128）//或者直接转战Python</p><h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(\log n)$</p><h2 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment"># while 1:</span></span><br><span class="line">n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">N=<span class="built_in">int</span>(math.log(n,<span class="number">5</span>)+<span class="number">1</span>)</span><br><span class="line">re=<span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> n%<span class="number">2</span>==<span class="number">0</span> :</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N+<span class="number">1</span>) :</span><br><span class="line">        <span class="comment">#print(&quot;i=&quot;+str(i))</span></span><br><span class="line">        a1=(<span class="number">5</span>**i)//<span class="number">2</span>+<span class="number">2</span> <span class="comment">#首项</span></span><br><span class="line">        <span class="comment">#print(&quot;a1=&quot;+str(a1))</span></span><br><span class="line">        d=(<span class="number">5</span>**i)*<span class="number">2</span> <span class="comment">#公差</span></span><br><span class="line">        <span class="comment">#print(&quot;d=&quot;+str(d))</span></span><br><span class="line">        m=(n//<span class="number">2</span>)//(<span class="number">5</span>**i) <span class="comment">#完整段数</span></span><br><span class="line">        <span class="comment">#print(&quot;m=&quot;+str(m))</span></span><br><span class="line">        re+=(<span class="number">2</span>*a1+(m-<span class="number">1</span>)*d)*m//<span class="number">2</span> <span class="comment">#完整段等差数列求和</span></span><br><span class="line">        <span class="comment">#print(&quot;re1:&quot; + str(re))</span></span><br><span class="line">        re+=(n//<span class="number">2</span>-m*(<span class="number">5</span>**i))*<span class="number">2</span>*m <span class="comment">#最后一段余项求和</span></span><br><span class="line">        <span class="comment">#print(&quot;re2:&quot; + str(re))</span></span><br><span class="line">        <span class="comment">#print(&quot;pl1=&quot; + str((n//2-m*(5**i))*2*m))</span></span><br><span class="line">        <span class="keyword">if</span> n//<span class="number">2</span>-m*(<span class="number">5</span>**i)&gt;(<span class="number">5</span>**i)//<span class="number">2</span> :</span><br><span class="line">            re+=n//<span class="number">2</span>-m*(<span class="number">5</span>**i)-(<span class="number">5</span>**i)//<span class="number">2</span></span><br><span class="line">            <span class="comment">#print(&quot;pl2=&quot; + str(n//2-m*(5**i)-(5**i)//2))</span></span><br><span class="line">                </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n%<span class="number">2</span> :</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N+<span class="number">1</span>) :</span><br><span class="line">        <span class="comment">#print(&quot;i=&quot;+str(i))</span></span><br><span class="line">        a1=(<span class="number">5</span>**i)//<span class="number">2</span>+<span class="number">1</span> <span class="comment">#首项</span></span><br><span class="line">        <span class="comment">#print(&quot;a1=&quot;+str(a1))</span></span><br><span class="line">        d=(<span class="number">5</span>**i)*<span class="number">2</span> <span class="comment">#公差</span></span><br><span class="line">        <span class="comment">#print(&quot;d=&quot;+str(d))</span></span><br><span class="line">        m=((n+<span class="number">1</span>)//<span class="number">2</span>)//(<span class="number">5</span>**i) <span class="comment">#完整段数</span></span><br><span class="line">        <span class="comment">#print(&quot;m=&quot;+str(m))</span></span><br><span class="line">        re+=(<span class="number">2</span>*a1+(m-<span class="number">1</span>)*d)*m//<span class="number">2</span> <span class="comment">#完整段等差数列求和</span></span><br><span class="line">        <span class="comment">#print(&quot;re1:&quot; + str(re))</span></span><br><span class="line">        re+=((n+<span class="number">1</span>)//<span class="number">2</span>-m*(<span class="number">5</span>**i))*<span class="number">2</span>*m <span class="comment">#最后一段余项求和</span></span><br><span class="line">        <span class="comment">#print(&quot;re2:&quot; + str(re)) </span></span><br><span class="line">        <span class="comment">#print(&quot;pl1=&quot; + str(((n+1)//2-m*(5**i))*2*m))</span></span><br><span class="line">        <span class="keyword">if</span> (n+<span class="number">1</span>)//<span class="number">2</span>-m*(<span class="number">5</span>**i)&gt;(<span class="number">5</span>**i)//<span class="number">2</span> :</span><br><span class="line">            re+=(n+<span class="number">1</span>)//<span class="number">2</span>-m*(<span class="number">5</span>**i)-(<span class="number">5</span>**i)//<span class="number">2</span></span><br><span class="line">            <span class="comment">#print(&quot;pl2=&quot; + str((n+1)//2-m*(5**i)-(5**i)//2))</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(re)</span><br></pre></td></tr></table></figure><hr><h1 id="E-Sequence"><a href="#E-Sequence" class="headerlink" title="E.Sequence"></a>E.Sequence</h1><p><strong>思维题</strong></p><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个长度为 $n$ 的正整数序列，并进行 $q$ 次询问<br>每次询问给定一个范围 $[l,r]$ 和一个正整数 $k$<br>问能否将序列中给定范围内的子序列划分为 $k$ 段非空区间，且每段区间之和为偶数</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先对于给定区间：</p><ol><li>给定区间内总元素个数不足 $k$ ，则无法划分</li><li>给定区间内奇数元素个数为奇数，则给定区间的和为奇数，无法划分为 $k$ 个和为偶数的区间</li><li>给定区间内奇数元素个数为偶数，则最优划分为：从前往后奇数两两匹配形成区间，余下的偶数自成一个区间</li></ol><p>因此本题的关键就在于区间内奇数的处理</p><p>输入的记录奇数所在的位置，每次询问对于给定的区间，二分查找第一次出现奇数的位置和最后一次出现的位置，判断奇数个数<br>符合要求再进行区间计数判断，具体实现和解释可以参考代码注释</p><h3 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>2023/8/5：纠正：最坏时间复杂度为 $O(qn)$ ，卡一下平均能过qwq</p><h2 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,q,t;cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    vector&lt;ll&gt; v,odd;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;v.<span class="built_in">emplace_back</span>(t);</span><br><span class="line">        <span class="keyword">if</span>(t&amp;<span class="number">1</span>) odd.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    &#125;<span class="comment">//奇数下标存入odd,O(n)</span></span><br><span class="line">    ll l,r,k;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,q)&#123;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">        <span class="keyword">if</span>(r-l&lt;k<span class="number">-1</span>) &#123;cout &lt;&lt; NO;<span class="keyword">continue</span>;&#125;<span class="comment">//元素数量小于k</span></span><br><span class="line">        <span class="keyword">if</span>(odd.<span class="built_in">empty</span>()) &#123;cout &lt;&lt; YES;<span class="keyword">continue</span>;&#125;<span class="comment">//整个序列无奇数</span></span><br><span class="line">        <span class="keyword">auto</span> ol=<span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(odd),l);<span class="comment">//找到区间左端点右边最近的奇数的位置</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">upper_bound</span>(<span class="built_in">ALL</span>(odd),r)-ol)&amp;<span class="number">1</span>) &#123;cout &lt;&lt; NO;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="comment">//如果区间内奇数个数为奇数个，一定会残留一个区间和为奇数的区间</span></span><br><span class="line">        ll cnt=<span class="number">0</span>;<span class="comment">//最多区间计数</span></span><br><span class="line">        <span class="keyword">while</span>(ol!=odd.<span class="built_in">end</span>()&amp;&amp;*ol&lt;=r)&#123;<span class="comment">//下一个奇数在区间内</span></span><br><span class="line">            cnt+=*ol-l;ol++;<span class="comment">//奇数左边的偶数一个记一段</span></span><br><span class="line">            <span class="keyword">if</span>(*ol&lt;=r) cnt++;<span class="comment">//两个奇数之间记一段</span></span><br><span class="line">            l=*ol+<span class="number">1</span>;ol++;<span class="comment">//更新左端点</span></span><br><span class="line">        &#125;<span class="keyword">if</span>(ol==odd.<span class="built_in">begin</span>()) &#123;cout &lt;&lt; YES;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        ol--;cnt+=r-*ol;<span class="comment">//加上区间右边剩余偶数</span></span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=k) cout &lt;&lt; YES;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; NO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="G-Gcd"><a href="#G-Gcd" class="headerlink" title="G.Gcd"></a>G.Gcd</h1><p><strong>数论</strong></p><h2 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个包含两个非负数的初始集合 $S={x,y}$<br>每次操作可以选定其中不相等的两个数 $a,b$ ，并将 $a-b$ 或 $gcd(a,b)$ 置入集合 $S$ ，其中 $gcd(0,a)=a$<br>可以操作任意次，问能否使得集合 $S$ 包含非负数 $z$</p><h3 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h3><p><a href="https://oi-wiki.org/math/number-theory/bezouts/">裴蜀定理</a></p><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据裴蜀定理，两个正整数辗转相减只能得到他们最大公约数的倍数//<br>因此对于 $z$ ，判断其是否是 $g=gcd(x,y)$ 的倍数即可。<br>如果 $z$ 是 $g$ 的倍数，则可以通过以下操作得到 $z$ ：</p><ol><li>将 $g=gcd(x,y)$ 置入集合</li><li>$x$ 作为 $g$ 的倍数，其加减任意次 $g$ 便可得到任意 $g$ 的倍数。<br>只能减不能加怎么办呢//先把 $x$ 减到 $-g$ 就好了</li></ol><p>值得注意的是，本题的数据约束为<strong>非负数</strong>，这意味着需要对 $0$ 的情况进行特判//</p><ol><li>对于 $z=0$ ，仅当 $x,y$ 有 $0$ 时有解</li><li>对于 $x=0$ 或 $y=0$ ，仅当 $z$ 为非 $0$ 项的倍数时有解（实际上这条也满足裴蜀定理，直接归入一般情况即可）</li></ol><p>参考样例：<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">in</span>: <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="attribute">out</span>: YES</span><br></pre></td></tr></table></figure></p><h2 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y,z;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">    <span class="keyword">if</span>(x&amp;&amp;y&amp;&amp;z==<span class="number">0</span>) &#123;cout &lt;&lt; NO;<span class="keyword">return</span>;&#125;</span><br><span class="line">    ll g=<span class="built_in">gcd</span>(x,y);</span><br><span class="line">    <span class="keyword">if</span>(z%g) cout &lt;&lt; NO;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2023暑期牛客多校06</summary>
    
    
    
    <category term="算法竞赛" scheme="http://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2023暑期牛客多校" scheme="http://www.cclmsy.cc/tags/2023%E6%9A%91%E6%9C%9F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2023暑期杭电多校06</title>
    <link href="http://www.cclmsy.cc/posts/93944a48.html"/>
    <id>http://www.cclmsy.cc/posts/93944a48.html</id>
    <published>2023-08-02T16:00:00.000Z</published>
    <updated>2023-11-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1001-Count"><a href="#1001-Count" class="headerlink" title="1001.Count"></a>1001.Count</h1><p><strong>构造</strong></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定 $n,m,k$ ，构造长度为 $n$ 的整数序列，元素大小范围为 $a_i\in [1,m]$ ，并且需要保证前 $k$ 个元素和后 $k$ 个元素对应相同<br>求可以构造出的序列数量</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>模拟一下即可<br>对于 $k\le \dfrac{n}{2}$ ，最后 $k$ 个元素由前 $k$ 个元素确定，只需决定前 $n-k$ 个元素<br>对于 $\dfrac{n}{2}\le k \lt n$ ，确定了前 $n-k$ 个元素，可以递归向后确定更多元素<br>对于 $k=n$ ，序列本身自然相同，即可以随意确定 $n$ 个元素</p><p>确定 $x$ 个元素的方案总数为 $m^{x}$ ，快速幂取模即可<br>(P.S.):快速幂前先对底数取模// </p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>快速幂： $O(\log n)$</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">if</span>(n==k) cout &lt;&lt; <span class="built_in">qcpow</span>(m,n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">qcpow</span>(m,n-k) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2023暑期杭电多校06</summary>
    
    
    
    <category term="算法竞赛" scheme="http://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2023暑期杭电多校" scheme="http://www.cclmsy.cc/tags/2023%E6%9A%91%E6%9C%9F%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
</feed>
